<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="title: AFNetworking 3.0 源码解析之NSURLSessiondate: 2016-09-28 16:29:11NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。
下面分两个部分来解析：
 父类：NSURLSessionManager，
 子类：AFHTTPSessionManager
父类NSURLSessionManager对系统的NSU">
<meta property="og:type" content="article">
<meta property="og:title" content="Semyon Xu's Blog">
<meta property="og:url" content="http://yoursite.com/2016/09/28/AFNetworking-3-0-源码解析之NSURLSession/index.html">
<meta property="og:site_name" content="Semyon Xu's Blog">
<meta property="og:description" content="title: AFNetworking 3.0 源码解析之NSURLSessiondate: 2016-09-28 16:29:11NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。
下面分两个部分来解析：
 父类：NSURLSessionManager，
 子类：AFHTTPSessionManager
父类NSURLSessionManager对系统的NSU">
<meta property="og:updated_time" content="2016-09-28T09:51:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Semyon Xu's Blog">
<meta name="twitter:description" content="title: AFNetworking 3.0 源码解析之NSURLSessiondate: 2016-09-28 16:29:11NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。
下面分两个部分来解析：
 父类：NSURLSessionManager，
 子类：AFHTTPSessionManager
父类NSURLSessionManager对系统的NSU">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/09/28/AFNetworking-3-0-源码解析之NSURLSession/"/>

  <title>  | Semyon Xu's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Semyon Xu's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-28T16:29:11+08:00" content="2016-09-28">
              2016-09-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<p>title: AFNetworking 3.0 源码解析之NSURLSession<br>date: 2016-09-28 16:29:11<br>NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。</p>
<p>下面分两个部分来解析：</p>
<p> 父类：NSURLSessionManager，</p>
<p> 子类：AFHTTPSessionManager</p>
<p>父类NSURLSessionManager对系统的NSURLSession类的网络请求进行了封装，并把NSURLSession里面的delegate返回值通过block返回回去。<br>子类AFHTTPSessionManager继承了所有父类的功能，在这个基础上封装了支持GET，POST，PUT，HEAD，PATCH，DELETE等HTTP请求方式，使用更加方便。当然不用子类，也是可以直接进行网络请求的。</p>
<p>#NSURLSessionManager</p>
<p>####1）先看初始化方法</p>
<pre><code>- (instancetype)init {
return [self initWithSessionConfiguration:nil];
}

- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration {
self = [super init];
if (!self) {
    return nil;
}

if (!configuration) {
    configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
}

self.sessionConfiguration = configuration;

self.operationQueue = [[NSOperationQueue alloc] init];
self.operationQueue.maxConcurrentOperationCount = 1; // 最大并发数量1，不允许并发？当前请求任务只能是一个。

self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 代理的设置在这里。我找的好苦啊

self.responseSerializer = [AFJSONResponseSerializer serializer];

self.securityPolicy = [AFSecurityPolicy defaultPolicy];

#if !TARGET_OS_WATCH
   self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];
#endif

   self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];

self.lock = [[NSLock alloc] init];
self.lock.name = AFURLSessionManagerLockName;

[self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
    for (NSURLSessionDataTask *task in dataTasks) {
        [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];
    }

    for (NSURLSessionUploadTask *uploadTask in uploadTasks) {
        [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];
    }

    for (NSURLSessionDownloadTask *downloadTask in downloadTasks) {
        [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];
    }
}];

return self;
}
</code></pre><p>这里对各个属性进行了基本的初始化，为session初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSessionsessionWithConfiguration:self.sessionConfigurationdelegate:selfdelegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>我们可以看到是用的系统NSURLSession的初始化方法。</p>
<p>此处会遍历所有task添加delegate方法，猜测是兼容上次为未完成的请求Task，再继续进行处理，具体还得看情况，因为我跟了多次都是没有走这个方法。</p>
<p>####2）网络请求支持的几个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///---------------------------</div><div class="line">/// @name Running Upload Tasks</div><div class="line">///---------------------------</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromFile:(NSURL *)fileURL</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromData:(nullable NSData *)bodyData</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</div><div class="line">                                                 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///-----------------------------</div><div class="line">/// @name Running Download Tasks</div><div class="line">///-----------------------------</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                             progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData</div><div class="line">                                                progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                             destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                       completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div><div class="line">```                                     </div><div class="line">   </div><div class="line">这里面封装了系统NSURLSession的dataTask、uploadTask、downloadTask方法。而且另外添加了数据的进度progress。</div><div class="line"></div><div class="line">下面我们来解析一下实现原理：</div><div class="line">首先看一下dataTask的请求：</div></pre></td></tr></table></figure>
<ul>
<li><p>(NSURLSessionDataTask <em>)dataTaskWithRequest:(NSURLRequest </em>)request</p>
<pre><code>   uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
 downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler {
</code></pre><p>  __block NSURLSessionDataTask *dataTask = nil;<br>  url_session_manager_create_task_safely(^{</p>
<pre><code>dataTask = [self.session dataTaskWithRequest:request]; // 核心方法，NSURLSessionDataTask的dataTask方法。
</code></pre><p>  });</p>
<p>  [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; // 设置代理，所有进度的处理都在代理中。进度的回调。</p>
<p>  return dataTask;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以看到，这里使用的是NSURLSessionDataTask的dataTaskWithRequest:方法，这个地方加了数据保护。然后就是为这个dataTask添加代理。所以核心的工作都交个这个代理AFURLSessionManagerTaskDelegate类来处理，那么这个代理的作用就显得尤为重要。</div><div class="line"></div><div class="line">####3）网络请求的代理类AFURLSessionManagerTaskDelegate</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@interface AFURLSessionManagerTaskDelegate : NSObject <nsurlsessiontaskdelegate, nsurlsessiondatadelegate,="" nsurlsessiondownloaddelegate=""><br>@property (nonatomic, weak) AFURLSessionManager <em>manager;<br>@property (nonatomic, strong) NSMutableData </em>mutableData;<br>@property (nonatomic, strong) NSProgress <em>uploadProgress;<br>@property (nonatomic, strong) NSProgress </em>downloadProgress;<br>@property (nonatomic, copy) NSURL *downloadFileURL;<br>@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading; // 下载任务结束回调<br>@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock; // 上传进度回调<br>@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock; // 下载进度回调<br>@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler; // 返回成功结果的Block<br>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里遵循了NSURLSessionDataDelegate,NSURLSessionDataDelegate,NSURLSessionDownloadDelegate,所以是将NSURLSession的基本代理功能封装了一下。然后会对这些代理方法的返回数据进行处理，使用completionHandler Block来进行返回。</div><div class="line"></div><div class="line">首先来看下代理的核心部分，然后再解读progress的封装思路</div><div class="line"></div><div class="line">##### A.代理的核心部分</div></pre></td></tr></table></figure></nsurlsessiontaskdelegate,></p>
<p>#pragma mark - NSURLSessionTaskDelegate</p>
<ul>
<li><p>(void)URLSession:(__unused NSURLSession *)session</p>
<pre><code>task:(NSURLSessionTask *)task
</code></pre><p>didCompleteWithError:(NSError <em>)error<br>{<br>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wgnu”<br>  __strong AFURLSessionManager </em>manager = self.manager;</p>
<p>  __block id responseObject = nil;</p>
<p>  __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];<br>  userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</p>
<p>  //Performance Improvement from #2672<br>  NSData *data = nil;<br>  if (self.mutableData) {</p>
<pre><code>data = [self.mutableData copy];
//We no longer need the reference, so nil it out to gain back some memory.
self.mutableData = nil;
</code></pre><p>  }</p>
<p>  if (self.downloadFileURL) {</p>
<pre><code>userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;
</code></pre><p>  } else if (data) {</p>
<pre><code>userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;
</code></pre><p>  }</p>
<p>  if (error) {</p>
<pre><code>userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;

dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ // 单利group对象，why？这样是不是就可以对多个返回结果进行处理，这样的话，就不用顺序等待了，哪个先完成就先返回回去。
    // 看参数：如果用户传了group对象，那么选择的是用户的，否则直接使用单利的组对象。 队列是默认是主队列，用户填写的就是用户的。
    if (self.completionHandler) { // 最终的回调结果
        self.completionHandler(task.response, responseObject, error);
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
    });
});
</code></pre><p>  } else {</p>
<pre><code>dispatch_async(url_session_manager_processing_queue(), ^{
    NSError *serializationError = nil;
    responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 成功后数据的解析

    if (self.downloadFileURL) { // 下载的情况下，responseObject为下载的本地地址
        responseObject = self.downloadFileURL;
    }

    if (responseObject) {
        userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;
    }

    if (serializationError) {
        userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;
    }

    dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ // why use gcd group?
        if (self.completionHandler) { // 最终的回调结果
            self.completionHandler(task.response, responseObject, serializationError); // response Header, 返回结果， 解析错误。
        }

        dispatch_async(dispatch_get_main_queue(), ^{ // 此处任务完成的通知只是为了UIKit中的一些类别中拿到回调。userInfo字段并没有返回给外部，而是给UIKit用的。当然我们可以用这个通知来获取到。
            [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];
        });
    });
});
</code></pre><p>  }<br>#pragma clang diagnostic pop<br>}</p>
</li>
</ul>
<p>#pragma mark - NSURLSessionDataTaskDelegate</p>
<ul>
<li>(void)URLSession:(__unused NSURLSession *)session<pre><code>dataTask:(__unused NSURLSessionDataTask *)dataTask
</code></pre>  didReceiveData:(NSData *)data<br>{<br>  [self.mutableData appendData:data];<br>}</li>
</ul>
<p>#pragma mark - NSURLSessionDownloadTaskDelegate</p>
<ul>
<li><p>(void)URLSession:(NSURLSession *)session</p>
<pre><code>downloadTask:(NSURLSessionDownloadTask *)downloadTask
</code></pre><p>didFinishDownloadingToURL:(NSURL <em>)location<br>{<br>  NSError </em>fileManagerError = nil;<br>  self.downloadFileURL = nil;</p>
<p>  if (self.downloadTaskDidFinishDownloading) {</p>
<pre><code>self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);
if (self.downloadFileURL) {
    [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];

    if (fileManagerError) {
        [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];
    }
}
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以看到这里核心的方法只有三个，一个是task完成的回调，一个是接受到数据的回调，最后是下载完成的回调。</div><div class="line">普通的task请求会先走第二个方法didReceiveData方法，把返回的数据添加到mutableData中。</div><div class="line">然后再走第一个方法，请求完成的回调。</div><div class="line"></div><div class="line">###### 读一下这个方法：</div><div class="line">首先会把返回的数据赋给一个局部变量data，然后将全局的mutableData置空，这样就可以保证下次请求的数据是重新加载。这里区分了下载和普通的数据返回，如果是下载的话，直接下载到指定文件路径中，如果用户指定这个路径的话，userInfo字典里面存的就是下载路径，否则，存的是下载数据。</div><div class="line">然后就是判断有没有错误，错误的话把错误返回，返回值task.response, responseObject此处是空的，然后就是error。最后在主线程中发送通知，为当前task的userInfo，注意此处的userInfo只是用来做通知信息的。而我们平时用的时候不会用通知来获取请求成功的回调，这个通知是为了AFNetworking中的UIKit封装部分服务的。</div><div class="line">然后就是成功的回调，异步请求在单利队列中，这里对队列的生成都加了单利的保护。这里通过responseSerializer 对结果数据进行转化成对应的格式（这可以参考Serialization部分，里面讲解如何转化的），如果是下载的话，responseObject直接赋值成downloadFileURL，也就是下载的话，回调中只会有下载的目标地址。然后就是对userInfo的AFNetworkingTaskDidCompleteSerializedResponseKey（序列化响应结果）、AFNetworkingTaskDidCompleteErrorKey（序列化过程中的错误信息）进行赋值，不得不说AFNetworking对各个部分的情况都返回回去了，做的很详细。</div><div class="line">然后就是调用回调block：completionHandler：</div><div class="line">返回值task.response也就是完整的返回头信息以及返回的状态码。</div><div class="line">responseObject是返回的数据或者是下载的目标地址。</div><div class="line">serializationError注意这个地方的错误是序列化的错误，也就是此处如果对返回数据序列化产生错误，也会照样返回成功回调，只是回调结果会是序列化的错误。</div><div class="line">最后还是一样的发送通知。</div><div class="line"></div><div class="line">###### 第二个方法：</div><div class="line">简单的接收到返回数据，简单的把数据进行拼接。</div><div class="line"></div><div class="line">###### 第三个方法：</div><div class="line">下载的方法，此处如果有downloadTaskDidFinishDownloading的实现，那么进行调用转换目标地址，而目标地址是在下面这个方法的destination Block中进行设置的，这个地方转了一下，也就是倒了两个block让用户来设置这个目标地址。如果可以正常获取这个目标地址的话，把location（也就是本地下载路径，其实就是缓存路径，因为这里下载完成后会删掉）的数据转移到目标路径。响应的会有文件操作的错误信息的处理。</div></pre></td></tr></table></figure>
</li>
<li><p>(void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</p>
<pre><code>         progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock
      destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler
</code></pre><p>{<br>  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];<br>  delegate.manager = self;<br>  delegate.completionHandler = completionHandler;</p>
<p>  if (destination) {</p>
<pre><code>delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) {
    return destination(location, task.response);
};
</code></pre><p>  }</p>
<p>  downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</p>
<p>  [self setDelegate:delegate forTask:downloadTask];</p>
<p>  delegate.downloadProgressBlock = downloadProgressBlock;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### B. 网络请求progress的封装思路</div><div class="line">此处使用的技术是KVO，先看代码：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setupProgressForTask:(NSURLSessionTask *)task {<br>  <strong>weak </strong>typeof__(task) weakTask = task;</p>
<p>  self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;<br>  self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;<br>  [self.uploadProgress setCancellable:YES];<br>  [self.uploadProgress setCancellationHandler:^{</p>
<pre><code>__typeof__(weakTask) strongTask = weakTask;
[strongTask cancel];
</code></pre><p>  }];<br>  [self.uploadProgress setPausable:YES];<br>  [self.uploadProgress setPausingHandler:^{</p>
<pre><code>__typeof__(weakTask) strongTask = weakTask;
[strongTask suspend];
</code></pre><p>  }];<br>  if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) {</p>
<pre><code>[self.uploadProgress setResumingHandler:^{
    __typeof__(weakTask) strongTask = weakTask;
    [strongTask resume];
}];
</code></pre><p>  }</p>
<p>  [self.downloadProgress setCancellable:YES];<br>  [self.downloadProgress setCancellationHandler:^{</p>
<pre><code>__typeof__(weakTask) strongTask = weakTask;
[strongTask cancel];
</code></pre><p>  }];<br>  [self.downloadProgress setPausable:YES];<br>  [self.downloadProgress setPausingHandler:^{</p>
<pre><code>__typeof__(weakTask) strongTask = weakTask;
[strongTask suspend];
</code></pre><p>  }];</p>
<p>  if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) {</p>
<pre><code>[self.downloadProgress setResumingHandler:^{
    __typeof__(weakTask) strongTask = weakTask;
    [strongTask resume];
}];
</code></pre><p>  }</p>
<p>  [task addObserver:self</p>
<pre><code>forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))
   options:NSKeyValueObservingOptionNew
   context:NULL];
</code></pre><p>  [task addObserver:self</p>
<pre><code>forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))
   options:NSKeyValueObservingOptionNew
   context:NULL];
</code></pre><p>  [task addObserver:self</p>
<pre><code>forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))
   options:NSKeyValueObservingOptionNew
   context:NULL];
</code></pre><p>  [task addObserver:self</p>
<pre><code>forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))
   options:NSKeyValueObservingOptionNew
   context:NULL];
</code></pre><p>  [self.downloadProgress addObserver:self</p>
<pre><code>forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
   options:NSKeyValueObservingOptionNew
   context:NULL];
</code></pre><p>  [self.uploadProgress addObserver:self</p>
<pre><code>forKeyPath:NSStringFromSelector(@selector(fractionCompleted))
   options:NSKeyValueObservingOptionNew
   context:NULL];
</code></pre><p>}</p>
</li>
<li><p>(void)cleanUpProgressForTask:(NSURLSessionTask *)task {<br>  [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];<br>  [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))];<br>  [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];<br>  [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))];<br>  [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];<br>  [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];<br>}</p>
</li>
<li><p>(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString </em>,id&gt; <em>)change context:(void </em>)context {<br>  if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) {</p>
<pre><code>if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) {
    self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];
} else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) {
    self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];
} else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) {
    self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];
} else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) {
    self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];
}
</code></pre><p>  }<br>  else if ([object isEqual:self.downloadProgress]) {</p>
<pre><code>if (self.downloadProgressBlock) {
    self.downloadProgressBlock(object);
}
</code></pre><p>  }<br>  else if ([object isEqual:self.uploadProgress]) {</p>
<pre><code>if (self.uploadProgressBlock) {
    self.uploadProgressBlock(object);
}
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">初始化方法中我们可以看到KVO监听的KeyPath是NSURLSessionTask的四个只读属性：countOfBytesReceived, countOfBytesExpectedToReceive, countOfBytesSent, countOfBytesExpectedToSend， 也就是Task的数据统计的一些信息。 downloadProgress和uploadProgress都对fractionCompleted进行监听，也就是进度完成的百分比。</div><div class="line">这里cleanUp移除所有的KVO，KVO我们平时使用的时候也是需要注意移除的，防止发生原来的还在，又添加监听导致多次监听，那么悲剧了，就是执行监听结果方法的调用越来越多。莫名其妙的bug。</div><div class="line">最后KVO监听到结果的回调中，对downloadProgress，uploadProgress分别进行completedunitCount完成进度的赋值、totalUnitCount所有进度的复制。如果对象不是task而是NSProgress对象，那么直接把这个object返回回去。</div><div class="line"></div><div class="line">####4）NSURLSession代理方法的转换处理</div><div class="line">首先这里会有很多block的回调：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession <em>session, NSError </em>error))block;</p>
</li>
<li><p>(void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession <em>session, NSURLAuthenticationChallenge </em>challenge, NSURLCredential <em> _Nullable __autoreleasing </em> _Nullable credential))block;</p>
</li>
</ul>
<p>///————————————–<br>/// @name Setting Task Delegate Callbacks<br>///————————————–</p>
<ul>
<li><p>(void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream <em> (^)(NSURLSession </em>session, NSURLSessionTask *task))block;</p>
</li>
<li><p>(void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest <em> (^)(NSURLSession </em>session, NSURLSessionTask <em>task, NSURLResponse </em>response, NSURLRequest *request))block;</p>
</li>
<li><p>(void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession <em>session, NSURLSessionTask </em>task, NSURLAuthenticationChallenge <em>challenge, NSURLCredential </em> _Nullable __autoreleasing * _Nullable credential))block;</p>
</li>
<li><p>(void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession <em>session, NSURLSessionTask </em>task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</p>
</li>
<li><p>(void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession <em>session, NSURLSessionTask </em>task, NSError * _Nullable error))block;</p>
</li>
</ul>
<p>///——————————————-<br>/// @name Setting Data Task Delegate Callbacks<br>///——————————————-</p>
<ul>
<li><p>(void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession <em>session, NSURLSessionDataTask </em>dataTask, NSURLResponse *response))block;</p>
</li>
<li><p>(void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession <em>session, NSURLSessionDataTask </em>dataTask, NSURLSessionDownloadTask *downloadTask))block;</p>
</li>
<li><p>(void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession <em>session, NSURLSessionDataTask </em>dataTask, NSData *data))block;</p>
</li>
<li><p>(void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse <em> (^)(NSURLSession </em>session, NSURLSessionDataTask <em>dataTask, NSCachedURLResponse </em>proposedResponse))block;</p>
</li>
<li><p>(void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block;</p>
</li>
</ul>
<p>///———————————————–<br>/// @name Setting Download Task Delegate Callbacks<br>///———————————————–</p>
<ul>
<li><p>(void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL <em> _Nullable  (^)(NSURLSession </em>session, NSURLSessionDownloadTask <em>downloadTask, NSURL </em>location))block;</p>
</li>
<li><p>(void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession <em>session, NSURLSessionDownloadTask </em>downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</p>
</li>
<li><p>(void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession <em>session, NSURLSessionDownloadTask </em>downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">也就是支持对所有的NSURLSession代理方法的回调方法直接使用block传给用户使用，这里既支持我们处理原始的回调，AFNetworking在里面继续做响应的处理。</div><div class="line"></div><div class="line">具体方法的处理，由于太多了，我们就分析一下几个：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)URLSession:(NSURLSession *)session</p>
<pre><code>task:(NSURLSessionTask *)task
</code></pre><p>didCompleteWithError:(NSError <em>)error<br>{<br>  AFURLSessionManagerTaskDelegate </em>delegate = [self delegateForTask:task];</p>
<p>  // delegate may be nil when completing a task in the background<br>  if (delegate) {</p>
<pre><code>[delegate URLSession:session task:task didCompleteWithError:error];

[self removeDelegateForTask:task];
</code></pre><p>  }</p>
<p>  if (self.taskDidComplete) {</p>
<pre><code>self.taskDidComplete(session, task, error);
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个方法会获取到当前task的delegate对象，然后在代理中对这些数据进行处理。这个方法是在网络完成的时候执行的，所以这里应该将这个task移除掉。数据的处理参见3)里面的AFURLSessionManagerTaskDelegate的方法解析。 最后会执行taskDidComplete的block回调。</div></pre></td></tr></table></figure>
</li>
<li><p>(void)URLSession:(NSURLSession *)session</p>
<pre><code>downloadTask:(NSURLSessionDownloadTask *)downloadTask
</code></pre><p>didFinishDownloadingToURL:(NSURL <em>)location<br>{<br>  AFURLSessionManagerTaskDelegate </em>delegate = [self delegateForTask:downloadTask];<br>  if (self.downloadTaskDidFinishDownloading) {</p>
<pre><code>NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); // block 带入目标地址的url，在外面设置
if (fileURL) {
    delegate.downloadFileURL = fileURL;
    NSError *error = nil;
    [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];
    if (error) {
        [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];
    }

    return;
}
</code></pre><p>  }</p>
<p>  if (delegate) {</p>
<pre><code>[delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">download的完成方法的回调，我们看到跟AFURLSessionManagerTaskDelegate中的方法功能基本是一样的，也就是如果有AFURLSessionManager类中有downloadTaskDidFinishDownloading的block实现的话，就直接在NSURLSessionDownloadDelegate中处理，如果现在还没有实现block，那么就放在delegete里面处理。注意这个地方AFURLSessionManager和NSURLSessionDownloadDelegate都有这个downloadTaskDidFinishDownloading 的block。</div><div class="line"></div><div class="line">就这俩吧，其他的代理方法基本上都是转换成block进行回调，有的复杂一点需要对block的值进行处理一下，然后在回调回去。</div><div class="line"></div><div class="line">####5）关于多任务的处理</div></pre></td></tr></table></figure>
</li>
<li><p>(AFURLSessionManagerTaskDelegate <em>)delegateForTask:(NSURLSessionTask </em>)task {<br>  NSParameterAssert(task);</p>
<p>  AFURLSessionManagerTaskDelegate *delegate = nil;<br>  [self.lock lock];<br>  delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];<br>  [self.lock unlock];</p>
<p>  return delegate;<br>}</p>
</li>
<li><p>(void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</p>
<pre><code>forTask:(NSURLSessionTask *)task
</code></pre><p>{<br>  NSParameterAssert(task);<br>  NSParameterAssert(delegate);</p>
<p>  [self.lock lock];<br>  self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>  [delegate setupProgressForTask:task];<br>  [self addNotificationObserverForTask:task];<br>  [self.lock unlock];<br>}</p>
</li>
<li><p>(void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</p>
<pre><code>   uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock
 downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock
completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
</code></pre><p>{<br>  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];<br>  delegate.manager = self;<br>  delegate.completionHandler = completionHandler;</p>
<p>  dataTask.taskDescription = self.taskDescriptionForSessionTasks;<br>  [self setDelegate:delegate forTask:dataTask];</p>
<p>  delegate.uploadProgressBlock = uploadProgressBlock;<br>  delegate.downloadProgressBlock = downloadProgressBlock;<br>}</p>
</li>
<li><p>(void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask</p>
<pre><code>         progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock
completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler
</code></pre><p>{<br>  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];<br>  delegate.manager = self;<br>  delegate.completionHandler = completionHandler;</p>
<p>  uploadTask.taskDescription = self.taskDescriptionForSessionTasks;</p>
<p>  [self setDelegate:delegate forTask:uploadTask];</p>
<p>  delegate.uploadProgressBlock = uploadProgressBlock;<br>}</p>
</li>
<li><p>(void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</p>
<pre><code>         progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock
      destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination
completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler
</code></pre><p>{<br>  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];<br>  delegate.manager = self;<br>  delegate.completionHandler = completionHandler;</p>
<p>  if (destination) {</p>
<pre><code>delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) {
    return destination(location, task.response);
};
</code></pre><p>  }</p>
<p>  downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</p>
<p>  [self setDelegate:delegate forTask:downloadTask];</p>
<p>  delegate.downloadProgressBlock = downloadProgressBlock;<br>}</p>
</li>
<li><p>(void)removeDelegateForTask:(NSURLSessionTask *)task {<br>  NSParameterAssert(task);</p>
<p>  AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];<br>  [self.lock lock];<br>  [delegate cleanUpProgressForTask:task];<br>  [self removeNotificationObserverForTask:task];<br>  [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];<br>  [self.lock unlock];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里是支持多任务请求的。这里使用字典存的是当前task的代理AFURLSessionManagerTaskDelegate的delegate：</div><div class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;</div><div class="line">也就是所有的请求会把代理使用task的taskIdentifier标记存起来。设置代理的时候加了保护锁，保证可变字典的安全操作。</div><div class="line"></div><div class="line">####6）_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>(void)load {<br>  if (NSClassFromString(@”NSURLSessionTask”)) {</p>
<pre><code>NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];
</code></pre><p>#pragma GCC diagnostic push<br>#pragma GCC diagnostic ignored “-Wnonnull”</p>
<pre><code>NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];
</code></pre><p>#pragma clang diagnostic pop</p>
<pre><code>IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));
Class currentClass = [localDataTask class];

while (class_getInstanceMethod(currentClass, @selector(resume))) {
    Class superClass = [currentClass superclass];
    IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));
    IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));
    if (classResumeIMP != superclassResumeIMP &amp;&amp;
        originalAFResumeIMP != classResumeIMP) {
        [self swizzleResumeAndSuspendMethodForClass:currentClass];
    }
    currentClass = [currentClass superclass];
}

[localDataTask cancel];
[session finishTasksAndInvalidate];
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)swizzleResumeAndSuspendMethodForClass:(Class)theClass {<br>  Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));<br>  Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</p>
<p>  if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) {</p>
<pre><code>af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));
</code></pre><p>  }</p>
<p>  if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) {</p>
<pre><code>af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));
</code></pre><p>  }<br>}</p>
</li>
</ul>
<ul>
<li><p>(NSURLSessionTaskState)state {<br>  NSAssert(NO, @”State method should never be called in the actual dummy class”);<br>  return NSURLSessionTaskStateCanceling;<br>}</p>
</li>
<li><p>(void)af_resume { // 通过Swizzle发通知AFNSURLSessionTaskDidResumeNotification<br>  NSAssert([self respondsToSelector:@selector(state)], @”Does not respond to state”);<br>  NSURLSessionTaskState state = [self state];<br>  [self af_resume];</p>
<p>  if (state != NSURLSessionTaskStateRunning) {</p>
<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)af_suspend {<br>  NSAssert([self respondsToSelector:@selector(state)], @”Does not respond to state”);<br>  NSURLSessionTaskState state = [self state];<br>  [self af_suspend];</p>
<p>  if (state != NSURLSessionTaskStateSuspended) {</p>
<pre><code>[[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里使用runtime技术的swizzle方法对新初始化的一个NSURLSessionDataTask对象进行方法替换。替换resume方法的实现为af_resume，suspend的方法实现为af_suspend。这里面对当前的NSURLSessionTaskState进行操作。</div><div class="line">#2.AFHTTPSessionManager</div><div class="line"></div><div class="line">这部分是继承自AFURLSessionManager，如果是AFURLSessionManager是网络的核心部分，那么这部分就是方便开发者调用的一个实现部分。</div><div class="line">这里面其实封装的比较简单。看一下属性数据：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;</p>
<p>@property (nonatomic, strong) AFHTTPRequestSerializer <afurlrequestserialization> * requestSerializer;</afurlrequestserialization></p>
<p>@property (nonatomic, strong) AFHTTPResponseSerializer <afurlresponseserialization> * responseSerializer;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">里面一个基本的URL，请求序列化，响应序列化。注意这个地方，请求序列化是在AFHTTPSessionManager中做的处理，而responseSerializer是在AFURLSessionManager中做的处理。</div><div class="line"></div><div class="line">初始化方法：</div></pre></td></tr></table></figure></afurlresponseserialization></p>
<ul>
<li>(instancetype)manager;</li>
</ul>
<ul>
<li><p>(instancetype)initWithBaseURL:(nullable NSURL *)url;</p>
</li>
<li><p>(instancetype)initWithBaseURL:(nullable NSURL *)url</p>
<pre><code>sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">           </div><div class="line">这里支持类方法和实例方法。当然了类方法是封装的实例方法。</div><div class="line"></div><div class="line">提供的网络请求方法：</div></pre></td></tr></table></figure>
</li>
<li><p>(nullable NSURLSessionDataTask <em>)GET:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)GET:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
  progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)HEAD:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
   success:(nullable void (^)(NSURLSessionDataTask *task))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)POST:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)POST:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
  progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)POST:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
</code></pre><p>   constructingBodyWithBlock:(nullable void (^)(id <afmultipartformdata> formData))block</afmultipartformdata></p>
<pre><code>success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)POST:(NSString </em>)URLString</p>
<pre><code>               parameters:(nullable id)parameters
constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block
                 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress
                  success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
                  failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)PUT:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)PATCH:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre></li>
<li><p>(nullable NSURLSessionDataTask <em>)DELETE:(NSString </em>)URLString</p>
<pre><code>parameters:(nullable id)parameters
   success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success
   failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">                         </div><div class="line">以上是提供的所有的方法，HTTP协议的基本请求类型GET，POST，PUT，HEAD，DELETE都封装了。</div><div class="line"></div><div class="line">下面我们看一下GET的实现，因为其他的思路都是一样的，出了POST另外增加了一种body类型的封装。</div></pre></td></tr></table></figure>
</li>
<li><p>(NSURLSessionDataTask <em>)GET:(NSString </em>)URLString</p>
<pre><code>parameters:(id)parameters
  progress:(void (^)(NSProgress * _Nonnull))downloadProgress
   success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success
   failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure
</code></pre><p>{</p>
<p>  NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@”GET”</p>
<pre><code>       URLString:URLString
      parameters:parameters
  uploadProgress:nil
downloadProgress:downloadProgress
         success:success
         failure:failure];
</code></pre><p>  [dataTask resume];</p>
<p>  return dataTask;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里我们可以看到调用的是dataTaskWithHTTPMethod: URLString: parameters: uploadProgress: downloadProgress: success: failure:方法。除了POST新增的方法，其他的都是直接调用的这个方法。</div></pre></td></tr></table></figure>
</li>
<li><p>(NSURLSessionDataTask <em>)dataTaskWithHTTPMethod:(NSString </em>)method</p>
<pre><code>       URLString:(NSString *)URLString
      parameters:(id)parameters
  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress
downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress
         success:(void (^)(NSURLSessionDataTask *, id))success
         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure
</code></pre><p>{<br>  NSError <em>serializationError = nil;<br>  NSMutableURLRequest </em>request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];<br>  if (serializationError) {</p>
<pre><code>if (failure) {
</code></pre><p>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wgnu”</p>
<pre><code>dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
    failure(nil, serializationError);
});
</code></pre><p>#pragma clang diagnostic pop</p>
<pre><code>}

return nil;
</code></pre><p>  }</p>
<p>  __block NSURLSessionDataTask *dataTask = nil;<br>  dataTask = [self dataTaskWithRequest:request</p>
<pre><code>                  uploadProgress:uploadProgress
                downloadProgress:downloadProgress
               completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) {
if (error) {
    if (failure) {
        failure(dataTask, error);
    }
} else {
    if (success) {
        success(dataTask, responseObject);
    }
}
</code></pre><p>  }];</p>
<p>  return dataTask;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这个方法就是简单的把请求数据进行了序列化，如果错误的话就直接返回nil，不会发送任何请求。成功的话，进行调用NSURLSessionManager中的方法，最后对返回值进行了简单处理。封装的还算简单，没有太多复杂的逻辑。</div><div class="line"></div><div class="line">最后看一下POST的另一个增加的方法：</div></pre></td></tr></table></figure>
</li>
<li><p>(NSURLSessionDataTask <em>)POST:(NSString </em>)URLString</p>
<pre><code>parameters:(id)parameters
</code></pre><p>   constructingBodyWithBlock:(void (^)(id <afmultipartformdata> formData))block</afmultipartformdata></p>
<pre><code>progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress
 success:(void (^)(NSURLSessionDataTask *task, id responseObject))success
 failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure
</code></pre><p>{<br>  NSError <em>serializationError = nil;<br>  NSMutableURLRequest </em>request = [self.requestSerializer multipartFormRequestWithMethod:@”POST” URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];<br>  if (serializationError) {</p>
<pre><code>if (failure) {
</code></pre><p>#pragma clang diagnostic push<br>#pragma clang diagnostic ignored “-Wgnu”</p>
<pre><code>dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^{
    failure(nil, serializationError);
});
</code></pre><p>#pragma clang diagnostic pop</p>
<pre><code>}

return nil;
</code></pre><p>  }</p>
<p>  <strong>block NSURLSessionDataTask <em>task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse </em> </strong>unused response, id responseObject, NSError *error) {</p>
<pre><code>if (error) {
    if (failure) {
        failure(task, error);
    }
} else {
    if (success) {
        success(task, responseObject);
    }
}
</code></pre><p>  }];</p>
<p>  [task resume];</p>
<p>  return task;<br>}<br>```</p>
</li>
</ul>
<p>封装思路跟上面的基本上是一样的，序列化数据的时候会把body的内容封装在请求body里面：<br> [self.requestsetHTTPBodyStream:self.bodyStream];<br> 相应的这里调用的是NSURLSessionManager中的StreamRequest方法。</p>
<p>不好意思引用了很多的源码，导致文章有点长。<br>最后感谢各位看官，如果你能看到这，非常感谢。如果文中有什么错误，欢迎指正。</p>
<p>更多问题讨论欢迎加QQ群：426825923</p>
<p>转载请注明出处：<a href="http://semyonxu.com" target="_blank" rel="external">http://semyonxu.com</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Semyon Xu" />
          <p class="site-author-name" itemprop="name">Semyon Xu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Semyon Xu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
