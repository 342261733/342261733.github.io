<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Reachability]]></title>
      <url>http://yoursite.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReachability/</url>
      <content type="html"><![CDATA[<p>Reachability这部分主要负责网络的状态网络状态的监听。</p>
<h1 id="首先介绍下使用方法。"><a href="#首先介绍下使用方法。" class="headerlink" title="首先介绍下使用方法。"></a>首先介绍下使用方法。</h1><p>这里介绍三种使用方法：</p>
<h3 id="直接使用单利，调用"><a href="#直接使用单利，调用" class="headerlink" title="直接使用单利，调用"></a>直接使用单利，调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFNetworkReachabilityManager *reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">[reachabilityManager startMonitoring];</div><div class="line">[reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h3 id="使用AFURLSessionManager的属性调用"><a href="#使用AFURLSessionManager的属性调用" class="headerlink" title="使用AFURLSessionManager的属性调用"></a>使用AFURLSessionManager的属性调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;] sessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">  sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">  [sessionManager.reachabilityManager startMonitoring];</div><div class="line">  [sessionManager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">      NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h3 id="使用通知中心的模式，监听"><a href="#使用通知中心的模式，监听" class="headerlink" title="使用通知中心的模式，监听"></a>使用通知中心的模式，监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reachabilityCallBack:) name:AFNetworkingReachabilityDidChangeNotification object:nil];</div><div class="line"></div><div class="line"></div><div class="line">- (void)reachabilityCallBack:(NSNotification *)sender &#123;</div><div class="line">    NSDictionary *userInfo = sender.userInfo;</div><div class="line">    AFNetworkReachabilityStatus netStatus = [userInfo[@&quot;AFNetworkingReachabilityNotificationStatusItem&quot;] integerValue];</div><div class="line">    NSLog(@&quot;netStatus %ld &quot;, netStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法还是比较简单的。</p>
<h1 id="下面分析下源码。"><a href="#下面分析下源码。" class="headerlink" title="下面分析下源码。"></a>下面分析下源码。</h1><h2 id="初始化网络监听"><a href="#初始化网络监听" class="headerlink" title="初始化网络监听"></a>初始化网络监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager;</div><div class="line"></div><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">+ (instancetype)managerForDomain:(NSString *)domain;</div><div class="line"></div><div class="line">+ (instancetype)managerForAddress:(const void *)address;</div><div class="line"></div><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>以上均是初始化方法，我们可以直接用单利模式，比较方便的进行初始化对象，也可以直接用manager，建议还是用单利，因为单利里面也是调用的manager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager &#123;</div><div class="line">    static AFNetworkReachabilityManager *_sharedManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _sharedManager = [self manager];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _sharedManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>manager是直接使用的managerForAdress方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager</div><div class="line">&#123;</div><div class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</div><div class="line">    struct sockaddr_in6 address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin6_len = sizeof(address);</div><div class="line">    address.sin6_family = AF_INET6;</div><div class="line">#else</div><div class="line">    struct sockaddr_in address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin_len = sizeof(address);</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">#endif</div><div class="line">    return [self managerForAddress:&amp;address];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然我们也可以使用初始化domain的方法，然后转换成SCNetworkReachabilityRef对象，进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</div><div class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</div><div class="line"></div><div class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</div><div class="line">    </div><div class="line">    CFRelease(reachability);</div><div class="line"></div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 初始化方法里面只是做了一个retain，和初始化网络状态，目测SCNetworkReachabilityRef是不支持自动内存管理的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _networkReachability = CFRetain(reachability);</div><div class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="开始监听网络状态"><a href="#开始监听网络状态" class="headerlink" title="开始监听网络状态"></a>开始监听网络状态</h2><p>我们之间调用startMonitoring方法，进行开始网络状态的监控：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoring &#123;</div><div class="line">    [self stopMonitoring];</div><div class="line"></div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"></div><div class="line">        strongSelf.networkReachabilityStatus = status;</div><div class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</div><div class="line">            strongSelf.networkReachabilityStatusBlock(status);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</div><div class="line">    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</div><div class="line">    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</div><div class="line">        SCNetworkReachabilityFlags flags;</div><div class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</div><div class="line">            AFPostReachabilityStatusChange(flags, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法比较简单，此处我们可以看到，做了数据保护工作，如果没有初始化会return，首先先stopMonitoring，这样做可以避免生成多个监听网络的对象，导致收到多个成功的回调。<br>然后是一个网络状态捕获到的回调。<br>下面才是使用的SystemConfiguration框架下的SCNetworkReachability的API来做的处理，使用也比较简单，先初始化，然后设置回调block，再对回调的C数据转换成网络状态的枚举类型，最后放到了RunLoop里面，设置到了主RunLoop，并设置model为CommonModes，CommonModes就是普通的和事件处理Mode的集合，不清楚的可以去看RunLoop相关文档。</p>
<h2 id="结束监听网络状态"><a href="#结束监听网络状态" class="headerlink" title="结束监听网络状态"></a>结束监听网络状态</h2><p>结束也比较简单，当然，我们可以自己调用，也可以不调用。因为在类销毁的时候，dealloc中也调用了这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)stopMonitoring &#123;</div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看一下网络状态的枚举，也就是我们可以捕获到的网络状态有哪些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</div><div class="line">    AFNetworkReachabilityStatusUnknown          = -1,</div><div class="line">    AFNetworkReachabilityStatusNotReachable     = 0,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWWAN = 1,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWiFi = 2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>默认是Unknown未知，然后是网络不可达，无线广域网链接，WiFi链接，此处没有区分2G/3G/4G,所以需要使用的小伙伴还得自行处理。</p>
<p>当然AF也为我们提供了获取的属性方法，我们可以直接调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WWAN.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WiFi.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi;</div></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isReachable &#123;</div><div class="line">    return [self isReachableViaWWAN] || [self isReachableViaWiFi];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWWAN &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWiFi &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，我们可以拿到网络是不是可达，当前是不是状态WWAN，WiFi。使用比较方便。</p>
<p>基本就是这些了，如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p><img src="http://chuantu.biz/t5/36/1475134450x3340469572.png" alt=""></p>
<p>转载请注明出处：<a href="http://semyonxu.com" target="_blank" rel="external">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之NSURLSession]]></title>
      <url>http://yoursite.com/2016/09/28/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BNSURLSession/</url>
      <content type="html"><![CDATA[<p>NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。</p>
<p>下面分两个部分来解析：<br> 父类：NSURLSessionManager，<br> 子类：AFHTTPSessionManager</p>
<p>父类NSURLSessionManager对系统的NSURLSession类的网络请求进行了封装，并把NSURLSession里面的delegate返回值通过block返回回去。<br>子类AFHTTPSessionManager继承了所有父类的功能，在这个基础上封装了支持GET，POST，PUT，HEAD，PATCH，DELETE等HTTP请求方式，使用更加方便。当然不用子类，也是可以直接进行网络请求的。</p>
<h1 id="NSURLSessionManager"><a href="#NSURLSessionManager" class="headerlink" title="NSURLSessionManager"></a>NSURLSessionManager</h1><h2 id="先看初始化方法"><a href="#先看初始化方法" class="headerlink" title="先看初始化方法"></a>先看初始化方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">  - (instancetype)init &#123;</div><div class="line">    return [self initWithSessionConfiguration:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!configuration) &#123;</div><div class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    self.sessionConfiguration = configuration;</div><div class="line"></div><div class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">    self.operationQueue.maxConcurrentOperationCount = 1; // 最大并发数量1，不允许并发？当前请求任务只能是一个。</div><div class="line"></div><div class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 代理的设置在这里。我找的好苦啊。。。</div><div class="line"></div><div class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line"></div><div class="line">#if !TARGET_OS_WATCH</div><div class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">#endif</div><div class="line"></div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</div><div class="line"></div><div class="line">    self.lock = [[NSLock alloc] init];</div><div class="line">    self.lock.name = AFURLSessionManagerLockName;</div><div class="line"></div><div class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</div><div class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</div><div class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</div><div class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对各个属性进行了基本的初始化，为session初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSessionsessionWithConfiguration:self.sessionConfigurationdelegate:selfdelegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>我们可以看到是用的系统NSURLSession的初始化方法。</p>
<p>此处会遍历所有task添加delegate方法，猜测是兼容上次为未完成的请求Task，再继续进行处理，具体还得看情况，因为我跟了多次都是没有走这个方法。</p>
<h2 id="网络请求支持的几个方法"><a href="#网络请求支持的几个方法" class="headerlink" title="网络请求支持的几个方法"></a>网络请求支持的几个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///---------------------------</div><div class="line">/// @name Running Upload Tasks</div><div class="line">///---------------------------</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromFile:(NSURL *)fileURL</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromData:(nullable NSData *)bodyData</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</div><div class="line">                                                 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///-----------------------------</div><div class="line">/// @name Running Download Tasks</div><div class="line">///-----------------------------</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                             progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData</div><div class="line">                                                progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                             destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                       completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>这里面封装了系统NSURLSession的dataTask、uploadTask、downloadTask方法。而且另外添加了数据的进度progress。</p>
<p>下面我们来解析一下实现原理：<br>首先看一下dataTask的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request]; // 核心方法，NSURLSessionDataTask的dataTask方法。</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; // 设置代理，所有进度的处理都在代理中。进度的回调。</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，这里使用的是NSURLSessionDataTask的dataTaskWithRequest:方法，这个地方加了数据保护。然后就是为这个dataTask添加代理。所以核心的工作都交个这个代理AFURLSessionManagerTaskDelegate类来处理，那么这个代理的作用就显得尤为重要。</p>
<h2 id="网络请求的代理类AFURLSessionManagerTaskDelegate"><a href="#网络请求的代理类AFURLSessionManagerTaskDelegate" class="headerlink" title="网络请求的代理类AFURLSessionManagerTaskDelegate"></a>网络请求的代理类AFURLSessionManagerTaskDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</div><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div><div class="line">@property (nonatomic, strong) NSMutableData *mutableData;</div><div class="line">@property (nonatomic, strong) NSProgress *uploadProgress;</div><div class="line">@property (nonatomic, strong) NSProgress *downloadProgress;</div><div class="line">@property (nonatomic, copy) NSURL *downloadFileURL;</div><div class="line">@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading; // 下载任务结束回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock; // 上传进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock; // 下载进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler; // 返回成功结果的Block</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里遵循了NSURLSessionDataDelegate,NSURLSessionDataDelegate,NSURLSessionDownloadDelegate,所以是将NSURLSession的基本代理功能封装了一下。然后会对这些代理方法的返回数据进行处理，使用completionHandler Block来进行返回。</p>
<p>首先来看下代理的核心部分，然后再解读progress的封装思路</p>
<h3 id="代理的核心部分"><a href="#代理的核心部分" class="headerlink" title="代理的核心部分"></a>代理的核心部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSURLSessionTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // 单利group对象，why？这样是不是就可以对多个返回结果进行处理，这样的话，就不用顺序等待了，哪个先完成就先返回回去。</div><div class="line">            // 看参数：如果用户传了group对象，那么选择的是用户的，否则直接使用单利的组对象。 队列是默认是主队列，用户填写的就是用户的。</div><div class="line">            if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 成功后数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123; // 下载的情况下，responseObject为下载的本地地址</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // why use gcd group?</div><div class="line">                if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError); // response Header, 返回结果， 解析错误。</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123; // 此处任务完成的通知只是为了UIKit中的一些类别中拿到回调。userInfo字段并没有返回给外部，而是给UIKit用的。当然我们可以用这个通知来获取到。</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDataTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到这里核心的方法只有三个，一个是task完成的回调，一个是接受到数据的回调，最后是下载完成的回调。<br>普通的task请求会先走第二个方法didReceiveData方法，把返回的数据添加到mutableData中。<br>然后再走第一个方法，请求完成的回调。</p>
<h4 id="第一个方法："><a href="#第一个方法：" class="headerlink" title="第一个方法："></a>第一个方法：</h4><p>首先会把返回的数据赋给一个局部变量data，然后将全局的mutableData置空，这样就可以保证下次请求的数据是重新加载。这里区分了下载和普通的数据返回，如果是下载的话，直接下载到指定文件路径中，如果用户指定这个路径的话，userInfo字典里面存的就是下载路径，否则，存的是下载数据。<br>然后就是判断有没有错误，错误的话把错误返回，返回值task.response, responseObject此处是空的，然后就是error。最后在主线程中发送通知，为当前task的userInfo，注意此处的userInfo只是用来做通知信息的。而我们平时用的时候不会用通知来获取请求成功的回调，这个通知是为了AFNetworking中的UIKit封装部分服务的。<br>然后就是成功的回调，异步请求在单利队列中，这里对队列的生成都加了单利的保护。这里通过responseSerializer 对结果数据进行转化成对应的格式（这可以参考Serialization部分，里面讲解如何转化的），如果是下载的话，responseObject直接赋值成downloadFileURL，也就是下载的话，回调中只会有下载的目标地址。然后就是对userInfo的AFNetworkingTaskDidCompleteSerializedResponseKey（序列化响应结果）、AFNetworkingTaskDidCompleteErrorKey（序列化过程中的错误信息）进行赋值，不得不说AFNetworking对各个部分的情况都返回回去了，做的很详细。<br>然后就是调用回调block：completionHandler：<br>返回值task.response也就是完整的返回头信息以及返回的状态码。<br>responseObject是返回的数据或者是下载的目标地址。<br>serializationError注意这个地方的错误是序列化的错误，也就是此处如果对返回数据序列化产生错误，也会照样返回成功回调，只是回调结果会是序列化的错误。<br>最后还是一样的发送通知。</p>
<h4 id="第二个方法："><a href="#第二个方法：" class="headerlink" title="第二个方法："></a>第二个方法：</h4><p>简单的接收到返回数据，简单的把数据进行拼接。</p>
<h4 id="第三个方法："><a href="#第三个方法：" class="headerlink" title="第三个方法："></a>第三个方法：</h4><p>下载的方法，此处如果有downloadTaskDidFinishDownloading的实现，那么进行调用转换目标地址，而目标地址是在下面这个方法的destination Block中进行设置的，这个地方转了一下，也就是倒了两个block让用户来设置这个目标地址。如果可以正常获取这个目标地址的话，把location（也就是本地下载路径，其实就是缓存路径，因为这里下载完成后会删掉）的数据转移到目标路径。响应的会有文件操作的错误信息的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络请求progress的封装思路"><a href="#网络请求progress的封装思路" class="headerlink" title="网络请求progress的封装思路"></a>网络请求progress的封装思路</h3><p>此处使用的技术是KVO，先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    __weak __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</div><div class="line">    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</div><div class="line">    [self.uploadProgress setCancellable:YES];</div><div class="line">    [self.uploadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.uploadProgress setPausable:YES];</div><div class="line">    [self.uploadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line">    if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.uploadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self.downloadProgress setCancellable:YES];</div><div class="line">    [self.downloadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.downloadProgress setPausable:YES];</div><div class="line">    [self.downloadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.downloadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [self.downloadProgress addObserver:self</div><div class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                               options:NSKeyValueObservingOptionNew</div><div class="line">                               context:NULL];</div><div class="line">    [self.uploadProgress addObserver:self</div><div class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                             options:NSKeyValueObservingOptionNew</div><div class="line">                             context:NULL];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)cleanUpProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))];</div><div class="line">    [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">    [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</div><div class="line">            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</div><div class="line">            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</div><div class="line">        if (self.downloadProgressBlock) &#123;</div><div class="line">            self.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</div><div class="line">        if (self.uploadProgressBlock) &#123;</div><div class="line">            self.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化方法中我们可以看到KVO监听的KeyPath是NSURLSessionTask的四个只读属性：countOfBytesReceived, countOfBytesExpectedToReceive, countOfBytesSent, countOfBytesExpectedToSend， 也就是Task的数据统计的一些信息。 downloadProgress和uploadProgress都对fractionCompleted进行监听，也就是进度完成的百分比。<br>这里cleanUp移除所有的KVO，KVO我们平时使用的时候也是需要注意移除的，防止发生原来的还在，又添加监听导致多次监听，那么悲剧了，就是执行监听结果方法的调用越来越多。莫名其妙的bug。<br>最后KVO监听到结果的回调中，对downloadProgress，uploadProgress分别进行completedunitCount完成进度的赋值、totalUnitCount所有进度的复制。如果对象不是task而是NSProgress对象，那么直接把这个object返回回去。</p>
<h2 id="NSURLSession代理方法的转换处理"><a href="#NSURLSession代理方法的转换处理" class="headerlink" title="NSURLSession代理方法的转换处理"></a>NSURLSession代理方法的转换处理</h2><p>首先这里会有很多block的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;</div><div class="line"></div><div class="line">- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">///--------------------------------------</div><div class="line">/// @name Setting Task Delegate Callbacks</div><div class="line">///--------------------------------------</div><div class="line"></div><div class="line">- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;</div><div class="line"></div><div class="line">- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;</div><div class="line"></div><div class="line">- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</div><div class="line"></div><div class="line">- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;</div><div class="line"></div><div class="line">///-------------------------------------------</div><div class="line">/// @name Setting Data Task Delegate Callbacks</div><div class="line">///-------------------------------------------</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;</div><div class="line"></div><div class="line">- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;</div><div class="line"></div><div class="line">- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block;</div><div class="line"></div><div class="line">///-----------------------------------------------</div><div class="line">/// @name Setting Download Task Delegate Callbacks</div><div class="line">///-----------------------------------------------</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable  (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</div></pre></td></tr></table></figure>
<p>也就是支持对所有的NSURLSession代理方法的回调方法直接使用block传给用户使用，这里既支持我们处理原始的回调，AFNetworking在里面继续做响应的处理。</p>
<p>具体方法的处理，由于太多了，我们就分析一下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line"></div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会获取到当前task的delegate对象，然后在代理中对这些数据进行处理。这个方法是在网络完成的时候执行的，所以这里应该将这个task移除掉。数据的处理参见3)里面的AFURLSessionManagerTaskDelegate的方法解析。 最后会执行taskDidComplete的block回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); // block 带入目标地址的url，在外面设置</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>download的完成方法的回调，我们看到跟AFURLSessionManagerTaskDelegate中的方法功能基本是一样的，也就是如果有AFURLSessionManager类中有downloadTaskDidFinishDownloading的block实现的话，就直接在NSURLSessionDownloadDelegate中处理，如果现在还没有实现block，那么就放在delegete里面处理。注意这个地方AFURLSessionManager和NSURLSessionDownloadDelegate都有这个downloadTaskDidFinishDownloading 的block。</p>
<p>就这俩吧，其他的代理方法基本上都是转换成block进行回调，有的复杂一点需要对block的值进行处理一下，然后在回调回去。</p>
<h2 id="关于多任务的处理"><a href="#关于多任务的处理" class="headerlink" title="关于多任务的处理"></a>关于多任务的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = nil;</div><div class="line">    [self.lock lock];</div><div class="line">    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line"></div><div class="line">    return delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask</div><div class="line">                        progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">               completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    uploadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:uploadTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是支持多任务请求的。这里使用字典存的是当前task的代理AFURLSessionManagerTaskDelegate的delegate：<br>@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;<br>也就是所有的请求会把代理使用task的taskIdentifier标记存起来。设置代理的时候加了保护锁，保证可变字典的安全操作。</p>
<h2 id="AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"><a href="#AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state" class="headerlink" title="_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"></a>_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</div><div class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</div><div class="line">#pragma GCC diagnostic push</div><div class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</div><div class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</div><div class="line">        Class currentClass = [localDataTask class];</div><div class="line">        </div><div class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</div><div class="line">            Class superClass = [currentClass superclass];</div><div class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</div><div class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</div><div class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</div><div class="line">                originalAFResumeIMP != classResumeIMP) &#123;</div><div class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</div><div class="line">            &#125;</div><div class="line">            currentClass = [currentClass superclass];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [localDataTask cancel];</div><div class="line">        [session finishTasksAndInvalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</div><div class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</div><div class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionTaskState)state &#123;</div><div class="line">    NSAssert(NO, @&quot;State method should never be called in the actual dummy class&quot;);</div><div class="line">    return NSURLSessionTaskStateCanceling;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_resume &#123; // 通过Swizzle发通知AFNSURLSessionTaskDidResumeNotification</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_resume];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_suspend &#123;</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_suspend];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用runtime技术的swizzle方法对新初始化的一个NSURLSessionDataTask对象进行方法替换。替换resume方法的实现为af_resume，suspend的方法实现为af_suspend。这里面对当前的NSURLSessionTaskState进行操作。</p>
<h1 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h1><p>这部分是继承自AFURLSessionManager，如果是AFURLSessionManager是网络的核心部分，那么这部分就是方便开发者调用的一个实现部分。<br>这里面其实封装的比较简单。看一下属性数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div></pre></td></tr></table></figure>
<p>里面一个基本的URL，请求序列化，响应序列化。注意这个地方，请求序列化是在AFHTTPSessionManager中做的处理，而responseSerializer是在AFURLSessionManager中做的处理。</p>
<p>初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</div><div class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>这里支持类方法和实例方法。当然了类方法是封装的实例方法。</p>
<p>提供的网络请求方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                            parameters:(nullable id)parameters</div><div class="line">                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">     constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">              constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString</div><div class="line">                     parameters:(nullable id)parameters</div><div class="line">                        success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                        failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString</div><div class="line">                      parameters:(nullable id)parameters</div><div class="line">                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div></pre></td></tr></table></figure>
<p>以上是提供的所有的方法，HTTP协议的基本请求类型GET，POST，PUT，HEAD，DELETE都封装了。</p>
<p>下面我们看一下GET的实现，因为其他的思路都是一样的，出了POST另外增加了一种body类型的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(id)parameters</div><div class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</div><div class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</div><div class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                   uploadProgress:nil</div><div class="line">                                                 downloadProgress:downloadProgress</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line"></div><div class="line">    [dataTask resume];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到调用的是dataTaskWithHTTPMethod: URLString: parameters: uploadProgress: downloadProgress: success: failure:方法。除了POST新增的方法，其他的都是直接调用的这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是简单的把请求数据进行了序列化，如果错误的话就直接返回nil，不会发送任何请求。成功的话，进行调用NSURLSessionManager中的方法，最后对返回值进行了简单处理。封装的还算简单，没有太多复杂的逻辑。</p>
<p>最后看一下POST的另一个增加的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(id)parameters</div><div class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</div><div class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</div><div class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(task, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(task, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [task resume];</div><div class="line"></div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装思路跟上面的基本上是一样的，序列化数据的时候会把body的内容封装在请求body里面：<br> [self.requestsetHTTPBodyStream:self.bodyStream];<br> 相应的这里调用的是NSURLSessionManager中的StreamRequest方法。</p>
<p>如果文中有什么错误，欢迎指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p><img src="http://chuantu.biz/t5/36/1475134450x3340469572.png" alt=""></p>
<p>转载请注明出处：<a href="http://semyonxu.com" target="_blank" rel="external">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
  
  
</search>
