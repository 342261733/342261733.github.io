<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[MJRefresh源码解析]]></title>
      <url>http://semyonxu.com/2016/10/09/MJRefresh%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本文主要解析一下MJRefresh这个刷新框架的封装思路以及一些技术在实际中的运用。</p>
<p>当前版本：v3.1.12</p>
<p>github地址：<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">https://github.com/CoderMJLee/MJRefresh</a></p>
<p>首先看下结构图<br><img src="https://camo.githubusercontent.com/4a86d398d981df5dc845042b92c6d785d0d486b4/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67" alt=""></p>
<p>图有点大，大家可以点这里单独看：<a href="https://camo.githubusercontent.com/4a86d398d981df5dc845042b92c6d785d0d486b4/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67" target="_blank" rel="external">结构图</a></p>
<p>接下来我们顺着这个结构来逐步解析封装的思路。</p>
<a id="more"></a>
<h1 id="MJRefreshComponent基类"><a href="#MJRefreshComponent基类" class="headerlink" title="MJRefreshComponent基类"></a>MJRefreshComponent基类</h1><p>基类里面为我们捕获了当前的父view（UITableView、UICollectionVeiw等），然后使用KVO为我们做了一些滑动操作属性的监听，具体的处理需要交给子类去实现。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">    if (self = [super initWithFrame:frame]) &#123;</div><div class="line">        // 准备工作</div><div class="line">        [self prepare];</div><div class="line">        </div><div class="line">        // 默认是普通状态</div><div class="line">        self.state = MJRefreshStateIdle;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepare</div><div class="line">&#123;</div><div class="line">    // 基本属性</div><div class="line">    self.autoresizingMask = UIViewAutoresizingFlexibleWidth;</div><div class="line">    self.backgroundColor = [UIColor clearColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)layoutSubviews</div><div class="line">&#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    </div><div class="line">    [self placeSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubviews&#123;&#125;</div></pre></td></tr></table></figure>
<p>这里设计了两个方法，分别交给子类去使用。</p>
<ul>
<li>一个是preppare方法，触发是通过initWithFrame，这个方法是作用就是初始化一些基本的属性、状态等，倾向于数据方面的初始化。</li>
<li>一个是placeSubviews方法，触发是通过layoutSubviews。关于layoutSubviews的触发条件不清楚的同学可以Google一下。这个方法倾向于处理UI方面。</li>
</ul>
<h2 id="属性方法的转换处理"><a href="#属性方法的转换处理" class="headerlink" title="属性方法的转换处理"></a>属性方法的转换处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</div><div class="line">&#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    </div><div class="line">    // 如果不是UIScrollView，不做任何事情</div><div class="line">    if (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[UIScrollView class]]) return;</div><div class="line">    </div><div class="line">    // 旧的父控件移除监听</div><div class="line">    [self removeObservers];</div><div class="line">    </div><div class="line">    if (newSuperview) &#123; // 新的父控件</div><div class="line">        // 设置宽度</div><div class="line">        self.mj_w = newSuperview.mj_w;</div><div class="line">        // 设置位置</div><div class="line">        self.mj_x = 0;</div><div class="line">        </div><div class="line">        // 记录UIScrollView</div><div class="line">        _scrollView = (UIScrollView *)newSuperview;</div><div class="line">        // 设置永远支持垂直弹簧效果</div><div class="line">        _scrollView.alwaysBounceVertical = YES;</div><div class="line">        // 记录UIScrollView最开始的contentInset</div><div class="line">        _scrollViewOriginalInset = _scrollView.contentInset;</div><div class="line">        </div><div class="line">        // 添加监听</div><div class="line">        [self addObservers];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)drawRect:(CGRect)rect</div><div class="line">&#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    </div><div class="line">    if (self.state == MJRefreshStateWillRefresh) &#123;</div><div class="line">        // 预防view还没显示出来就调用了beginRefreshing</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - KVO监听</div><div class="line">- (void)addObservers</div><div class="line">&#123;</div><div class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</div><div class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil];</div><div class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil];</div><div class="line">    self.pan = self.scrollView.panGestureRecognizer;</div><div class="line">    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeObservers</div><div class="line">&#123;</div><div class="line">    [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentOffset];</div><div class="line">    [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentSize];;</div><div class="line">    [self.pan removeObserver:self forKeyPath:MJRefreshKeyPathPanState];</div><div class="line">    self.pan = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</div><div class="line">&#123;</div><div class="line">    // 遇到这些情况就直接返回</div><div class="line">    if (!self.userInteractionEnabled) return;</div><div class="line">    </div><div class="line">    // 这个就算看不见也需要处理</div><div class="line">    if ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [self scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 看不见</div><div class="line">    if (self.hidden) return;</div><div class="line">    if ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [self scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; else if ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [self scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#123;&#125;</div><div class="line">- (void)scrollViewContentSizeDidChange:(NSDictionary *)change&#123;&#125;</div><div class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change&#123;&#125;</div></pre></td></tr></table></figure>
<p>此处关键的切入点是继承父类的willMoveToSuperview方法，这个方法在刷新控件将要加载到父类的时候调用，这样我们可以获取到父类。然后如果是新的父类的话，首先初始化一些变量属性，然后添加KVO，KVO在这里的作用是监听@”contentOffset”，@”contentSize”以及@”state”属性的变化，来对header，footer做响应状态的处理。</p>
<p>此处为子类抛出了三个响应的方法（scrollViewContentOffsetDidChange…）可以继承下来，实现不同的功能。</p>
<h2 id="刷新状态的处理"><a href="#刷新状态的处理" class="headerlink" title="刷新状态的处理"></a>刷新状态的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#pragma mark 进入刷新状态</div><div class="line">- (void)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        self.alpha = 1.0;</div><div class="line">    &#125;];</div><div class="line">    self.pullingPercent = 1.0;</div><div class="line">    // 只要正在刷新，就完全显示</div><div class="line">    if (self.window) &#123;</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; else &#123;</div><div class="line">        self.state = MJRefreshStateWillRefresh;</div><div class="line">        // 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</div><div class="line">        [self setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 结束刷新状态</div><div class="line">- (void)endRefreshing</div><div class="line">&#123;</div><div class="line">    self.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 是否正在刷新</div><div class="line">- (BOOL)isRefreshing</div><div class="line">&#123;</div><div class="line">    return self.state == MJRefreshStateRefreshing || self.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始结束刷新状态和判断是不是正在刷新状态，其中除了动画外，self.state是个很重要的属性，几乎所有的状态变化都是state的set方法里面实现，下面我们会在子类中解读。</p>
<h2 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)executeRefreshingCallback</div><div class="line">&#123;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        if (self.refreshingBlock) &#123;</div><div class="line">            self.refreshingBlock();</div><div class="line">        &#125;</div><div class="line">        if ([self.refreshingTarget respondsToSelector:self.refreshingAction]) &#123;</div><div class="line">            MJRefreshMsgSend(MJRefreshMsgTarget(self.refreshingTarget), self.refreshingAction, self);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于回调方法，这里支持block和target:selecteor:两种。此处target方式的调用是用的封装的runtime宏，我们知道方法的调用实际上就是转换成objc_msgSend方法。</p>
<p>这种封装对于我们也是有借鉴意义的，如果写公共的框架，我们也是应该支持多种类型的回调的。最好再加一个delegate的方法。</p>
<h1 id="Header控件"><a href="#Header控件" class="headerlink" title="Header控件"></a>Header控件</h1><p>下面一步一步解析继承的子类的功能以及职责。</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p>继承自MJRefreshComponent基础父类。</p>
<p>本类的主要职责：<br>实现基本的页面刷新逻辑，负责解析出各个状态，然后对每个状态进行处理。（简单点说就是只是逻辑的实现，简单下拉，然后scrollView头部留出一点空，等待刷新完成，完成后空白消失）。</p>
<p>这里对contentoffset的状态的变化进行监听，并对结果处理成四种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MJRefreshStateIdle = 1, /** 普通闲置状态 */MJRefreshStatePulling, /** 松开就可以进行刷新的状态 */MJRefreshStateRefreshing, /** 正在刷新中的状态 */MJRefreshStateWillRefresh, /** 即将刷新的状态 */</div><div class="line">mj</div></pre></td></tr></table></figure>
<h3 id="先解读一下初始化方法"><a href="#先解读一下初始化方法" class="headerlink" title="先解读一下初始化方法:"></a>先解读一下初始化方法:</h3><pre><code>
+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock {
    MJRefreshHeader *cmp = [[self alloc] init];
    cmp.refreshingBlock = refreshingBlock;
    return cmp;
}

- (void)prepare {
    [super prepare];
    self.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;
    self.mj_h = MJRefreshHeaderHeight;
}

- (void)placeSubViews {
    [super placeSubViews];

    // 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)
    self.mj_y =  - self.mj_h - self.ignoredScrollViewContentInsetTop;
}


<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里封装了一个类方法，方便用户调用，并获取刷新的回调。然后prepare就是跟之前说的一样，设置一下初始化值数据。而placeSubViews这里更新一下UI。</div><div class="line"></div><div class="line">### 通过contentofffset转换刷新的状态</div></pre></td></tr></table></figure>

- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change
{
    [super scrollViewContentOffsetDidChange:change];

    // 在刷新的refreshing状态
    if (self.state == MJRefreshStateRefreshing) {
        if (self.window == nil) return;

        // sectionheader停留解决
        CGFloat insetT = - self.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top;
        insetT = insetT &gt; self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT;
        self.scrollView.mj_insetT = insetT;

        self.insetTDelta = _scrollViewOriginalInset.top - insetT;
        return;
    }

    // 跳转到下一个控制器时，contentInset可能会变
     _scrollViewOriginalInset = self.scrollView.contentInset;

    // 当前的contentOffset
    CGFloat offsetY = self.scrollView.mj_offsetY;
    // 头部控件刚好出现的offsetY
    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;

    // 如果是向上滚动到看不见头部控件，直接返回
    // &gt;= -&gt; &gt;
    if (offsetY &gt; happenOffsetY) return;

    // 普通 和 即将刷新 的临界点
    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;
    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;

    if (self.scrollView.isDragging) { // 如果正在拖拽
        self.pullingPercent = pullingPercent;
        if (self.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) {
            // 转为即将刷新状态
            self.state = MJRefreshStatePulling;
        } else if (self.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) {
            // 转为普通状态
            self.state = MJRefreshStateIdle;
        }
    } else if (self.state == MJRefreshStatePulling) {// 即将刷新 &amp;&amp; 手松开
        // 开始刷新
        [self beginRefreshing];
    } else if (pullingPercent &lt; 1) {
        self.pullingPercent = pullingPercent;
    }
}
- (void)setState:(MJRefreshState)state
{
    MJRefreshCheckState

    // 根据状态做事情
    if (state == MJRefreshStateIdle) {
        if (oldState != MJRefreshStateRefreshing) return;

        // 保存刷新时间
        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];
        [[NSUserDefaults standardUserDefaults] synchronize];

        // 恢复inset和offset
        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{
            self.scrollView.mj_insetT += self.insetTDelta;

            // 自动调整透明度
            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;
        } completion:^(BOOL finished) {
            self.pullingPercent = 0.0;

            if (self.endRefreshingCompletionBlock) {
                self.endRefreshingCompletionBlock();
            }
        }];
    } else if (state == MJRefreshStateRefreshing) {
         dispatch_async(dispatch_get_main_queue(), ^{
            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{
                CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;
                // 增加滚动区域top
                self.scrollView.mj_insetT = top;
                // 设置滚动位置
                [self.scrollView setContentOffset:CGPointMake(0, -top) animated:NO];
            } completion:^(BOOL finished) {
                [self executeRefreshingCallback];
            }];
         });
    }
}

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面我们一起解读一下这个刷新的过程。</div><div class="line"></div><div class="line">首先，我们下拉刷新的时候，当前状态肯定是MJRefreshStateIdle（啰嗦一下：这个在MJRefreshComponent中initwithframe中有设置：self.state = MJRefreshStateIdle）。那么直接走下面的if判断，满足第一个if，当前操作是isDragging。这里计算出了拖拽所占的比例，也就下拉的百分比。</div><div class="line"></div><div class="line">如果是MJRefreshStateIdle普通状态并超出下拉超出header的高度，那么状态立刻转换为MJRefreshStatePulling拖动中。</div><div class="line"></div><div class="line">此时如果没有继续下拉，而是松手，那么就会走else if，立刻把状态转换回MJRefreshStateIdle。</div><div class="line"></div><div class="line">此时如果继续下拉，那么走下面这个else if (self.state == MJRefreshStatePulling)，立刻调用beginRefreshing开始刷新。其实也就是把状态转换为MJRefreshStateRefreshing.看一下父类中的实现：</div></pre></td></tr></table></figure>

- (void)beginRefreshing {
    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{
        self.alpha = 1.0;
    }];
    self.pullingPercent = 1.0;
    if (self.window) {
        self.state = MJRefreshStateRefreshing;
    }
    else {
        if (self.state != MJRefreshStateRefreshing) {
            self.state = MJRefreshStateWillRefresh;
            [self setNeedsDisplay]; // 继续调用drawrect，这样延时，加了个willrefresh的state 意欲：预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下
        }
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里做了一个有时间长度的动画，多加了一个willRefresh的状态，我的理解是为了防止从另一个页面返回的时候self.window为空的时候，突然刷新会崩溃，需要一个状态来过渡。当然了当前的下拉比例是百分百了。</div><div class="line"></div><div class="line">设置state = MJRefreshStateRefreshing，会调用state的setStaus方法，我们看到，这里直接对页面进行了header高度的偏移，使得整个header显示出来，然后在完成动画的时候回调回去，我们可以进行一些网络请求。</div><div class="line"></div><div class="line">此时状态是MJRefreshStateRefreshing，继续监听会接着走第一个if：if (self.state == MJRefreshStateRefreshing)，这里重新设置了insetTop，也就是页面偏移到整个header的高度，好像跟setState有点重复。记录了一下insetTDelta值：：初始的top - insetTop, 这个值是刷新完恢复header位置用的。当然了，这里也是为了兼容，我们使用MJ之前设置过了insetTop，这里是在之前设置过的insetTop基础上再偏移的。然后就是return，下面的代码不会再执行。</div><div class="line"></div><div class="line">直到我们的网络请求完成，触发endRefreshing方法，那么此时的状态会改变回去MJRefreshStateIdle。然后处理就是保存一下刷新的时间，通过这个insetTDelta恢复insetTop为原始值，完成后执行endRefreshingCompletionBlock回调。</div><div class="line"></div><div class="line">## MJRefreshStateHeader</div><div class="line"></div><div class="line">此部分继承自MJRefreshHeader，主要就是处理状态文字，不同状态下的提示文字是不同的。系统给我们提供了多语言版本的默认提示语，当然我们也可以自己设置我们的个性提示语：</div></pre></td></tr></table></figure>

- (void)setTitle:(NSString *)title forState:(MJRefreshState)state {
    if (title == nil) {
        return;
    }
    self.stateTitles[@(state)] = title;
    self.stateLabel.text = self.stateTitles[@(self.state)];
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">（不得不吐槽一下小码哥的代码格式，有的花括号跟方法一行，有的另起一行。对于有些洁癖的看官只好忍一下了。）</div><div class="line">这里是用的state枚举值当做key来存的stateTitle值，使用的是字典。</div><div class="line"></div><div class="line"></div><div class="line">还是使用这两个初始化方法：</div></pre></td></tr></table></figure>

- (void)prepare
{
    [super prepare];

    // 初始化间距
    self.labelLeftInset = MJRefreshLabelLeftInset;

    // 初始化文字
    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];
    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];
    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];
}

- (void)placeSubviews
{
    [super placeSubviews];

    if (self.stateLabel.hidden) return;

    BOOL noConstrainsOnStatusLabel = self.stateLabel.constraints.count == 0;

    if (self.lastUpdatedTimeLabel.hidden) {
        // 状态
        if (noConstrainsOnStatusLabel) self.stateLabel.frame = self.bounds;
    } else {
        CGFloat stateLabelH = self.mj_h * 0.5;
        // 状态
        if (noConstrainsOnStatusLabel) {
            self.stateLabel.mj_x = 0;
            self.stateLabel.mj_y = 0;
            self.stateLabel.mj_w = self.mj_w;
            self.stateLabel.mj_h = stateLabelH;
        }

        // 更新时间
        if (self.lastUpdatedTimeLabel.constraints.count == 0) {
            self.lastUpdatedTimeLabel.mj_x = 0;
            self.lastUpdatedTimeLabel.mj_y = stateLabelH;
            self.lastUpdatedTimeLabel.mj_w = self.mj_w;
            self.lastUpdatedTimeLabel.mj_h = self.mj_h - self.lastUpdatedTimeLabel.mj_y;
        }
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">prepare方法默认设置了状态文字，placeSubviews方法对文字Label进行处理。这里一共两个label，一个状态文字label，一个上次刷新时间label。并对隐藏一个或者全部做了页面布局的处理。</div><div class="line"></div><div class="line">最后还是通过state的set方法来更新状态：</div></pre></td></tr></table></figure>

- (void)setState:(MJRefreshState)state
{
    MJRefreshCheckState

    // 设置状态文字
    self.stateLabel.text = self.stateTitles[@(state)];

    // 重新设置key（重新显示时间）
    self.lastUpdatedTimeKey = self.lastUpdatedTimeKey;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">不得不说setState方法是核心处理方法，很重要。</div><div class="line"></div><div class="line"></div><div class="line">## MJRefreshNormalHeader</div><div class="line"></div><div class="line">此部分继承自MJRefreshStateHeader，作用就是在添加了文字基础上，添加了动画部分，包括刷新的菊花和箭头。</div><div class="line"></div><div class="line">箭头的添加方式跟文本添加是一样的，添加在了文本的左边，如果文本隐藏的话，箭头就居中了。</div></pre></td></tr></table></figure>

- (void)setState:(MJRefreshState)state
{
    MJRefreshCheckState

    // 根据状态做事情
    if (state == MJRefreshStateIdle) {
        if (oldState == MJRefreshStateRefreshing) {
            self.arrowView.transform = CGAffineTransformIdentity;

            [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^{
                self.loadingView.alpha = 0.0;
            } completion:^(BOOL finished) {
                // 如果执行完动画发现不是idle状态，就直接返回，进入其他状态
                if (self.state != MJRefreshStateIdle) return;

                self.loadingView.alpha = 1.0;
                [self.loadingView stopAnimating];
                self.arrowView.hidden = NO;
            }];
        } else {
            [self.loadingView stopAnimating];
            self.arrowView.hidden = NO;
            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{
                self.arrowView.transform = CGAffineTransformIdentity;
            }];
        }
    } else if (state == MJRefreshStatePulling) {
        [self.loadingView stopAnimating];
        self.arrowView.hidden = NO;
        [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^{
            self.arrowView.transform = CGAffineTransformMakeRotation(0.000001 - M_PI);
        }];
    } else if (state == MJRefreshStateRefreshing) {
        self.loadingView.alpha = 1.0; // 防止refreshing -&gt; idle的动画完毕动作没有被执行
        [self.loadingView startAnimating];
        self.arrowView.hidden = YES;
    }
}

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在state的set方法中，添加了一个箭头的旋转动画。</div><div class="line"></div><div class="line"></div><div class="line">## MJRefreshGifHeader</div><div class="line"></div><div class="line">与MJRefreshNormalHeader类似，继承自MJRefreshStateHeader。是在文本类的基础上添加的带有普通动画的子类。</div><div class="line"></div><div class="line">只不过这里加了拖动和刷新中的动画。</div></pre></td></tr></table></figure>

- (void)setState:(MJRefreshState)state
{
    MJRefreshCheckState

    // 根据状态做事情
    if (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) {
        NSArray *images = self.stateImages[@(state)];
        if (images.count == 0) return;

        [self.gifView stopAnimating];
        if (images.count == 1) { // 单张图片
            self.gifView.image = [images lastObject];
        } else { // 多张图片
            self.gifView.animationImages = images;
            self.gifView.animationDuration = [self.stateDurations[@(state)] doubleValue];
            [self.gifView startAnimating];
        }
    } else if (state == MJRefreshStateIdle) {
        [self.gifView stopAnimating];
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里使用的是UIImageView的自带图片动画功能。我们可以直接传入图片数组来实现动画。当然如果不能满足我们的需求，我们是可以自己封装这一层，替换为自己的动画。</div><div class="line"></div><div class="line"></div><div class="line"># Footer控件</div><div class="line"></div><div class="line">Footer封装了两个分支子类：</div><div class="line"></div><div class="line">- BackFooter(会回弹到底部的上拉刷新控件)</div><div class="line">- AutoFooter(会自动刷新的上拉刷新控件)</div><div class="line"></div><div class="line"></div><div class="line">## MJRefreshFooter </div><div class="line"></div><div class="line">基础父类，是两种footer的共同父类。此处比Header的父类要简单一些，因为下面两个分支的逻辑处理还是不一样的，所以这里就简单的做了一些初始化工作。</div></pre></td></tr></table></figure>

- (void)willMoveToSuperview:(UIView *)newSuperview
{
    [super willMoveToSuperview:newSuperview];

    if (newSuperview) {
        // 监听scrollView数据的变化
        if ([self.scrollView isKindOfClass:[UITableView class]] || [self.scrollView isKindOfClass:[UICollectionView class]]) {
            [self.scrollView setMj_reloadDataBlock:^(NSInteger totalDataCount) {
                if (self.isAutomaticallyHidden) {
                    self.hidden = (totalDataCount == 0);
                }
            }];
        }
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里可以设置自动隐藏Footer。前提是tableview或collectionview的数据源为空。</div><div class="line"></div><div class="line">## AutoFooter</div><div class="line"></div><div class="line">自动上拉加载类。滑动到底部触发刷新动作，无需上拉操作。</div><div class="line"></div><div class="line">### MJRefreshAutoFooter</div><div class="line"></div><div class="line">类似于MJRefreshHeader类的功能，将UI效果逻辑处理出来。</div></pre></td></tr></table></figure>

- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change
{
    [super scrollViewContentOffsetDidChange:change];

    if (self.state != MJRefreshStateIdle || !self.automaticallyRefresh || self.mj_y == 0) return;

    if (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) { // 内容超过一个屏幕
        // 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理
        if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH - _scrollView.mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - self.mj_h) { 
                /*
            // contentsize Height + bottom = scrollview content 全部展示高度。    注意此处的self.hegiht 包含在bottom里面
            // _scrollView.mj_contentH +  _scrollView.mj_insetB - _scrollView.mj_h - self.mj_h * (1 - self.triggerAutomaticallyRefreshPercent)  
             // if  self.triggerAutomaticallyRefreshPercent = 1, 跟下面的 第二中情况是一样的。 只是兼容了一下 可以显示self的多少比例，就刷新而已。 其实此处默认也是1.  但是这个方法比下面的方法，提前回调。呵呵。
            // 这个方法跟下面的方法区别在于，下面的方法需要是手松开的情况下，达到临界值，而这个方法是不需要的，也就是条件更宽松。其实，如果手势滑动到底部情况下，这个方法，和下面的方法的处理是一样的。效果也是一样的。
            */
            // 防止手松开时连续调用
            CGPoint old = [change[@&quot;old&quot;] CGPointValue];
            CGPoint new = [change[@&quot;new&quot;] CGPointValue];
            if (new.y &lt;= old.y) return;

            // 当底部刷新控件完全出现时，才刷新
            [self beginRefreshing];
        }
    }
}

- (void)scrollViewPanStateDidChange:(NSDictionary *)change
{
    [super scrollViewPanStateDidChange:change];

    if (self.state != MJRefreshStateIdle) return;

    if (_scrollView.panGestureRecognizer.state == UIGestureRecognizerStateEnded) {// 手松开
        if (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;= _scrollView.mj_h) {  // 不够一个屏幕
            if (_scrollView.mj_offsetY &gt;= - _scrollView.mj_insetT) { // 向上拽, 拽的浮度需要大于top的值 没有设置的话此处是mj_insetT = 0,注意此处的mj_offsetY已经默认是加了初始top的offset。 比如设置top 100 ，此处offset = -100 ，只要向上滑动一点，就可以执行下面的刷新。
                [self beginRefreshing];
            }
        } else { // 超出一个屏幕, // 这个是需要拖一下。再加载， 正常情况下，下面这个开始加载是不会走的，只有设置automaticallyRefresh = NO 才会走这个。
            if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) { // 也就是比偏移量比contentH + Bottom 整个scrollview的显示内容 - scrollview的height还有大。 相等是到底部，大于就是有个拖动手势。
                [self beginRefreshing];
            }
        }
    }
}

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里处理了contentOffset的变化以及Pan手势的改变状态回调。</div><div class="line"></div><div class="line">### MJRefreshAutoStateFooter</div><div class="line"></div><div class="line">封装思路类似于MJRefreshStateHeader，不再赘述。</div><div class="line"></div><div class="line">### MJRefreshAutoNormalFooter</div><div class="line"></div><div class="line">封装思路类似于MJRefreshNormalHeader，不再赘述。</div><div class="line"></div><div class="line">### MJRefreshAutoGifFooter</div><div class="line"></div><div class="line">封装思路类似于MJRefreshGifHeader，不再赘述。</div><div class="line"></div><div class="line"></div><div class="line">## BackFooter</div><div class="line"></div><div class="line">跟Header的封装思路是一样的，需要上拉才会触发刷新动作。</div><div class="line"></div><div class="line">### MJRefreshBackFooter</div></pre></td></tr></table></figure>

- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change
{
    [super scrollViewContentOffsetDidChange:change];

    // 如果正在刷新，直接返回
    if (self.state == MJRefreshStateRefreshing) return;

    _scrollViewOriginalInset = self.scrollView.contentInset;

    // 当前的contentOffset
    CGFloat currentOffsetY = self.scrollView.mj_offsetY;
    // 尾部控件刚好出现的offsetY
    CGFloat happenOffsetY = [self happenOffsetY];
    // 如果是向下滚动到看不见尾部控件，直接返回
    if (currentOffsetY &lt;= happenOffsetY) return;

    CGFloat pullingPercent = (currentOffsetY - happenOffsetY) / self.mj_h;

    // 如果已全部加载，仅设置pullingPercent，然后返回
    if (self.state == MJRefreshStateNoMoreData) {
        self.pullingPercent = pullingPercent;
        return;
    }

    if (self.scrollView.isDragging) {
        self.pullingPercent = pullingPercent;
        // 普通 和 即将刷新 的临界点
        CGFloat normal2pullingOffsetY = happenOffsetY + self.mj_h;

        if (self.state == MJRefreshStateIdle &amp;&amp; currentOffsetY &gt; normal2pullingOffsetY) {
            // 转为即将刷新状态
            self.state = MJRefreshStatePulling;
        } else if (self.state == MJRefreshStatePulling &amp;&amp; currentOffsetY &lt;= normal2pullingOffsetY) {
            // 转为普通状态
            self.state = MJRefreshStateIdle;
        }
    } else if (self.state == MJRefreshStatePulling) {// 即将刷新 &amp;&amp; 手松开
        // 开始刷新
        [self beginRefreshing];
    } else if (pullingPercent &lt; 1) {
        self.pullingPercent = pullingPercent;
    }
}

- (void)scrollViewContentSizeDidChange:(NSDictionary *)change
{
    [super scrollViewContentSizeDidChange:change];

    // 内容的高度
    CGFloat contentHeight = self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;
    // 表格的高度
    CGFloat scrollHeight = self.scrollView.mj_h - self.scrollViewOriginalInset.top - self.scrollViewOriginalInset.bottom + self.ignoredScrollViewContentInsetBottom;
    // 设置位置和尺寸
    self.mj_y = MAX(contentHeight, scrollHeight);
}
</code></pre><p>对比之后，我们发现跟Header的思路基本一致。</p>
<h3 id="MJRefreshBackStateFooter"><a href="#MJRefreshBackStateFooter" class="headerlink" title="MJRefreshBackStateFooter"></a>MJRefreshBackStateFooter</h3><p>封装思路类似于MJRefreshStateHeader，不再赘述。</p>
<h3 id="MJRefreshBackNormalFooter"><a href="#MJRefreshBackNormalFooter" class="headerlink" title="MJRefreshBackNormalFooter"></a>MJRefreshBackNormalFooter</h3><p>封装思路类似于MJRefreshNormalHeader，不再赘述。</p>
<h3 id="MJRefreshBackGifFooter"><a href="#MJRefreshBackGifFooter" class="headerlink" title="MJRefreshBackGifFooter"></a>MJRefreshBackGifFooter</h3><p>封装思路类似于MJRefreshGifHeader，不再赘述。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Serialization]]></title>
      <url>http://semyonxu.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSerialization/</url>
      <content type="html"><![CDATA[<p>本部分主要的作用：网络通信信息序列化/反序列化</p>
<h1 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h1><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><p>负责参数转换成NSMutableURLRequest类型，进行网络请求。</p>
<ol>
<li>构建普通请求：格式化请求参数，生成HTTP Header</li>
<li>构建multipart请求</li>
</ol>
<h2 id="类关系："><a href="#类关系：" class="headerlink" title="类关系："></a>类关系：</h2><p>父类：</p>
<ul>
<li>AFHTTPRequestSerializer,二进制格式（query字符串转换成二进制）</li>
</ul>
<p>子类：</p>
<ul>
<li>AFJSONRequestSerializer,Json格式（Json序列化成NSData类型）</li>
<li>AFPropertyListRequestSerializer，Plist（一种特殊的XML，解析起来相对容易）<a id="more"></a>
</li>
</ul>
<h2 id="封装思路："><a href="#封装思路：" class="headerlink" title="封装思路："></a>封装思路：</h2><p>所有类遵循一个协议AFURLRequestSerialization，协议中一个非必须实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullableNSURLRequest*)requestBySerializingRequest:(NSURLRequest*)request</div><div class="line">                                withParameters:(nullableid)parameters</div><div class="line">                                   error:(NSError* _Nullable__autoreleasing *)error NS_SWIFT_NOTHROW;</div></pre></td></tr></table></figure>
<p>父类AFHTTPRequestSerializer中提供外部调用接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest*)requestWithMethod:(NSString*)method</div><div class="line">                                 URLString:(NSString*)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError*__autoreleasing*)error</div></pre></td></tr></table></figure>
<p>在这个方法中调用协议方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutableRequest = [[selfrequestBySerializingRequest:mutableRequestwithParameters:parameterserror:error]mutableCopy];</div></pre></td></tr></table></figure>
<p>而这个方法的实现是父类以及各个子类分别实现。所以，此处self如果是AFHTTPRequestSerializer那么走AFHTTPRequestSerializer类下的实现，如果是<br>AFJSONRequestSerializer，那么走AFJSONRequestSerializer类下的实现。然后再分别实现这个方法不同功能的实现。</p>
<p>下面看一下各个类不同职能分别的实现：</p>
<p>AFURLRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [requestmutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeadersenumerateKeysAndObjectsUsingBlock:^(id field,id value, BOOL *__unused stop) &#123;</div><div class="line">        if (![requestvalueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:valueforHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSString *query =nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                returnnil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                caseAFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURIcontainsObject:[[request HTTPMethod]uppercaseString]]) &#123; //普通GET，HEAD等，参数直接拼接在url后面用&amp;分开</div><div class="line">        if (query &amp;&amp; query.length &gt;0) &#123;</div><div class="line">            mutableRequest.URL = [NSURLURLWithString:[[mutableRequest.URLabsoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequestvalueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot;forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[querydataUsingEncoding:self.stringEncoding]];// 普通的POST请求参数，直接转换成NSData设置到HTTP的body中。</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到AFNetworking对于GET，POST请求参数的处理，一个是直接拼接在URL上面，一个是设置在HTTPBody里面。</p>
<p>其中，HTTPMethodsEncodingParametersInURI的初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil]; // 支持GET，HEAD，DELETE</div></pre></td></tr></table></figure>
<p>也就是GET,HEAD,DELETE支持的是参数直接拼接URL的方式。</p>
<p>AFJSONRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;]; // 设置公共的请求头</div><div class="line"></div><div class="line">    if (parameters) &#123;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟AFURLRequestSerialization中的实现差不多，如果是HTTPMethodsEncodingParametersInURI请求方式是GET，HEAD，DELETE，则直接调用父类的解析方法。如果是POST等其他的，那么做了一下设置请求头Content-Type = “application/json”,并且将paramters参数Json序列化成NSData,设置到HTTPBody里面。</p>
<p>AFPropertyListRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if (parameters) &#123;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-plist&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [mutableRequest setHTTPBody:[NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好吧，封装思路跟AFJSONRequestSerialization一样，区别在于json序列化变成Plist的转换。</p>
<h1 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h1><h2 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h2><p>负责对网络请求返回的数据进行解析。</p>
<h2 id="类关系：-1"><a href="#类关系：-1" class="headerlink" title="类关系："></a>类关系：</h2><p>父类：</p>
<ul>
<li>AFHTTPResponseSerializer，二进制格式</li>
</ul>
<p>子类： </p>
<ul>
<li>AFJSONResponseSerializer, JSON格式</li>
<li>AFXMLParseResponseSerializer, XML（只能返回XMLParser，还需要自己通过代理解析）</li>
<li>AFXMLDocumentResponseSerializer, （Mac OS X）</li>
<li>AFPropertyListResponseSerializer,  Plist</li>
<li>AFImageResponseSerializer,  Image</li>
<li>AFCompoundResponseSerializer, 组合</li>
</ul>
<h2 id="封装思路：-1"><a href="#封装思路：-1" class="headerlink" title="封装思路："></a>封装思路：</h2><p>跟Request的封装思路基本相同。只不过这个是在数据请求到之后进行的处理。遵循的是AFURLResponseSerialization协议。实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div></pre></td></tr></table></figure>
<p>此处的返回值是id类型的，也就是数据解析完之后的数据。</p>
<p>顺便提一下返回值解析的调用函数是在AFURLSessionManager中的网络请求成功的回调中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 此处进行数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看一下各个类不同职能分别的实现：<br>父类AFHTTPResponseSerializer 中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</div><div class="line"></div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处就一个方法，就是做了一个返回的数据是否有效。但是数据是否有错，都会返回原始数据，没有做任何的修改。<br>看一下返回数据有效性的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</div><div class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</div><div class="line"></div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要做了判断是不是支持的返回content-type类型，再就是状态码是不是200+，如果不满足就不是有效的返回数据。<br>看下初始化值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</div><div class="line">self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];</div></pre></td></tr></table></figure>
<p>子类AFJSONResponseSerializer中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id responseObject = nil;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</div><div class="line">    // See https://github.com/rails/rails/issues/1742</div><div class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</div><div class="line">    if (data.length &gt; 0 &amp;&amp; !isSpace) &#123;</div><div class="line">        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</div><div class="line">    &#125; else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</div><div class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处看到在父类中对有效性的判断结果并没有做处理，而在Json转换类中，如果返回数据是无效的，直接就返回nil。然后就是对返回数据进行了Json转换。并对结果进行了空值进行了排空。</p>
<p>其他的子类的封装思路也都相似，不再一一赘述。注意的是不同的功能的子类对返回值的类型支持是不同的。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p><img src="http://chuantu.biz/t5/36/1475134450x3340469572.png" alt=""></p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Reachability]]></title>
      <url>http://semyonxu.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReachability/</url>
      <content type="html"><![CDATA[<p>Reachability这部分主要负责网络的状态网络状态的监听。</p>
<h1 id="首先介绍下使用方法。"><a href="#首先介绍下使用方法。" class="headerlink" title="首先介绍下使用方法。"></a>首先介绍下使用方法。</h1><p>这里介绍三种使用方法：</p>
<h2 id="直接使用单利，调用"><a href="#直接使用单利，调用" class="headerlink" title="直接使用单利，调用"></a>直接使用单利，调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFNetworkReachabilityManager *reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">[reachabilityManager startMonitoring];</div><div class="line">[reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="使用AFURLSessionManager的属性调用"><a href="#使用AFURLSessionManager的属性调用" class="headerlink" title="使用AFURLSessionManager的属性调用"></a>使用AFURLSessionManager的属性调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;] sessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">  sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">  [sessionManager.reachabilityManager startMonitoring];</div><div class="line">  [sessionManager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">      NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h2 id="使用通知中心的模式，监听"><a href="#使用通知中心的模式，监听" class="headerlink" title="使用通知中心的模式，监听"></a>使用通知中心的模式，监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reachabilityCallBack:) name:AFNetworkingReachabilityDidChangeNotification object:nil];</div><div class="line"></div><div class="line"></div><div class="line">- (void)reachabilityCallBack:(NSNotification *)sender &#123;</div><div class="line">    NSDictionary *userInfo = sender.userInfo;</div><div class="line">    AFNetworkReachabilityStatus netStatus = [userInfo[@&quot;AFNetworkingReachabilityNotificationStatusItem&quot;] integerValue];</div><div class="line">    NSLog(@&quot;netStatus %ld &quot;, netStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法还是比较简单的。</p>
<h1 id="下面分析下源码"><a href="#下面分析下源码" class="headerlink" title="下面分析下源码"></a>下面分析下源码</h1><h2 id="初始化网络监听"><a href="#初始化网络监听" class="headerlink" title="初始化网络监听"></a>初始化网络监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager;</div><div class="line"></div><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">+ (instancetype)managerForDomain:(NSString *)domain;</div><div class="line"></div><div class="line">+ (instancetype)managerForAddress:(const void *)address;</div><div class="line"></div><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>以上均是初始化方法，我们可以直接用单利模式，比较方便的进行初始化对象，也可以直接用manager，建议还是用单利，因为单利里面也是调用的manager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager &#123;</div><div class="line">    static AFNetworkReachabilityManager *_sharedManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _sharedManager = [self manager];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _sharedManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>manager是直接使用的managerForAdress方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager</div><div class="line">&#123;</div><div class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</div><div class="line">    struct sockaddr_in6 address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin6_len = sizeof(address);</div><div class="line">    address.sin6_family = AF_INET6;</div><div class="line">#else</div><div class="line">    struct sockaddr_in address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin_len = sizeof(address);</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">#endif</div><div class="line">    return [self managerForAddress:&amp;address];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然我们也可以使用初始化domain的方法，然后转换成SCNetworkReachabilityRef对象，进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</div><div class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</div><div class="line"></div><div class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</div><div class="line">    </div><div class="line">    CFRelease(reachability);</div><div class="line"></div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 初始化方法里面只是做了一个retain，和初始化网络状态，目测SCNetworkReachabilityRef是不支持自动内存管理的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _networkReachability = CFRetain(reachability);</div><div class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="开始监听网络状态"><a href="#开始监听网络状态" class="headerlink" title="开始监听网络状态"></a>开始监听网络状态</h2><p>我们之间调用startMonitoring方法，进行开始网络状态的监控：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoring &#123;</div><div class="line">    [self stopMonitoring];</div><div class="line"></div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"></div><div class="line">        strongSelf.networkReachabilityStatus = status;</div><div class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</div><div class="line">            strongSelf.networkReachabilityStatusBlock(status);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</div><div class="line">    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</div><div class="line">    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</div><div class="line">        SCNetworkReachabilityFlags flags;</div><div class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</div><div class="line">            AFPostReachabilityStatusChange(flags, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法比较简单，此处我们可以看到，做了数据保护工作，如果没有初始化会return，首先先stopMonitoring，这样做可以避免生成多个监听网络的对象，导致收到多个成功的回调。<br>然后是一个网络状态捕获到的回调。<br>下面才是使用的SystemConfiguration框架下的SCNetworkReachability的API来做的处理，使用也比较简单，先初始化，然后设置回调block，再对回调的C数据转换成网络状态的枚举类型，最后放到了RunLoop里面，设置到了主RunLoop，并设置model为CommonModes，CommonModes就是普通的和事件处理Mode的集合，不清楚的可以去看RunLoop相关文档。</p>
<h2 id="结束监听网络状态"><a href="#结束监听网络状态" class="headerlink" title="结束监听网络状态"></a>结束监听网络状态</h2><p>结束也比较简单，当然，我们可以自己调用，也可以不调用。因为在类销毁的时候，dealloc中也调用了这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)stopMonitoring &#123;</div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看一下网络状态的枚举，也就是我们可以捕获到的网络状态有哪些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</div><div class="line">    AFNetworkReachabilityStatusUnknown          = -1,</div><div class="line">    AFNetworkReachabilityStatusNotReachable     = 0,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWWAN = 1,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWiFi = 2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>默认是Unknown未知，然后是网络不可达，无线广域网链接，WiFi链接，此处没有区分2G/3G/4G,所以需要使用的小伙伴还得自行处理。</p>
<p>当然AF也为我们提供了获取的属性方法，我们可以直接调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WWAN.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WiFi.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi;</div></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isReachable &#123;</div><div class="line">    return [self isReachableViaWWAN] || [self isReachableViaWiFi];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWWAN &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWiFi &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，我们可以拿到网络是不是可达，当前是不是状态WWAN，WiFi。使用比较方便。</p>
<p>基本就是这些了，如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p><img src="http://chuantu.biz/t5/36/1475134450x3340469572.png" alt=""></p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之NSURLSession]]></title>
      <url>http://semyonxu.com/2016/09/28/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BNSURLSession/</url>
      <content type="html"><![CDATA[<p>NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。</p>
<p>下面分两个部分来解析：<br> 父类：AFURLSessionManager，<br> 子类：AFHTTPSessionManager</p>
<p>父类AFURLSessionManager对系统的NSURLSession类的网络请求进行了封装，并把NSURLSession里面的delegate返回值通过block返回回去。<br>子类AFHTTPSessionManager继承了所有父类的功能，在这个基础上封装了支持GET，POST，PUT，HEAD，PATCH，DELETE等HTTP请求方式，使用更加方便。当然不用子类，也是可以直接进行网络请求的。<br><a id="more"></a></p>
<h1 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h1><h2 id="先看初始化方法"><a href="#先看初始化方法" class="headerlink" title="先看初始化方法"></a>先看初始化方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">  - (instancetype)init &#123;</div><div class="line">    return [self initWithSessionConfiguration:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!configuration) &#123;</div><div class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    self.sessionConfiguration = configuration;</div><div class="line"></div><div class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">    self.operationQueue.maxConcurrentOperationCount = 1; // 最大并发数量1，不允许并发？当前请求任务只能是一个。</div><div class="line"></div><div class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 代理的设置在这里。我找的好苦啊。。。</div><div class="line"></div><div class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line"></div><div class="line">#if !TARGET_OS_WATCH</div><div class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">#endif</div><div class="line"></div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</div><div class="line"></div><div class="line">    self.lock = [[NSLock alloc] init];</div><div class="line">    self.lock.name = AFURLSessionManagerLockName;</div><div class="line"></div><div class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</div><div class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</div><div class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</div><div class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对各个属性进行了基本的初始化，为session初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSessionsessionWithConfiguration:self.sessionConfigurationdelegate:selfdelegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>我们可以看到是用的系统NSURLSession的初始化方法。</p>
<p>此处会遍历所有task添加delegate方法，猜测是兼容上次为未完成的请求Task，再继续进行处理，具体还得看情况，因为我跟了多次都是没有走这个方法。</p>
<h2 id="网络请求支持的几个方法"><a href="#网络请求支持的几个方法" class="headerlink" title="网络请求支持的几个方法"></a>网络请求支持的几个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///---------------------------</div><div class="line">/// @name Running Upload Tasks</div><div class="line">///---------------------------</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromFile:(NSURL *)fileURL</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromData:(nullable NSData *)bodyData</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</div><div class="line">                                                 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///-----------------------------</div><div class="line">/// @name Running Download Tasks</div><div class="line">///-----------------------------</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                             progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData</div><div class="line">                                                progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                             destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                       completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>这里面封装了系统NSURLSession的dataTask、uploadTask、downloadTask方法。而且另外添加了数据的进度progress。</p>
<p>下面我们来解析一下实现原理：<br>首先看一下dataTask的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request]; // 核心方法，NSURLSessionDataTask的dataTask方法。</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; // 设置代理，所有进度的处理都在代理中。进度的回调。</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，这里使用的是NSURLSessionDataTask的dataTaskWithRequest:方法，这个地方加了数据保护。然后就是为这个dataTask添加代理。所以核心的工作都交个这个代理AFURLSessionManagerTaskDelegate类来处理，那么这个代理的作用就显得尤为重要。</p>
<h2 id="网络请求的代理类AFURLSessionManagerTaskDelegate"><a href="#网络请求的代理类AFURLSessionManagerTaskDelegate" class="headerlink" title="网络请求的代理类AFURLSessionManagerTaskDelegate"></a>网络请求的代理类AFURLSessionManagerTaskDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</div><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div><div class="line">@property (nonatomic, strong) NSMutableData *mutableData;</div><div class="line">@property (nonatomic, strong) NSProgress *uploadProgress;</div><div class="line">@property (nonatomic, strong) NSProgress *downloadProgress;</div><div class="line">@property (nonatomic, copy) NSURL *downloadFileURL;</div><div class="line">@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading; // 下载任务结束回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock; // 上传进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock; // 下载进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler; // 返回成功结果的Block</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里遵循了NSURLSessionDataDelegate,NSURLSessionDataDelegate,NSURLSessionDownloadDelegate,所以是将NSURLSession的基本代理功能封装了一下。然后会对这些代理方法的返回数据进行处理，使用completionHandler Block来进行返回。</p>
<p>首先来看下代理的核心部分，然后再解读progress的封装思路</p>
<h3 id="代理的核心部分"><a href="#代理的核心部分" class="headerlink" title="代理的核心部分"></a>代理的核心部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSURLSessionTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // 单利group对象，why？这样是不是就可以对多个返回结果进行处理，这样的话，就不用顺序等待了，哪个先完成就先返回回去。</div><div class="line">            // 看参数：如果用户传了group对象，那么选择的是用户的，否则直接使用单利的组对象。 队列是默认是主队列，用户填写的就是用户的。</div><div class="line">            if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 成功后数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123; // 下载的情况下，responseObject为下载的本地地址</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // why use gcd group?</div><div class="line">                if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError); // response Header, 返回结果， 解析错误。</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123; // 此处任务完成的通知只是为了UIKit中的一些类别中拿到回调。userInfo字段并没有返回给外部，而是给UIKit用的。当然我们可以用这个通知来获取到。</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDataTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到这里核心的方法只有三个，一个是task完成的回调，一个是接受到数据的回调，最后是下载完成的回调。<br>普通的task请求会先走第二个方法didReceiveData方法，把返回的数据添加到mutableData中。<br>然后再走第一个方法，请求完成的回调。</p>
<h4 id="第一个方法："><a href="#第一个方法：" class="headerlink" title="第一个方法："></a>第一个方法：</h4><p>首先会把返回的数据赋给一个局部变量data，然后将全局的mutableData置空，这样就可以保证下次请求的数据是重新加载。这里区分了下载和普通的数据返回，如果是下载的话，直接下载到指定文件路径中，如果用户指定这个路径的话，userInfo字典里面存的就是下载路径，否则，存的是下载数据。<br>然后就是判断有没有错误，错误的话把错误返回，返回值task.response, responseObject此处是空的，然后就是error。最后在主线程中发送通知，为当前task的userInfo，注意此处的userInfo只是用来做通知信息的。而我们平时用的时候不会用通知来获取请求成功的回调，这个通知是为了AFNetworking中的UIKit封装部分服务的。<br>然后就是成功的回调，异步请求在单利队列中，这里对队列的生成都加了单利的保护。这里通过responseSerializer 对结果数据进行转化成对应的格式（这可以参考Serialization部分，里面讲解如何转化的），如果是下载的话，responseObject直接赋值成downloadFileURL，也就是下载的话，回调中只会有下载的目标地址。然后就是对userInfo的AFNetworkingTaskDidCompleteSerializedResponseKey（序列化响应结果）、AFNetworkingTaskDidCompleteErrorKey（序列化过程中的错误信息）进行赋值，不得不说AFNetworking对各个部分的情况都返回回去了，做的很详细。<br>然后就是调用回调block：completionHandler：<br>返回值task.response也就是完整的返回头信息以及返回的状态码。<br>responseObject是返回的数据或者是下载的目标地址。<br>serializationError注意这个地方的错误是序列化的错误，也就是此处如果对返回数据序列化产生错误，也会照样返回成功回调，只是回调结果会是序列化的错误。<br>最后还是一样的发送通知。</p>
<h4 id="第二个方法："><a href="#第二个方法：" class="headerlink" title="第二个方法："></a>第二个方法：</h4><p>简单的接收到返回数据，简单的把数据进行拼接。</p>
<h4 id="第三个方法："><a href="#第三个方法：" class="headerlink" title="第三个方法："></a>第三个方法：</h4><p>下载的方法，此处如果有downloadTaskDidFinishDownloading的实现，那么进行调用转换目标地址，而目标地址是在下面这个方法的destination Block中进行设置的，这个地方转了一下，也就是倒了两个block让用户来设置这个目标地址。如果可以正常获取这个目标地址的话，把location（也就是本地下载路径，其实就是缓存路径，因为这里下载完成后会删掉）的数据转移到目标路径。响应的会有文件操作的错误信息的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络请求progress的封装思路"><a href="#网络请求progress的封装思路" class="headerlink" title="网络请求progress的封装思路"></a>网络请求progress的封装思路</h3><p>此处使用的技术是KVO，先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    __weak __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</div><div class="line">    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</div><div class="line">    [self.uploadProgress setCancellable:YES];</div><div class="line">    [self.uploadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.uploadProgress setPausable:YES];</div><div class="line">    [self.uploadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line">    if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.uploadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self.downloadProgress setCancellable:YES];</div><div class="line">    [self.downloadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.downloadProgress setPausable:YES];</div><div class="line">    [self.downloadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.downloadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [self.downloadProgress addObserver:self</div><div class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                               options:NSKeyValueObservingOptionNew</div><div class="line">                               context:NULL];</div><div class="line">    [self.uploadProgress addObserver:self</div><div class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                             options:NSKeyValueObservingOptionNew</div><div class="line">                             context:NULL];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)cleanUpProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))];</div><div class="line">    [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">    [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</div><div class="line">            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</div><div class="line">            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</div><div class="line">        if (self.downloadProgressBlock) &#123;</div><div class="line">            self.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</div><div class="line">        if (self.uploadProgressBlock) &#123;</div><div class="line">            self.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化方法中我们可以看到KVO监听的KeyPath是NSURLSessionTask的四个只读属性：countOfBytesReceived, countOfBytesExpectedToReceive, countOfBytesSent, countOfBytesExpectedToSend， 也就是Task的数据统计的一些信息。 downloadProgress和uploadProgress都对fractionCompleted进行监听，也就是进度完成的百分比。<br>这里cleanUp移除所有的KVO，KVO我们平时使用的时候也是需要注意移除的，防止发生原来的还在，又添加监听导致多次监听，那么悲剧了，就是执行监听结果方法的调用越来越多。莫名其妙的bug。<br>最后KVO监听到结果的回调中，对downloadProgress，uploadProgress分别进行completedunitCount完成进度的赋值、totalUnitCount所有进度的复制。如果对象不是task而是NSProgress对象，那么直接把这个object返回回去。</p>
<h2 id="NSURLSession代理方法的转换处理"><a href="#NSURLSession代理方法的转换处理" class="headerlink" title="NSURLSession代理方法的转换处理"></a>NSURLSession代理方法的转换处理</h2><p>首先这里会有很多block的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;</div><div class="line"></div><div class="line">- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">///--------------------------------------</div><div class="line">/// @name Setting Task Delegate Callbacks</div><div class="line">///--------------------------------------</div><div class="line"></div><div class="line">- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;</div><div class="line"></div><div class="line">- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;</div><div class="line"></div><div class="line">- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</div><div class="line"></div><div class="line">- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;</div><div class="line"></div><div class="line">///-------------------------------------------</div><div class="line">/// @name Setting Data Task Delegate Callbacks</div><div class="line">///-------------------------------------------</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;</div><div class="line"></div><div class="line">- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;</div><div class="line"></div><div class="line">- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block;</div><div class="line"></div><div class="line">///-----------------------------------------------</div><div class="line">/// @name Setting Download Task Delegate Callbacks</div><div class="line">///-----------------------------------------------</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable  (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</div></pre></td></tr></table></figure>
<p>也就是支持对所有的NSURLSession代理方法的回调方法直接使用block传给用户使用，这里既支持我们处理原始的回调，AFNetworking在里面继续做响应的处理。</p>
<p>具体方法的处理，由于太多了，我们就分析一下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line"></div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会获取到当前task的delegate对象，然后在代理中对这些数据进行处理。这个方法是在网络完成的时候执行的，所以这里应该将这个task移除掉。数据的处理参见3)里面的AFURLSessionManagerTaskDelegate的方法解析。 最后会执行taskDidComplete的block回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); // block 带入目标地址的url，在外面设置</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>download的完成方法的回调，我们看到跟AFURLSessionManagerTaskDelegate中的方法功能基本是一样的，也就是如果有AFURLSessionManager类中有downloadTaskDidFinishDownloading的block实现的话，就直接在NSURLSessionDownloadDelegate中处理，如果现在还没有实现block，那么就放在delegete里面处理。注意这个地方AFURLSessionManager和NSURLSessionDownloadDelegate都有这个downloadTaskDidFinishDownloading 的block。</p>
<p>就这俩吧，其他的代理方法基本上都是转换成block进行回调，有的复杂一点需要对block的值进行处理一下，然后在回调回去。</p>
<h2 id="关于多任务的处理"><a href="#关于多任务的处理" class="headerlink" title="关于多任务的处理"></a>关于多任务的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = nil;</div><div class="line">    [self.lock lock];</div><div class="line">    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line"></div><div class="line">    return delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask</div><div class="line">                        progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">               completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    uploadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:uploadTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是支持多任务请求的。这里使用字典存的是当前task的代理AFURLSessionManagerTaskDelegate的delegate：<br>@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;<br>也就是所有的请求会把代理使用task的taskIdentifier标记存起来。设置代理的时候加了保护锁，保证可变字典的安全操作。</p>
<h2 id="AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"><a href="#AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state" class="headerlink" title="_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"></a>_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</div><div class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</div><div class="line">#pragma GCC diagnostic push</div><div class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</div><div class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</div><div class="line">        Class currentClass = [localDataTask class];</div><div class="line">        </div><div class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</div><div class="line">            Class superClass = [currentClass superclass];</div><div class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</div><div class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</div><div class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</div><div class="line">                originalAFResumeIMP != classResumeIMP) &#123;</div><div class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</div><div class="line">            &#125;</div><div class="line">            currentClass = [currentClass superclass];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [localDataTask cancel];</div><div class="line">        [session finishTasksAndInvalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</div><div class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</div><div class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionTaskState)state &#123;</div><div class="line">    NSAssert(NO, @&quot;State method should never be called in the actual dummy class&quot;);</div><div class="line">    return NSURLSessionTaskStateCanceling;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_resume &#123; // 通过Swizzle发通知AFNSURLSessionTaskDidResumeNotification</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_resume];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_suspend &#123;</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_suspend];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用runtime技术的swizzle方法对新初始化的一个NSURLSessionDataTask对象进行方法替换。替换resume方法的实现为af_resume，suspend的方法实现为af_suspend。这里面对当前的NSURLSessionTaskState进行操作。</p>
<h1 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h1><p>这部分是继承自AFURLSessionManager，如果是AFURLSessionManager是网络的核心部分，那么这部分就是方便开发者调用的一个实现部分。<br>这里面其实封装的比较简单。看一下属性数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div></pre></td></tr></table></figure>
<p>里面一个基本的URL，请求序列化，响应序列化。注意这个地方，请求序列化是在AFHTTPSessionManager中做的处理，而responseSerializer是在AFURLSessionManager中做的处理。</p>
<p>初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</div><div class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>这里支持类方法和实例方法。当然了类方法是封装的实例方法。</p>
<p>提供的网络请求方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                            parameters:(nullable id)parameters</div><div class="line">                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">     constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">              constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString</div><div class="line">                     parameters:(nullable id)parameters</div><div class="line">                        success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                        failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString</div><div class="line">                      parameters:(nullable id)parameters</div><div class="line">                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div></pre></td></tr></table></figure>
<p>以上是提供的所有的方法，HTTP协议的基本请求类型GET，POST，PUT，HEAD，DELETE都封装了。</p>
<p>下面我们看一下GET的实现，因为其他的思路都是一样的，出了POST另外增加了一种body类型的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(id)parameters</div><div class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</div><div class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</div><div class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                   uploadProgress:nil</div><div class="line">                                                 downloadProgress:downloadProgress</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line"></div><div class="line">    [dataTask resume];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到调用的是dataTaskWithHTTPMethod: URLString: parameters: uploadProgress: downloadProgress: success: failure:方法。除了POST新增的方法，其他的都是直接调用的这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是简单的把请求数据进行了序列化，如果错误的话就直接返回nil，不会发送任何请求。成功的话，进行调用AFURLSessionManager中的方法，最后对返回值进行了简单处理。封装的还算简单，没有太多复杂的逻辑。</p>
<p>最后看一下POST的另一个增加的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(id)parameters</div><div class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</div><div class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</div><div class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(task, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(task, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [task resume];</div><div class="line"></div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装思路跟上面的基本上是一样的，序列化数据的时候会把body的内容封装在请求body里面：<br> [self.requestsetHTTPBodyStream:self.bodyStream];<br> 相应的这里调用的是AFURLSessionManager中的StreamRequest方法。</p>
<p>如果文中有什么错误，欢迎指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p><img src="http://chuantu.biz/t5/36/1475134450x3340469572.png" alt=""></p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
  
  
</search>
