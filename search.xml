<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JSPatch源码解析]]></title>
      <url>http://semyonxu.com/2017/07/12/JSPatch%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>JSPatch一款优秀的热更新框架，最近由于各种原因被苹果封杀了，虽然我们开发者暂时不能使用这种方式来进行来热更新，但是代码还是值得我们好好学习一下的，尤其是里面对于Runtime的使用，我们可以把它当做是Runtime的实践教材。</p>
<p>当然热更新的方式还有很多，Weex，React Native, Hybrid … 好像苹果现在并没有禁止JavaScriptCore引擎下的代码下发。</p>
<p>其实框架的实现原理，作者已经写的很详细了，本文主要是从源码的角度来解析实现过程。</p>
<p>下面根据调用流程来看一下，具体的是怎么实现的。<br>本文JS代码的调试是使用的Safari，具体步骤：<br>Safari-&gt;开发-&gt;Simulator-&gt;选择当前执行的js</p>
<a id="more"></a>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>举个栗子，比如有一个bug:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (IBAction)btnClick:(id)sender &#123;</div><div class="line">    NSArray *arrTest = @[@&quot;1&quot;];</div><div class="line">    @try &#123;</div><div class="line">        NSString *strCrash = [arrTest objectAtIndex:2];</div><div class="line">        NSLog(@&quot;strCrash %@&quot;, strCrash);</div><div class="line">        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Click&quot; message:@&quot;Success&quot; delegate:nil cancelButtonTitle:@&quot;Yes&quot; otherButtonTitles:nil, nil];</div><div class="line">        [alert show];</div><div class="line">    &#125; @catch (NSException *exception) &#123;</div><div class="line">        NSLog(@&quot;exception is %@&quot;, exception);</div><div class="line">    &#125; @finally &#123;</div><div class="line">        NSLog(@&quot;finally&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经典的数组越界问题，当然这里添加了try catch并不会崩溃，但是会抛出异常。</p>
<p>使用JSPatch下发main.js代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">require(&quot;UIAlertView&quot;);</div><div class="line"></div><div class="line">defineClass(&quot;ViewController&quot;, &#123;</div><div class="line">btnClick: function(sender) &#123;</div><div class="line">var arrTest = [&quot;arrTest&quot;];</div><div class="line">var strCrash = arrTest[0];</div><div class="line"></div><div class="line">var alert = UIAlertView.alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;JSPatchAmend&quot;, &quot;Success&quot;, null, &quot;Yes&quot;, null, null);</div><div class="line">    alert.show();</div><div class="line">&#125;</div><div class="line">&#125;, &#123;&#125;, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>当然我们现在没有JS代码下发的逻辑，所以模拟一下JS代码的执行，main.js先加到工程中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)testJSPatch &#123;</div><div class="line">    NSString *strJsPath = [[NSBundle mainBundle] pathForResource:@&quot;main&quot; ofType:@&quot;js&quot;];</div><div class="line">    NSLog(@&quot;strJsPath %@&quot;, strJsPath);</div><div class="line">    JSValue *resultValue = [JPEngine evaluateScriptWithPath:strJsPath];</div><div class="line">    NSLog(@&quot;resultValue %@&quot;, resultValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="追踪代码"><a href="#追踪代码" class="headerlink" title="追踪代码"></a>追踪代码</h3><h4 id="首先我们调用的是JPEngine类的evaluateScriptWithPath方法"><a href="#首先我们调用的是JPEngine类的evaluateScriptWithPath方法" class="headerlink" title="首先我们调用的是JPEngine类的evaluateScriptWithPath方法"></a>首先我们调用的是JPEngine类的evaluateScriptWithPath方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">+ (JSValue *)evaluateScriptWithPath:(NSString *)filePath</div><div class="line">&#123;</div><div class="line">    _scriptRootDir = [filePath stringByDeletingLastPathComponent];</div><div class="line">    return [self _evaluateScriptWithPath:filePath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (JSValue *)_evaluateScriptWithPath:(NSString *)filePath</div><div class="line">&#123;</div><div class="line">    NSString *script = [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil]; // 获取JS代码 字符串</div><div class="line">    return [self _evaluateScript:script withSourceURL:[NSURL URLWithString:[filePath lastPathComponent]]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (JSValue *)_evaluateScript:(NSString *)script withSourceURL:(NSURL *)resourceURL</div><div class="line">&#123;</div><div class="line">    if (!script || ![JSContext class]) &#123;</div><div class="line">        _exceptionBlock(@&quot;script is nil&quot;);</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    [self startEngine]; // 开启引擎， 开始初始化一些参数</div><div class="line">    </div><div class="line">    if (!_regex) &#123;</div><div class="line">        _regex = [NSRegularExpression regularExpressionWithPattern:_regexStr options:0 error:nil];</div><div class="line">    &#125;</div><div class="line">    // js字符串代码格式转换：新增了try catch，防止崩溃，使用正则 替换方法__c(),方法的调用统一走__c()方法</div><div class="line">    NSString *formatedScript = [NSString stringWithFormat:@&quot;;(function()&#123;try&#123;\n%@\n&#125;catch(e)&#123;_OC_catch(e.message, e.stack)&#125;&#125;)();&quot;, [_regex stringByReplacingMatchesInString:script options:0 range:NSMakeRange(0, script.length) withTemplate:_replaceStr]];</div><div class="line">    @try &#123;</div><div class="line">        if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) &#123;</div><div class="line">            return [_context evaluateScript:formatedScript withSourceURL:resourceURL]; // 调用JS</div><div class="line">        &#125; else &#123;</div><div class="line">            return [_context evaluateScript:formatedScript];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    @catch (NSException *exception) &#123;</div><div class="line">        _exceptionBlock([NSString stringWithFormat:@&quot;%@&quot;, exception]);</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里获取到JS代码字符串之后，开始调用+ (JSValue <em>)_evaluateScript:(NSString </em>)script withSourceURL:(NSURL *)resourceURL 方法执行调用。</p>
<p>方法逻辑：</p>
<ul>
<li><p>调用startEngine 方法（初始化参数，并调用JSPatch.js）</p>
</li>
<li><p>使用正则替换替换所有方法调用为 __c() 的形式，并添加try-catch语句防止崩溃</p>
</li>
<li><p>执行main.js代码，并使用_exceptionBlock抛出异常</p>
</li>
</ul>
<h4 id="看一下startEngine方法"><a href="#看一下startEngine方法" class="headerlink" title="看一下startEngine方法"></a>看一下startEngine方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">+ (void)startEngine</div><div class="line">&#123;</div><div class="line">    if (![JSContext class] || _context) &#123; // 如果已经初始化_context就返回，不需要重新初始化</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    JSContext *context = [[JSContext alloc] init];</div><div class="line">    </div><div class="line">    // 提前注册JS方法调用，js调用对应方法的时候回调给OC方法</div><div class="line">#ifdef DEBUG</div><div class="line">    context[@&quot;po&quot;] = ^JSValue*(JSValue *obj) &#123;</div><div class="line">        id ocObject = formatJSToOC(obj);</div><div class="line">        return [JSValue valueWithObject:[ocObject description] inContext:_context];</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    context[@&quot;bt&quot;] = ^JSValue*() &#123;</div><div class="line">        return [JSValue valueWithObject:_JSLastCallStack inContext:_context];</div><div class="line">    &#125;;</div><div class="line">#endif</div><div class="line"></div><div class="line">    context[@&quot;_OC_defineClass&quot;] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) &#123;</div><div class="line">        return defineClass(classDeclaration, instanceMethods, classMethods); // 类名， 实例方法，类方法</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    context[@&quot;_OC_defineProtocol&quot;] = ^(NSString *protocolDeclaration, JSValue *instProtocol, JSValue *clsProtocol) &#123;</div><div class="line">        return defineProtocol(protocolDeclaration, instProtocol,clsProtocol);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    context[@&quot;_OC_callI&quot;] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) &#123; // call instace method</div><div class="line">        return callSelector(nil, selectorName, arguments, obj, isSuper);</div><div class="line">    &#125;;</div><div class="line">    context[@&quot;_OC_callC&quot;] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) &#123; // call class method</div><div class="line">        return callSelector(className, selectorName, arguments, nil, NO);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">   ...</div><div class="line">       </div><div class="line">    context.exceptionHandler = ^(JSContext *con, JSValue *exception) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, exception);</div><div class="line">        _exceptionBlock([NSString stringWithFormat:@&quot;js exception: %@&quot;, exception]);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    _nullObj = [[NSObject alloc] init];</div><div class="line">    context[@&quot;_OC_null&quot;] = formatOCToJS(_nullObj);</div><div class="line">    </div><div class="line">    _context = context;</div><div class="line">    </div><div class="line">    // 初始化</div><div class="line">    _nilObj = [[NSObject alloc] init];</div><div class="line">    _JSMethodSignatureLock = [[NSLock alloc] init];</div><div class="line">    _JSMethodForwardCallLock = [[NSRecursiveLock alloc] init];</div><div class="line">    _registeredStruct = [[NSMutableDictionary alloc] init];</div><div class="line">    _currInvokeSuperClsName = [[NSMutableDictionary alloc] init];</div><div class="line">    </div><div class="line">#if TARGET_OS_IPHONE</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleMemoryWarning) name:UIApplicationDidReceiveMemoryWarningNotification object:nil];</div><div class="line">#endif</div><div class="line">    </div><div class="line">    // 运行JSPatch.js代码</div><div class="line">    NSString *path = [[NSBundle bundleForClass:[self class]] pathForResource:@&quot;JSPatch&quot; ofType:@&quot;js&quot;];</div><div class="line">    if (!path) _exceptionBlock(@&quot;can&apos;t find JSPatch.js&quot;);</div><div class="line">    NSString *jsCore = [[NSString alloc] initWithData:[[NSFileManager defaultManager] contentsAtPath:path] encoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    if ([_context respondsToSelector:@selector(evaluateScript:withSourceURL:)]) &#123;</div><div class="line">        [_context evaluateScript:jsCore withSourceURL:[NSURL URLWithString:@&quot;JSPatch.js&quot;]];</div><div class="line">    &#125; else &#123;</div><div class="line">        [_context evaluateScript:jsCore];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法逻辑：</p>
<ul>
<li>提前注册JS调用OC的方法，具体如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">_OC_defineClass， 定义类</div><div class="line">_OC_defineProtocol，定义协议</div><div class="line">_OC_callI，调用实例方法</div><div class="line">_OC_callC，调用类方法</div><div class="line">_OC_formatJSToOC，格式化JS为OC类型</div><div class="line">_OC_formatOCToJS，格式化OC为JS类型</div><div class="line">_OC_getCustomProps，获取属性get方法</div><div class="line">_OC_setCustomProps，获取属性set方法</div><div class="line">__weak，__weak属性</div><div class="line">__strong， __strong 属性</div><div class="line">_OC_superClsName，获取父类名</div><div class="line">resourcePath， 获取js文件路径</div><div class="line">dispatch_after，GCD延时调用</div><div class="line">dispatch_async_main，GCD异步主队列</div><div class="line">dispatch_sync_main，GCD同步主队列</div><div class="line">dispatch_async_global_queue，GCD全局队列</div><div class="line">releaseTmpObj，释放tmp对象</div><div class="line">_OC_log， log信息</div><div class="line">_OC_null， 空对象</div></pre></td></tr></table></figure>
<ul>
<li><p>初始化一些变量 _nilObj，_JSMethodSignatureLock，_JSMethodForwardCallLock…</p>
</li>
<li><p>加载JSPatch.js代码</p>
</li>
</ul>
<h4 id="执行main-js代码的时候使用的是JSpatch-js里面的defineClass-方法"><a href="#执行main-js代码的时候使用的是JSpatch-js里面的defineClass-方法" class="headerlink" title="执行main.js代码的时候使用的是JSpatch.js里面的defineClass()方法"></a>执行main.js代码的时候使用的是JSpatch.js里面的defineClass()方法</h4><p>看一下JSPatch.js中的defineClass()方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// declaration: 类名，父类，协议的描述，cls:supercls&lt;protocol..&gt;</div><div class="line">// properties: &#123; 方法名：JS的方法实现 &#125;</div><div class="line">// instMethods</div><div class="line">global.defineClass = function(declaration, properties, instMethods, clsMethods) &#123;</div><div class="line">  var newInstMethods = &#123;&#125;, newClsMethods = &#123;&#125;</div><div class="line">  if (!(properties instanceof Array)) &#123; // properties 不是数组，是字典类型： &#123;方法名：方法体&#125;，直接赋值给 instMethods，然后置空</div><div class="line">    clsMethods = instMethods</div><div class="line">    instMethods = properties</div><div class="line">    properties = null</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /*</div><div class="line">   逻辑：如果是属性那么使用数组[property1,property2], 再动态获取set，get方法然后放到instMethods字典中，也就是instMethods中存的是&#123;方法名：方法实现&#125;</div><div class="line">   */</div><div class="line">  if (properties) &#123; // 此时 properties 应该是数组，那么处理OC属性Property相关，</div><div class="line">    properties.forEach(function(name)&#123;</div><div class="line">      if (!instMethods[name]) &#123;</div><div class="line">        instMethods[name] = _propertiesGetFun(name); // 设置property的get方法</div><div class="line">      &#125;</div><div class="line">      var nameOfSet = &quot;set&quot;+ name.substr(0,1).toUpperCase() + name.substr(1); // set方法</div><div class="line">      if (!instMethods[nameOfSet]) &#123;</div><div class="line">        instMethods[nameOfSet] = _propertiesSetFun(name); // 设置property的set方法</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // 获取真实的类名</div><div class="line">  var realClsName = declaration.split(&apos;:&apos;)[0].trim()  // split 把一个字符串分割成字符串数组</div><div class="line"></div><div class="line">  _formatDefineMethods(instMethods, newInstMethods, realClsName)</div><div class="line">  _formatDefineMethods(clsMethods, newClsMethods, realClsName)</div><div class="line"></div><div class="line">  var ret = _OC_defineClass(declaration, newInstMethods, newClsMethods) // oc构造类，返回类名，父类名 返回值：@&#123;@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName&#125;;</div><div class="line">  var className = ret[&apos;cls&apos;]</div><div class="line">  var superCls = ret[&apos;superCls&apos;]</div><div class="line"></div><div class="line">  _ocCls[className] = &#123;</div><div class="line">    instMethods: &#123;&#125;,</div><div class="line">    clsMethods: &#123;&#125;,</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (superCls.length &amp;&amp; _ocCls[superCls]) &#123;</div><div class="line">    for (var funcName in _ocCls[superCls][&apos;instMethods&apos;]) &#123; // 如果父类中有这个实例方法，直接赋值给当前类</div><div class="line">      _ocCls[className][&apos;instMethods&apos;][funcName] = _ocCls[superCls][&apos;instMethods&apos;][funcName]</div><div class="line">    &#125;</div><div class="line">    for (var funcName in _ocCls[superCls][&apos;clsMethods&apos;]) &#123;  // 如果父类中有这个类例方法，直接赋值给当前类</div><div class="line">      _ocCls[className][&apos;clsMethods&apos;][funcName] = _ocCls[superCls][&apos;clsMethods&apos;][funcName]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // className: OC定义的类名，instMethods：实例方法&#123;方法名：方法实现&#125;，instMethods:解析declaration获取的真实类名</div><div class="line">  // 对js代码进行了一次包装，_wrapLocalMethod</div><div class="line">  _setupJSMethod(className, instMethods, 1, realClsName)</div><div class="line">  _setupJSMethod(className, clsMethods, 0, realClsName)</div><div class="line"></div><div class="line">  return require(className) // 返回的是： &#123;__clsName: 类名&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法逻辑：</p>
<ul>
<li><p>处理传入的JS方法</p>
<p>properties传入的不是数组类型，那么就是方法类型：{方法名：方法实现}，直接赋值给instMethods，并置nil。</p>
</li>
<li><p>处理属性方法数组</p>
<p>properties传入的是数组类型，那么处理这些属性，动态生成set，get方法，使用的是Runtime的关联对象方法。</p>
</li>
<li><p>格式化实例方法，类方法</p>
<p>格式化类方法，实例方法，将方法封装成数组 [1, function()]， 1 为 originMethod.length（var originMethod = methods[methodName] ）根据OC代码来看应该是参数个数, function()方法对之前的方法进行了封装，封装方法跟下面的_setupJSMethod一样。</p>
</li>
<li><p>调用OC的_OC_defineClass方法执行定义类</p>
<p>下面解析这个OC方法，返回类型是：<br>{“cls”: className, “superCls”: superClassName};</p>
</li>
<li><p>如果本地缓存_ocCls中有父类，将继承所有父类方法。</p>
</li>
<li>设置JS方法，进行了一次包装</li>
<li>最后返回类名的字典：{__clsName: 类名}</li>
</ul>
<h4 id="穿插中间调用JPEngine-m中的-OC-defineClass-方法"><a href="#穿插中间调用JPEngine-m中的-OC-defineClass-方法" class="headerlink" title="穿插中间调用JPEngine.m中的_OC_defineClass()方法"></a>穿插中间调用JPEngine.m中的_OC_defineClass()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line">context[@&quot;_OC_defineClass&quot;] = ^(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods) &#123;</div><div class="line">        return defineClass(classDeclaration, instanceMethods, classMethods); // 类名， 实例方法，类方法</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">static NSDictionary *defineClass(NSString *classDeclaration, JSValue *instanceMethods, JSValue *classMethods)</div><div class="line">&#123;</div><div class="line">    // classDeclaration: 原始的类名 + :父类 + &apos;&lt;&gt;&apos;协议</div><div class="line">    // 通过runtime定义类，并返回类名，父类名</div><div class="line">    NSScanner *scanner = [NSScanner scannerWithString:classDeclaration];</div><div class="line">    </div><div class="line">    NSString *className;</div><div class="line">    NSString *superClassName;</div><div class="line">    NSString *protocolNames; //  class:superclass&lt;protocol&gt; 扫描获取className，superClassName，protocolNames</div><div class="line">    [scanner scanUpToString:@&quot;:&quot; intoString:&amp;className];</div><div class="line">    if (!scanner.isAtEnd) &#123;</div><div class="line">        scanner.scanLocation = scanner.scanLocation + 1;</div><div class="line">        [scanner scanUpToString:@&quot;&lt;&quot; intoString:&amp;superClassName];</div><div class="line">        if (!scanner.isAtEnd) &#123;</div><div class="line">            scanner.scanLocation = scanner.scanLocation + 1;</div><div class="line">            [scanner scanUpToString:@&quot;&gt;&quot; intoString:&amp;protocolNames];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (!superClassName) superClassName = @&quot;NSObject&quot;; // 默认父类都是NSObject</div><div class="line">    className = trim(className); // 去空格</div><div class="line">    superClassName = trim(superClassName);</div><div class="line">    </div><div class="line">    NSArray *protocols = [protocolNames length] ? [protocolNames componentsSeparatedByString:@&quot;,&quot;] : nil;</div><div class="line">    </div><div class="line">    Class cls = NSClassFromString(className);</div><div class="line">    if (!cls) &#123; // 转换不了此类，动态新增一个NSObject的子类</div><div class="line">        Class superCls = NSClassFromString(superClassName);</div><div class="line">        if (!superCls) &#123;</div><div class="line">            _exceptionBlock([NSString stringWithFormat:@&quot;can&apos;t find the super class %@&quot;, superClassName]);</div><div class="line">            return @&#123;@&quot;cls&quot;: className&#125;;</div><div class="line">        &#125;</div><div class="line">        cls = objc_allocateClassPair(superCls, className.UTF8String, 0);</div><div class="line">        objc_registerClassPair(cls);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (protocols.count &gt; 0) &#123; // 添加协议列表</div><div class="line">        for (NSString* protocolName in protocols) &#123;</div><div class="line">            Protocol *protocol = objc_getProtocol([trim(protocolName) cStringUsingEncoding:NSUTF8StringEncoding]);</div><div class="line">            class_addProtocol (cls, protocol);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (int i = 0; i &lt; 2; i ++) &#123; // 第一次循环对类进行操作，第二次循环对元类进行操作</div><div class="line">        BOOL isInstance = i == 0;</div><div class="line">        JSValue *jsMethods = isInstance ? instanceMethods: classMethods; // 方法</div><div class="line">        </div><div class="line">        // instanceMethods 字典 key:方法名， value：数组（0：参数个数 1：js代码？？？）</div><div class="line">        Class currCls = isInstance ? cls: objc_getMetaClass(className.UTF8String); // 类名</div><div class="line">        NSDictionary *methodDict = [jsMethods toDictionary];</div><div class="line">        for (NSString *jsMethodName in methodDict.allKeys) &#123;</div><div class="line">            JSValue *jsMethodArr = [jsMethods valueForProperty:jsMethodName];</div><div class="line">            /*</div><div class="line">             1,function () &#123;</div><div class="line">             try &#123;</div><div class="line">             var args = _formatOCToJS(Array.prototype.slice.call(arguments))</div><div class="line">             var lastSelf = global.self</div><div class="line">             global.self = args[0]</div><div class="line">             if (global.self) global.self.__realClsName = realClsName</div><div class="line">             args.splice(0,1) // 删除第一个元素</div><div class="line">             var ret = originMethod.apply(originMethod, args)</div><div class="line">             global.self = lastSelf</div><div class="line">             return ret</div><div class="line">             &#125; catch(e) &#123;</div><div class="line">             _OC_catch(e.message, e.stack)</div><div class="line">             &#125;</div><div class="line">             &#125;</div><div class="line">             */</div><div class="line">            int numberOfArg = [jsMethodArr[0] toInt32];</div><div class="line">            NSString *selectorName = convertJPSelectorString(jsMethodName);</div><div class="line">            </div><div class="line">            if ([selectorName componentsSeparatedByString:@&quot;:&quot;].count - 1 &lt; numberOfArg) &#123; // 这个地方一个参数可以添加一个&apos;:&apos;,如果是多个参数呢？怎么添加？</div><div class="line">                selectorName = [selectorName stringByAppendingString:@&quot;:&quot;];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            JSValue *jsMethod = jsMethodArr[1]; // 来自js代码</div><div class="line">            if (class_respondsToSelector(currCls, NSSelectorFromString(selectorName))) &#123; // 类中含有这个方法,替换方法，跳转拦截调用</div><div class="line">                overrideMethod(currCls, selectorName, jsMethod, !isInstance, NULL);</div><div class="line">            &#125; else &#123; // 类中没有这个方法, 可能是协议</div><div class="line">                BOOL overrided = NO;</div><div class="line">                for (NSString *protocolName in protocols) &#123; // 如果有协议，全部添加</div><div class="line">                    char *types = methodTypesInProtocol(protocolName, selectorName, isInstance, YES);</div><div class="line">                    if (!types) types = methodTypesInProtocol(protocolName, selectorName, isInstance, NO);</div><div class="line">                    if (types) &#123;</div><div class="line">                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, types);</div><div class="line">                        free(types);</div><div class="line">                        overrided = YES;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (!overrided) &#123;</div><div class="line">                    if (![[jsMethodName substringToIndex:1] isEqualToString:@&quot;_&quot;]) &#123;</div><div class="line">                        NSMutableString *typeDescStr = [@&quot;@@:&quot; mutableCopy];</div><div class="line">                        for (int i = 0; i &lt; numberOfArg; i ++) &#123;</div><div class="line">                            [typeDescStr appendString:@&quot;@&quot;];</div><div class="line">                        &#125;</div><div class="line">                        overrideMethod(currCls, selectorName, jsMethod, !isInstance, [typeDescStr cStringUsingEncoding:NSUTF8StringEncoding]);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 新增两个方法： setProp:  getProp: forKey:</div><div class="line">    class_addMethod(cls, @selector(getProp:), (IMP)getPropIMP, &quot;@@:@&quot;);</div><div class="line">    class_addMethod(cls, @selector(setProp:forKey:), (IMP)setPropIMP, &quot;v@:@@&quot;);</div><div class="line"></div><div class="line">    return @&#123;@&quot;cls&quot;: className, @&quot;superCls&quot;: superClassName&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法逻辑：</p>
<ul>
<li><p>解析classDeclaration中的类名，父类，协议</p>
<ul>
<li>没有父类，默认是NSObject</li>
<li>如果这个类不是系统类，调用runtime的objc_registerClassPair新建</li>
<li>如果有protocols，动态添加协议列表</li>
</ul>
</li>
<li><p>添加实例方法，类方法</p>
<p>双重for循环，第一次是对类操作，添加实例方法，第二次是对元类操作，添加类方法。</p>
<ul>
<li><p>遍历方法列表，获取jsMethodArr第0个位置：参数个数，为方法动态添加”:”</p>
</li>
<li><p>如果本类中，已经有这个方法，那么执行overrideMethod()方法替换，跳转拦截调用，下面解析</p>
</li>
<li><p>如果本类中，没有这个方法，可能是协议，先获取协议方法的参数类型typeDescription，再执行overrideMethod()方法</p>
</li>
<li><p>如果不是本类中的方法，也不是协议，那么需要获取到这个方法的参数类型typeDescription，再执行overrideMethod()</p>
</li>
<li><p>为类新增set，get方法，统一使用关联对象关联property</p>
</li>
<li><p>返回类名，父类名</p>
</li>
</ul>
</li>
</ul>
<h4 id="overrideMethod-到底做了些什么？"><a href="#overrideMethod-到底做了些什么？" class="headerlink" title="overrideMethod()到底做了些什么？"></a>overrideMethod()到底做了些什么？</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">// 方法替换方法 _objc_msgForward，所有的方法全部都跳转到拦截调用</div><div class="line">/*</div><div class="line"> * 新增了一个ORIGFunc方法，方法实现是原来的方法实现，添加到本类中</div><div class="line"> * 新增一个JSFunc名字, 将方法名添加_JP前缀作为key，将JS代码作为value存入_JSOverideMethods中, 为以后JS调用做存储</div><div class="line"> */</div><div class="line">static void overrideMethod(Class cls, NSString *selectorName, JSValue *function, BOOL isClassMethod, const char *typeDescription)</div><div class="line">&#123;</div><div class="line">    SEL selector = NSSelectorFromString(selectorName);</div><div class="line">    </div><div class="line">    if (!typeDescription) &#123; // 如果没有传typeDescription，就是类中有这个方法，那么可以直接通过方法获取typeDescription</div><div class="line">        Method method = class_getInstanceMethod(cls, selector);</div><div class="line">        typeDescription = (char *)method_getTypeEncoding(method);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    IMP originalImp = class_respondsToSelector(cls, selector) ? class_getMethodImplementation(cls, selector) : NULL;</div><div class="line">    </div><div class="line">    IMP msgForwardIMP = _objc_msgForward; // 用_objc_msgForward函数指针代替imp，_objc_msgForward是用于消息转发的。也就是跳转拦截调用</div><div class="line">    #if !defined(__arm64__)</div><div class="line">        if (typeDescription[0] == &apos;&#123;&apos;) &#123;</div><div class="line">            //In some cases that returns struct, we should use the &apos;_stret&apos; API:</div><div class="line">            //http://sealiesoftware.com/blog/archive/2008/10/30/objc_explain_objc_msgSend_stret.html</div><div class="line">            //NSMethodSignature knows the detail but has no API to return, we can only get the info from debugDescription.</div><div class="line">            NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:typeDescription];</div><div class="line">            if ([methodSignature.debugDescription rangeOfString:@&quot;is special struct return? YES&quot;].location != NSNotFound) &#123;</div><div class="line">                msgForwardIMP = (IMP)_objc_msgForward_stret;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    #endif</div><div class="line"></div><div class="line">    if (class_getMethodImplementation(cls, @selector(forwardInvocation:)) != (IMP)JPForwardInvocation) &#123;</div><div class="line">        // 如果不是本地的forwardInvocation实现，新增JPForwardInvocation方法到类中，原来的forwardInvocation方法实现更改为ORIGforwardInvocation下。</div><div class="line">        IMP originalForwardImp = class_replaceMethod(cls, @selector(forwardInvocation:), (IMP)JPForwardInvocation, &quot;v@:@&quot;);</div><div class="line">        if (originalForwardImp) &#123;</div><div class="line">            class_addMethod(cls, @selector(ORIGforwardInvocation:), originalForwardImp, &quot;v@:@&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [cls jp_fixMethodSignature]; // fix bug</div><div class="line">    if (class_respondsToSelector(cls, selector)) &#123; // 类中含有这个方法，将原来的方法新增一个ORIG前缀，新增到类中, ORIG方法的实现是原方法</div><div class="line">        NSString *originalSelectorName = [NSString stringWithFormat:@&quot;ORIG%@&quot;, selectorName]; // ORIGFunc</div><div class="line">        SEL originalSelector = NSSelectorFromString(originalSelectorName);</div><div class="line">        if(!class_respondsToSelector(cls, originalSelector)) &#123;</div><div class="line">            class_addMethod(cls, originalSelector, originalImp, typeDescription);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName]; // _JPFunc</div><div class="line">    </div><div class="line">    _initJPOverideMethods(cls); // 初始化_JSOverideMethods</div><div class="line">    _JSOverideMethods[cls][JPSelectorName] = function;</div><div class="line">    // 将方法名添加_JP前缀作为key，将js代码作为value存入_JSOverideMethods中</div><div class="line">    // 存储JS代码: _JSOverideMethods字段： &#123;类 = &#123;&quot;_JPFunc&quot; = &quot;function实现&quot;&#125;&#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    // Replace the original selector at last, preventing threading issus when</div><div class="line">    // the selector get called during the execution of `overrideMethod`</div><div class="line">    class_replaceMethod(cls, selector, msgForwardIMP, typeDescription); // 将方法替换为_objc_msgForward，调用直接跳转拦截调用</div></pre></td></tr></table></figure>
<p>方法逻辑：</p>
<ul>
<li>如果没有传typeDescription，就是类中有这个方法，那么可以直接通过方法获取typeDescription</li>
<li>获取方法是原来实现originalImp，以及设置拦截调用IMP：_objc_msgForward</li>
<li>如果不是本地的forwardInvocation实现，新增JPForwardInvocation方法到类中，原来的forwardInvocation方法实现更改为ORIGforwardInvocation下</li>
<li>如果类中含有这个方法，将原来的方法新增一个ORIG前缀，新增到类中, ORIG方法的实现是原方法</li>
<li>保存一份方法：将方法名新增_JP前缀，添加到全局对象_JSOverideMethods字典中：{类 = {“_JPFunc” = “function实现”}}</li>
<li>执行方法替换，将当前方法selector的实现替换成msgForwardIMP，也就是肯定会跳转拦截调用，在拦截调用中捕获参数信息。</li>
</ul>
<hr>
<p>执行到这里，我们看到JS里面保存了一份方法的实现，OC里面也存了一份。<br>JS中：_ocCls<br>OC中：_JSOverideMethods</p>
<hr>
<h3 id="再次触发崩溃按钮，跟踪一下代码"><a href="#再次触发崩溃按钮，跟踪一下代码" class="headerlink" title="再次触发崩溃按钮，跟踪一下代码"></a>再次触发崩溃按钮，跟踪一下代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (IBAction)btnClick:(id)sender</div></pre></td></tr></table></figure>
<p>根据上面的解析，应该会走拦截调用方法，而我们已经将拦截调用的方法实现IMP替换成JPForwardInvocation()方法。接下来看一下这个方法。</p>
<h4 id="拦截调用方法JPForwardInvocation"><a href="#拦截调用方法JPForwardInvocation" class="headerlink" title="拦截调用方法JPForwardInvocation()"></a>拦截调用方法JPForwardInvocation()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div></pre></td><td class="code"><pre><div class="line">static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation)</div><div class="line">&#123;</div><div class="line">    BOOL deallocFlag = NO;</div><div class="line">    id slf = assignSlf;</div><div class="line">    NSMethodSignature *methodSignature = [invocation methodSignature]; // 获取参数，返回值相关信息</div><div class="line">    NSInteger numberOfArguments = [methodSignature numberOfArguments]; // 参数个数</div><div class="line">    </div><div class="line">    NSString *selectorName = NSStringFromSelector(invocation.selector); // 获取方法名</div><div class="line">    NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName]; // _JPFunc</div><div class="line">    JSValue *jsFunc = getJSFunctionInObjectHierachy(slf, JPSelectorName); // 获取之前存在 _JSOverideMethods字典中对应JS方法的实现</div><div class="line">    if (!jsFunc) &#123; // 如果没有这个方法实现，那么跳转系统自己的拦截调用方法，或者是工程中有实现的拦截调用方法，但是问题是如果有方法实现，那么工程中的拦截调用如果重写了，那么就不会执行ForwardInvocation方法了！！！！</div><div class="line">        JPExecuteORIGForwardInvocation(slf, selector, invocation);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSMutableArray *argList = [[NSMutableArray alloc] init]; // 存类型数组</div><div class="line">    if ([slf class] == slf) &#123; // slf 是 类 类型</div><div class="line">        [argList addObject:[JSValue valueWithObject:@&#123;@&quot;__clsName&quot;: NSStringFromClass([slf class])&#125; inContext:_context]];</div><div class="line">    &#125; else if ([selectorName isEqualToString:@&quot;dealloc&quot;]) &#123; // selectorName是dealloc方法</div><div class="line">        [argList addObject:[JPBoxing boxAssignObj:slf]];</div><div class="line">        deallocFlag = YES;</div><div class="line">    &#125; else &#123; // 正常的对象类型</div><div class="line">        [argList addObject:[JPBoxing boxWeakObj:slf]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 对参数进行解析，从i=2开始，就是对参数解析。  methodSignature: 返回值， 各个参数</div><div class="line">    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) &#123;</div><div class="line">        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];</div><div class="line">        switch(argumentType[0] == &apos;r&apos; ? argumentType[1] : argumentType[0]) &#123;</div><div class="line">        </div><div class="line">            ...</div><div class="line">            </div><div class="line">            case &apos;@&apos;: &#123;  // 对象类型</div><div class="line">                __unsafe_unretained id arg;</div><div class="line">                [invocation getArgument:&amp;arg atIndex:i]; // 获取当前对象，例子中是UIButton类型 &lt;UIButton: 0x7faa08704240; frame = (59 220; 46 30); opaque = NO; autoresize = RM+BM; layer = &lt;CALayer: 0x6080000385e0&gt;&gt;</div><div class="line">                if ([arg isKindOfClass:NSClassFromString(@&quot;NSBlock&quot;)]) &#123;</div><div class="line">                    [argList addObject:(arg ? [arg copy]: _nilObj)]; // NSBlock 对象需要执行copy，猜测是防止释放吧</div><div class="line">                &#125; else &#123;</div><div class="line">                    [argList addObject:(arg ? arg: _nilObj)]; // 添加到argList</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">           </div><div class="line">            ...</div><div class="line">            </div><div class="line">            default: &#123;</div><div class="line">                NSLog(@&quot;error type %s&quot;, argumentType);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_currInvokeSuperClsName[selectorName]) &#123; // 处理父类方法</div><div class="line">        Class cls = NSClassFromString(_currInvokeSuperClsName[selectorName]);</div><div class="line">        NSString *tmpSelectorName = [[selectorName stringByReplacingOccurrencesOfString:@&quot;_JPSUPER_&quot; withString:@&quot;_JP&quot;] stringByReplacingOccurrencesOfString:@&quot;SUPER_&quot; withString:@&quot;_JP&quot;];</div><div class="line">        if (!_JSOverideMethods[cls][tmpSelectorName]) &#123;</div><div class="line">            NSString *ORIGSelectorName = [selectorName stringByReplacingOccurrencesOfString:@&quot;SUPER_&quot; withString:@&quot;ORIG&quot;];</div><div class="line">            [argList removeObjectAtIndex:0];</div><div class="line">            id retObj = callSelector(_currInvokeSuperClsName[selectorName], ORIGSelectorName, [JSValue valueWithObject:argList inContext:_context], [JSValue valueWithObject:@&#123;@&quot;__obj&quot;: slf, @&quot;__realClsName&quot;: @&quot;&quot;&#125; inContext:_context], NO);</div><div class="line">            id __autoreleasing ret = formatJSToOC([JSValue valueWithObject:retObj inContext:_context]);</div><div class="line">            [invocation setReturnValue:&amp;ret];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    NSArray *params = _formatOCToJSList(argList); // 转换成JS类型的对象，格式：[&#123;&quot;__clsName&quot;: 类名, &quot;__obj&quot;: 对象&#125;, ...]</div><div class="line">    char returnType[255];</div><div class="line">    strcpy(returnType, [methodSignature methodReturnType]); // 获取返回值类型 此处v:void</div><div class="line">    </div><div class="line">    // Restore the return type</div><div class="line">    if (strcmp(returnType, @encode(JPDouble)) == 0) &#123; // 根据JS类型转换double</div><div class="line">        strcpy(returnType, @encode(double));</div><div class="line">    &#125;</div><div class="line">    if (strcmp(returnType, @encode(JPFloat)) == 0) &#123; // 根据JS类型转换float</div><div class="line">        strcpy(returnType, @encode(float));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 处理返回值类型</div><div class="line">    switch (returnType[0] == &apos;r&apos; ? returnType[1] : returnType[0]) &#123;</div><div class="line">       </div><div class="line">        ... // 此处省略占篇幅的宏定义</div><div class="line"></div><div class="line">        case &apos;v&apos;: &#123;</div><div class="line">//            JP_FWD_RET_CALL_JS // 由于用宏不好调试，替换成下面代码</div><div class="line">            </div><div class="line">            JSValue *jsval;</div><div class="line">            [_JSMethodForwardCallLock lock]; // 加锁</div><div class="line">            jsval = [jsFunc callWithArguments:params]; // 执行js方法</div><div class="line">            [_JSMethodForwardCallLock unlock]; // 解锁</div><div class="line">            while (![jsval isNull] &amp;&amp; ![jsval isUndefined] &amp;&amp; [jsval hasProperty:@&quot;__isPerformInOC&quot;]) &#123;</div><div class="line">                NSArray *args = nil;</div><div class="line">                JSValue *cb = jsval[@&quot;cb&quot;];</div><div class="line">                if ([jsval hasProperty:@&quot;sel&quot;]) &#123;</div><div class="line">                    id callRet = callSelector(![jsval[@&quot;clsName&quot;] isUndefined] ? [jsval[@&quot;clsName&quot;] toString] : nil, [jsval[@&quot;sel&quot;] toString], jsval[@&quot;args&quot;], ![jsval[@&quot;obj&quot;] isUndefined] ? jsval[@&quot;obj&quot;] : nil, NO);</div><div class="line">                    args = @[[_context[@&quot;_formatOCToJS&quot;] callWithArguments:callRet ? @[callRet] : _formatOCToJSList(@[_nilObj])]];</div><div class="line">                &#125;</div><div class="line">                [_JSMethodForwardCallLock lock];</div><div class="line">                jsval = [cb callWithArguments:args];</div><div class="line">                [_JSMethodForwardCallLock unlock];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        case &apos;&#123;&apos;: &#123;</div><div class="line">            NSString *typeString = extractStructName([NSString stringWithUTF8String:returnType]);</div><div class="line">            #define JP_FWD_RET_STRUCT(_type, _funcSuffix) \</div><div class="line">            if ([typeString rangeOfString:@#_type].location != NSNotFound) &#123;    \</div><div class="line">                JP_FWD_RET_CALL_JS \</div><div class="line">                _type ret = [jsval _funcSuffix]; \</div><div class="line">                [invocation setReturnValue:&amp;ret];\</div><div class="line">                break;  \</div><div class="line">            &#125;</div><div class="line">            JP_FWD_RET_STRUCT(CGRect, toRect)</div><div class="line">            JP_FWD_RET_STRUCT(CGPoint, toPoint)</div><div class="line">            JP_FWD_RET_STRUCT(CGSize, toSize)</div><div class="line">            JP_FWD_RET_STRUCT(NSRange, toRange)</div><div class="line">            </div><div class="line">            @synchronized (_context) &#123;</div><div class="line">                NSDictionary *structDefine = _registeredStruct[typeString];</div><div class="line">                if (structDefine) &#123;</div><div class="line">                    size_t size = sizeOfStructTypes(structDefine[@&quot;types&quot;]);</div><div class="line">                    JP_FWD_RET_CALL_JS</div><div class="line">                    void *ret = malloc(size);</div><div class="line">                    NSDictionary *dict = formatJSToOC(jsval);</div><div class="line">                    getStructDataWithDict(ret, dict, structDefine);</div><div class="line">                    [invocation setReturnValue:ret];</div><div class="line">                    free(ret);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">        default: &#123;</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (_pointersToRelease) &#123;</div><div class="line">        for (NSValue *val in _pointersToRelease) &#123;</div><div class="line">            void *pointer = NULL;</div><div class="line">            [val getValue:&amp;pointer];</div><div class="line">            CFRelease(pointer);</div><div class="line">        &#125;</div><div class="line">        _pointersToRelease = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (deallocFlag) &#123;</div><div class="line">        slf = nil;</div><div class="line">        Class instClass = object_getClass(assignSlf);</div><div class="line">        Method deallocMethod = class_getInstanceMethod(instClass, NSSelectorFromString(@&quot;ORIGdealloc&quot;));</div><div class="line">        void (*originalDealloc)(__unsafe_unretained id, SEL) = (__typeof__(originalDealloc))method_getImplementation(deallocMethod);</div><div class="line">        originalDealloc(assignSlf, NSSelectorFromString(@&quot;dealloc&quot;));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中有些…是省略了部分代码</p>
<p>方法逻辑：</p>
<ul>
<li><p>获取当前替换方法调用方法的参数，拦截调用的主要作用在于此。否则直接使用Method Swizzle即可，何必再走拦截调用呢。</p>
</li>
<li><p>通过在方法中添加_JP前缀，获取之前存在_JSOverideMethods中对应的JS方法实现，如果为空直接调用原来的拦截调用方法。</p>
</li>
<li><p>将类，对象，各个参数转换为OC对象存入argList数组中</p>
</li>
<li><p>处理父类方法</p>
</li>
<li><p>处理返回值</p>
</li>
<li><p>根据返回值类型，调用JS代码[jsFunc callWithArguments:params]，也就是此处会调用之前封装过的JS代码，执行JS中的btnClick:方法，这个地方比较绕。封装过的JS代码不是很理解。JS功底比较好的同学可以指教一下。</p>
</li>
</ul>
<h4 id="执行我们main-js里面btnClick-方法"><a href="#执行我们main-js里面btnClick-方法" class="headerlink" title="执行我们main.js里面btnClick:方法"></a>执行我们main.js里面btnClick:方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">btnClick: function(sender) &#123;</div><div class="line">var arrTest = [&quot;arrTest&quot;];</div><div class="line">var strCrash = arrTest[0];</div><div class="line"></div><div class="line">var alert = UIAlertView.alloc().initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles(&quot;JSPatchAmend&quot;, &quot;Success&quot;, null, &quot;Yes&quot;, null, null);</div><div class="line">    alert.show();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实已经替换成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">var arrTest = [&quot;arrTest&quot;];</div><div class="line">var strCrash = arrTest[0];</div><div class="line"></div><div class="line">var alert = UIAlertView.__c(&quot;alloc&quot;)().__c(&quot;initWithTitle_message_delegate_cancelButtonTitle_otherButtonTitles&quot;)(&quot;JSPatchAmend&quot;, &quot;Success&quot;, null, &quot;Yes&quot;, null, null);</div><div class="line">    alert.__c(&quot;show&quot;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们把crash代码替换掉，并执行了一个原生的Alert，这里统一的方法调用都是调用__c()</p>
<h4 id="C-方法的调用"><a href="#C-方法的调用" class="headerlink" title="__C()方法的调用"></a>__C()方法的调用</h4><p>疑问：JS如何去调用__c()方法呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (var method in _customMethods) &#123; // __c</div><div class="line">  if (_customMethods.hasOwnProperty(method)) &#123;</div><div class="line">    // Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</div><div class="line">    // Object.prototype 属性表示 Object 的原型对象。</div><div class="line">    Object.defineProperty(Object.prototype, method, &#123;value: _customMethods[method], configurable:false, enumerable: false&#125;)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面for循环我们可以看到，这里将_customMethods字典里面的key都会设置成这个对象的属性，由于这段代码没有调试出来，所以暂时理解为所有对象都添加<strong>c、super、performSelectorInOC、performSelector方法，而</strong>c方法实现是一个匿名函数, 返回值又是一个匿名函数</p>
<p>下面为_customMethods字典的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">var _customMethods = &#123; // 字典对象，存 __c: function</div><div class="line">  __c: function(methodName) &#123;</div><div class="line">    var slf = this</div><div class="line"></div><div class="line">    if (slf instanceof Boolean) &#123;</div><div class="line">      return function() &#123;</div><div class="line">        return false</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    if (slf[methodName]) &#123;</div><div class="line">      return slf[methodName].bind(slf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!slf.__obj &amp;&amp; !slf.__clsName) &#123; // 未定义抛出异常</div><div class="line">      throw new Error(slf + &apos;.&apos; + methodName + &apos; is undefined&apos;)</div><div class="line">    &#125;</div><div class="line">    if (slf.__isSuper &amp;&amp; slf.__clsName) &#123; // 如果是调用父类方法</div><div class="line">        slf.__clsName = _OC_superClsName(slf.__obj.__realClsName ? slf.__obj.__realClsName: slf.__clsName); // 通过调用oc的[cls superclass] 方法获取父类的名字</div><div class="line">    &#125;</div><div class="line">    var clsName = slf.__clsName</div><div class="line">    if (clsName &amp;&amp; _ocCls[clsName]) &#123; // 有缓存，返回缓存的方法</div><div class="line">      var methodType = slf.__obj ? &apos;instMethods&apos;: &apos;clsMethods&apos;  // 通过__obj判断是实例方法还是类方法</div><div class="line">      if (_ocCls[clsName][methodType][methodName]) &#123;</div><div class="line">        slf.__isSuper = 0;</div><div class="line">        return _ocCls[clsName][methodType][methodName].bind(slf) // // 返回的是之前缓存的方法</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return function()&#123;</div><div class="line">      var args = Array.prototype.slice.call(arguments) // 转换成数组， arguments 怎么获取的？？</div><div class="line">      return _methodFunc(slf.__obj, slf.__clsName, methodName, args, slf.__isSuper) // 返回方法调用的结果</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  super: function() &#123;</div><div class="line">    var slf = this</div><div class="line">    if (slf.__obj) &#123;</div><div class="line">      slf.__obj.__realClsName = slf.__realClsName;</div><div class="line">    &#125;</div><div class="line">    return &#123;__obj: slf.__obj, __clsName: slf.__clsName, __isSuper: 1&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  performSelectorInOC: function() &#123;</div><div class="line">    var slf = this</div><div class="line">    var args = Array.prototype.slice.call(arguments)</div><div class="line">    return &#123;__isPerformInOC:1, obj:slf.__obj, clsName:slf.__clsName, sel: args[0], args: args[1], cb: args[2]&#125;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  performSelector: function() &#123;</div><div class="line">    var slf = this</div><div class="line">    var args = Array.prototype.slice.call(arguments)</div><div class="line">    return _methodFunc(slf.__obj, slf.__clsName, args[0], args.splice(1), slf.__isSuper, true)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>方法调用例如：UIAlertView.<strong>c(“fucName”)(“param”)<br>第一个调用为方法名:(“fucName”)，参数为fucName，执行的是以</strong>c 为key的匿名函数，此时获取的返回值是另一个匿名函数，再执行(“param”)则是调用的返回值的匿名函数，参数为param。</p>
</blockquote>
<p>解析一下__c()匿名函数的逻辑：</p>
<ul>
<li><p>做了异常处理</p>
</li>
<li><p>处理父类方法</p>
</li>
<li><p>如果这个JS方法在缓存_ocCls字典中，那么直接返回</p>
</li>
<li><p>如果没有缓存，那么调用_methodFunc方法</p>
</li>
</ul>
<p>下面看下_methodFunc方法</p>
<h4 id="methodFunc-方法"><a href="#methodFunc-方法" class="headerlink" title="_methodFunc()方法"></a>_methodFunc()方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var _methodFunc = function(instance, clsName, methodName, args, isSuper, isPerformSelector) &#123;</div><div class="line">  var selectorName = methodName</div><div class="line">  if (!isPerformSelector) &#123; // 如果不是performselector，用正则对selectorName进行字符替换：__ 替换 -，- 替换 _，有&apos;:&apos;, 在最后添加上&apos;:&apos;</div><div class="line">    methodName = methodName.replace(/__/g, &quot;-&quot;) // __ 替换 -</div><div class="line">    selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;) // - 替换 _</div><div class="line">    var marchArr = selectorName.match(/:/g) // 有&apos;:&apos;, 在最后添加上&apos;:&apos;</div><div class="line">    var numOfArgs = marchArr ? marchArr.length : 0</div><div class="line">    if (args.length &gt; numOfArgs) &#123;</div><div class="line">      selectorName += &quot;:&quot;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  var ret = instance ? _OC_callI(instance, selectorName, args, isSuper):</div><div class="line">                       _OC_callC(clsName, selectorName, args) // 调用oc的生成方法：实例方法还是类方法</div><div class="line">  return _formatOCToJS(ret)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作用：通过调用OC方法，实现方法调用，并返回调用结果</p>
<p>方法逻辑：</p>
<ul>
<li>首先执行方法替换：<br>_<em> 替换 -，- 替换 </em>，有’:’, 在最后添加上’:’</li>
</ul>
<ul>
<li><p>根据是否是实例对象来调用OC的方法_OC_callI（实例方法），_OC_callC（类方法）</p>
</li>
<li><p>获取返回值，并格式转换为JS类型 </p>
</li>
</ul>
<p>下面看下OC的方法调用_OC_callI，_OC_callC</p>
<h4 id="OC调用方法执行-OC-callI-OC-callC"><a href="#OC调用方法执行-OC-callI-OC-callC" class="headerlink" title="OC调用方法执行_OC_callI/_OC_callC"></a>OC调用方法执行_OC_callI/_OC_callC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">context[@&quot;_OC_callI&quot;] = ^id(JSValue *obj, NSString *selectorName, JSValue *arguments, BOOL isSuper) &#123; // call instace method</div><div class="line">    return callSelector(nil, selectorName, arguments, obj, isSuper); // 返回值类型： &#123;&quot;__clsName&quot;: 类名; &quot;__obj&quot;: 对象&#125;</div><div class="line">&#125;;</div><div class="line">context[@&quot;_OC_callC&quot;] = ^id(NSString *className, NSString *selectorName, JSValue *arguments) &#123; // call class method</div><div class="line">    return callSelector(className, selectorName, arguments, nil, NO);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，这两个方法都是调用的callSelector（）方法。</p>
<p>下面看一下callSelector方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div></pre></td><td class="code"><pre><div class="line">static id callSelector(NSString *className, NSString *selectorName, JSValue *arguments, JSValue *instance, BOOL isSuper)</div><div class="line">&#123;</div><div class="line">    NSString *realClsName = [[instance valueForProperty:@&quot;__realClsName&quot;] toString];</div><div class="line">   </div><div class="line">    if (instance) &#123;</div><div class="line">        instance = formatJSToOC(instance);</div><div class="line">        if (class_isMetaClass(object_getClass(instance))) &#123; // 是元类</div><div class="line">            className = NSStringFromClass((Class)instance);</div><div class="line">            instance = nil;</div><div class="line">        &#125; else if (!instance || instance == _nilObj || [instance isKindOfClass:[JPBoxing class]]) &#123;</div><div class="line">            return @&#123;@&quot;__isNil&quot;: @(YES)&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    id argumentsObj = formatJSToOC(arguments); // 转换成oc对象数组</div><div class="line">    </div><div class="line">    if (instance &amp;&amp; [selectorName isEqualToString:@&quot;toJS&quot;]) &#123;</div><div class="line">        if ([instance isKindOfClass:[NSString class]] || [instance isKindOfClass:[NSDictionary class]] || [instance isKindOfClass:[NSArray class]] || [instance isKindOfClass:[NSDate class]]) &#123;</div><div class="line">            return _unboxOCObjectToJS(instance);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Class cls = instance ? [instance class] : NSClassFromString(className); // 传的是类或者对象</div><div class="line">    SEL selector = NSSelectorFromString(selectorName);</div><div class="line">    </div><div class="line">    NSString *superClassName = nil;</div><div class="line">    if (isSuper) &#123; // 是否是父类的方法</div><div class="line">        NSString *superSelectorName = [NSString stringWithFormat:@&quot;SUPER_%@&quot;, selectorName];</div><div class="line">        SEL superSelector = NSSelectorFromString(superSelectorName);</div><div class="line">        </div><div class="line">        Class superCls;</div><div class="line">        if (realClsName.length) &#123;</div><div class="line">            Class defineClass = NSClassFromString(realClsName);</div><div class="line">            superCls = defineClass ? [defineClass superclass] : [cls superclass];</div><div class="line">        &#125; else &#123;</div><div class="line">            superCls = [cls superclass];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        Method superMethod = class_getInstanceMethod(superCls, selector);</div><div class="line">        IMP superIMP = method_getImplementation(superMethod);</div><div class="line">        </div><div class="line">        class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod));</div><div class="line">        </div><div class="line">        NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName];</div><div class="line">        JSValue *overideFunction = _JSOverideMethods[superCls][JPSelectorName];</div><div class="line">        if (overideFunction) &#123;</div><div class="line">            overrideMethod(cls, superSelectorName, overideFunction, NO, NULL);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        selector = superSelector;</div><div class="line">        superClassName = NSStringFromClass(superCls);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    NSMutableArray *_markArray;</div><div class="line">    </div><div class="line">    NSInvocation *invocation;</div><div class="line">    NSMethodSignature *methodSignature;</div><div class="line">    if (!_JSMethodSignatureCache) &#123;</div><div class="line">        _JSMethodSignatureCache = [[NSMutableDictionary alloc]init];</div><div class="line">    &#125;</div><div class="line">    if (instance) &#123; // 实例方法</div><div class="line">        [_JSMethodSignatureLock lock];</div><div class="line">        if (!_JSMethodSignatureCache[cls]) &#123;</div><div class="line">            _JSMethodSignatureCache[(id&lt;NSCopying&gt;)cls] = [[NSMutableDictionary alloc]init]; // 初始化key</div><div class="line">        &#125;</div><div class="line">        methodSignature = _JSMethodSignatureCache[cls][selectorName]; // 新增缓存机制，提升效率</div><div class="line">        if (!methodSignature) &#123;</div><div class="line">            methodSignature = [cls instanceMethodSignatureForSelector:selector]; //</div><div class="line">            methodSignature = fixSignature(methodSignature);</div><div class="line">            _JSMethodSignatureCache[cls][selectorName] = methodSignature;</div><div class="line">        &#125;</div><div class="line">        [_JSMethodSignatureLock unlock];</div><div class="line">        if (!methodSignature) &#123;</div><div class="line">            _exceptionBlock([NSString stringWithFormat:@&quot;unrecognized selector %@ for instance %@&quot;, selectorName, instance]);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        invocation = [NSInvocation invocationWithMethodSignature:methodSignature];</div><div class="line">        [invocation setTarget:instance];</div><div class="line">    &#125; else &#123; // 类方法</div><div class="line">        methodSignature = [cls methodSignatureForSelector:selector]; //</div><div class="line">        methodSignature = fixSignature(methodSignature); // fix bug</div><div class="line">        if (!methodSignature) &#123;</div><div class="line">            _exceptionBlock([NSString stringWithFormat:@&quot;unrecognized selector %@ for class %@&quot;, selectorName, className]);</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">        invocation= [NSInvocation invocationWithMethodSignature:methodSignature];</div><div class="line">        [invocation setTarget:cls];</div><div class="line">    &#125;</div><div class="line">    [invocation setSelector:selector];</div><div class="line">    </div><div class="line">    NSUInteger numberOfArguments = methodSignature.numberOfArguments;</div><div class="line">    NSInteger inputArguments = [(NSArray *)argumentsObj count];</div><div class="line">    if (inputArguments &gt; numberOfArguments - 2) &#123;</div><div class="line">        // calling variable argument method, only support parameter type `id` and return type `id`</div><div class="line">        id sender = instance != nil ? instance : cls;</div><div class="line">        id result = invokeVariableParameterMethod(argumentsObj, methodSignature, sender, selector); // 调用objc_msgSend方法</div><div class="line">        return formatOCToJS(result);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    for (NSUInteger i = 2; i &lt; numberOfArguments; i++) &#123; // 参数的处理，注意从第二个argument开始：0是方法名，1是&apos;:&apos;</div><div class="line">        const char *argumentType = [methodSignature getArgumentTypeAtIndex:i];</div><div class="line">        id valObj = argumentsObj[i-2];</div><div class="line">        switch (argumentType[0] == &apos;r&apos; ? argumentType[1] : argumentType[0]) &#123;</div><div class="line">                </div><div class="line">                ...</div><div class="line">                </div><div class="line">            case &apos;#&apos;: &#123;</div><div class="line">                if ([valObj isKindOfClass:[JPBoxing class]]) &#123;</div><div class="line">                    Class value = [((JPBoxing *)valObj) unboxClass];</div><div class="line">                    [invocation setArgument:&amp;value atIndex:i];</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            default: &#123;</div><div class="line">                if (valObj == _nullObj) &#123;</div><div class="line">                    valObj = [NSNull null];</div><div class="line">                    [invocation setArgument:&amp;valObj atIndex:i];</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (valObj == _nilObj ||</div><div class="line">                    ([valObj isKindOfClass:[NSNumber class]] &amp;&amp; strcmp([valObj objCType], &quot;c&quot;) == 0 &amp;&amp; ![valObj boolValue])) &#123;</div><div class="line">                    valObj = nil;</div><div class="line">                    [invocation setArgument:&amp;valObj atIndex:i];</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if ([(JSValue *)arguments[i-2] hasProperty:@&quot;__isBlock&quot;]) &#123;</div><div class="line">                    JSValue *blkJSVal = arguments[i-2];</div><div class="line">                    Class JPBlockClass = NSClassFromString(@&quot;JPBlock&quot;);</div><div class="line">                    if (JPBlockClass &amp;&amp; ![blkJSVal[@&quot;blockObj&quot;] isUndefined]) &#123;</div><div class="line">                        __autoreleasing id cb = [JPBlockClass performSelector:@selector(blockWithBlockObj:) withObject:[blkJSVal[@&quot;blockObj&quot;] toObject]];</div><div class="line">                        [invocation setArgument:&amp;cb atIndex:i];</div><div class="line">                    &#125; else &#123;</div><div class="line">                        __autoreleasing id cb = genCallbackBlock(arguments[i-2]);</div><div class="line">                        [invocation setArgument:&amp;cb atIndex:i];</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    [invocation setArgument:&amp;valObj atIndex:i];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (superClassName) _currInvokeSuperClsName[selectorName] = superClassName;</div><div class="line">    [invocation invoke]; // 方法调用</div><div class="line">    if (superClassName) [_currInvokeSuperClsName removeObjectForKey:selectorName]; // 方法调用完又移除了缓存的父类方法名</div><div class="line">    if ([_markArray count] &gt; 0) &#123;</div><div class="line">        for (JPBoxing *box in _markArray) &#123;</div><div class="line">            void *pointer = [box unboxPointer];</div><div class="line">            id obj = *((__unsafe_unretained id *)pointer);</div><div class="line">            if (obj) &#123;</div><div class="line">                @synchronized(_TMPMemoryPool) &#123;</div><div class="line">                    [_TMPMemoryPool setObject:obj forKey:[NSNumber numberWithInteger:[(NSObject*)obj hash]]];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    char returnType[255];</div><div class="line">    strcpy(returnType, [methodSignature methodReturnType]);</div><div class="line">    </div><div class="line">    // Restore the return type</div><div class="line">    if (strcmp(returnType, @encode(JPDouble)) == 0) &#123; // 如果是JPDouble结构体，返回double的编码d</div><div class="line">        strcpy(returnType, @encode(double));</div><div class="line">    &#125;</div><div class="line">    if (strcmp(returnType, @encode(JPFloat)) == 0) &#123;</div><div class="line">        strcpy(returnType, @encode(float));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id returnValue;</div><div class="line">    if (strncmp(returnType, &quot;v&quot;, 1) != 0) &#123; // 不是void类型</div><div class="line">        if (strncmp(returnType, &quot;@&quot;, 1) == 0) &#123; // id 类型</div><div class="line">            void *result;</div><div class="line">            [invocation getReturnValue:&amp;result]; // 获取返回值result</div><div class="line">            </div><div class="line">            //For performance, ignore the other methods prefix with alloc/new/copy/mutableCopy</div><div class="line">            if ([selectorName isEqualToString:@&quot;alloc&quot;] || [selectorName isEqualToString:@&quot;new&quot;] ||</div><div class="line">                [selectorName isEqualToString:@&quot;copy&quot;] || [selectorName isEqualToString:@&quot;mutableCopy&quot;]) &#123;</div><div class="line">                returnValue = (__bridge_transfer id)result; // 这几个参数alloc/new/copy/mutableCopy会生成新对象，并且引用计数是1，需要我们持有，否则会提前释放？释放时机在哪？</div><div class="line">            &#125; else &#123; // 一般类型的返回值：id</div><div class="line">                returnValue = (__bridge id)result;</div><div class="line">            &#125;</div><div class="line">            return formatOCToJS(returnValue);</div><div class="line">            </div><div class="line">        &#125; else &#123;</div><div class="line">            switch (returnType[0] == &apos;r&apos; ? returnType[1] : returnType[0]) &#123;</div><div class="line">                    </div><div class="line">                ...</div><div class="line">                </div><div class="line">                case &apos;#&apos;: &#123;</div><div class="line">                    Class result;</div><div class="line">                    [invocation getReturnValue:&amp;result];</div><div class="line">                    returnValue = formatOCToJS([JPBoxing boxClass:result]);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            return returnValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于比较长，我们删掉了部分代码。</p>
<p>方法逻辑：</p>
<ul>
<li><p>这里根据调用对象的类型来进行判断是否调用实例方法，还是类方法。并对参数进行转换成OC数组</p>
</li>
<li><p>处理父类方法</p>
</li>
<li><p>使用NSInvocation来执行方法调用，注意，类方法使用[cls methodSignatureForSelector:selector]，而实例方法使用 [cls instanceMethodSignatureForSelector:selector]来初始化methodSignature。这里使用_JSMethodSignatureCache缓存methodSignature内容，提升方法调用效率</p>
</li>
<li><p>处理返回值，这里逻辑挺多的，核心就是调用Runtime的objc_msgSend方法，对于参数的转换，这里不做讨论。</p>
</li>
</ul>
<hr>
<p>至此，大体逻辑我们已经理清楚了。里面还有很多细节都写的挺好，还是值得去研究一下。</p>
<hr>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
<p>typeDescription类型的含义可以参考苹果文档：<br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1</a></p>
<p>参考作者文档：<br><a href="https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3" target="_blank" rel="external">https://github.com/bang590/JSPatch/wiki/JSPatch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[最新iOS自动打包Jenkins集成指南]]></title>
      <url>http://semyonxu.com/2017/06/13/%E6%9C%80%E6%96%B0iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85Jenkins%E9%9B%86%E6%88%90%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h1 id="Jenkins部署"><a href="#Jenkins部署" class="headerlink" title="Jenkins部署"></a>Jenkins部署</h1><p>Jenkins 搭建过程本文不在讨论，很多文章都已经讲得很详细。本文主要讲一下，部署过程中可能遇到的坑，以及解决方法。</p>
<p>搭建详细过程参考：<br><a href="http://www.cocoachina.com/ios/20160804/17281.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20160804/17281.html</a></p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>对于iOS开发来说，Jenkins各种插件支持，也是很贴心，但是没有办法在非Mac机器上使用xcode打包命令，也就是必须准备一台Mac，才能集成。</p>
<a id="more"></a>
<h2 id="开始搭建工程"><a href="#开始搭建工程" class="headerlink" title="开始搭建工程"></a>开始搭建工程</h2><p>我们可以通过新建，输入工程的名字，来新建一个工程。</p>
<p>在这里，如果安卓已经搭建了一个非Mac的服务器，而我们又使用不了，那么我们可以通过添加结点的方式，来链接一个专门打包的Mac。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">系统管理-&gt;管理结点-&gt;新建结点</div></pre></td></tr></table></figure>
<p>这里可以参考这篇文章<br><a href="http://www.qingpingshan.com/pc/fwq/128432.html" target="_blank" rel="external">http://www.qingpingshan.com/pc/fwq/128432.html</a></p>
<p>中间如果遇到：<br>执行命令的slave.jar的时候报错，那么升级一下java版本到java8即可解决。</p>
<p>可以去官网下载，JDK。<br>也可以使用brew命令下载：<br>终端输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew cask install java</div></pre></td></tr></table></figure>
<p>链接成功，就可以了。</p>
<p>需要在工程中配置当前电脑：<br>源码管理选项下找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Restrict where this project can be run</div><div class="line">Label Expression &apos;填写配置好的Mac名字&apos;</div></pre></td></tr></table></figure>
<h2 id="打包命令"><a href="#打包命令" class="headerlink" title="打包命令"></a>打包命令</h2><p>Jenkins支持使用Xcode插件（Xcode integration）打包，但是不方便切换证书，所以推荐使用命令的方式。</p>
<p>配置好各种证书，profile之后，使用命令打包。注意xcode8之后的命令变化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcodebuild  -exportArchive -archivePath /Users/xxx/Documents/work/xxx -exportPath /Users/xxx/Desktop/xxx/xxx.ipa -exportOptionsPlist xxx/IPA.plist</div></pre></td></tr></table></figure>
<p>此处打包信息需要在IPA.plist 中填写。对于plist内容格式，我们可以通过以下命令查看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcodebuild --help</div></pre></td></tr></table></figure>
<p>这里注意贴两个主要的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">method : String</div><div class="line"></div><div class="line">	Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, and developer-id. The list of options varies based on the type of archive. Defaults to development.</div><div class="line"></div><div class="line">teamID : String</div><div class="line"></div><div class="line">	The Developer Portal team to use for this export. Defaults to the team used to build the archive.</div></pre></td></tr></table></figure>
<ul>
<li>method：打包类型，企业版、ad-Hoc版、上架appstore版</li>
<li>teamID：证书对应的teamID，可以去钥匙串中查看。</li>
</ul>
<p>我们通过key，value的形式填入自己生成的plist文件中。</p>
<p>参考链接：<br><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html" target="_blank" rel="external">https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html</a></p>
<p><a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcrun.1.html" target="_blank" rel="external">https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/xcrun.1.html</a></p>
<h2 id="开始打包"><a href="#开始打包" class="headerlink" title="开始打包"></a>开始打包</h2><p>一切都部署成功的情况下，开始构建，结果发现如下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:unknown error -1=ffffffffffffffff</div><div class="line"> Command /usr/bin/codesign failed with exit code 1</div></pre></td></tr></table></figure>
<p>可能是你的钥匙串的访问权限问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">获取keychain权限，解锁keychain，执行以下命令：</div><div class="line">security -v unlock-keychain -p password ~/Library/Keychains/login.keychain </div><div class="line">// password为电脑的密码</div></pre></td></tr></table></figure>
<p>如果这个命令还是有错误，那么需要手动修改一下证书的访问权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">设置钥匙串证书秘钥的访问权限：</div><div class="line">找到对应证书-&gt;</div><div class="line">点击最左边箭头展开秘钥-&gt;</div><div class="line">右击显示简介-&gt;</div><div class="line">点击访问控制-&gt;</div><div class="line">选择【允许所有应用程序访问此项目】-&gt; </div><div class="line">存储更改</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[组件化开发之CocoaPods私有库制作]]></title>
      <url>http://semyonxu.com/2017/02/27/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BCocoaPods%E7%A7%81%E6%9C%89%E5%BA%93%E5%88%B6%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>iOS中如果涉及到多个APP的同时开发，那么有些公共的代码可能需要有个统一的修改的地方，那么组件化功能就势在必行。CocoaPods的使用，我们一般使用pod库里面的公共框架，比如AFNetworking，但是我们不希望我们业务相关的代码提供给别人，这里讨论一下使用CocoaPods来制作私有库。</p>
<h1 id="CocoaPods-私有库制作方式一"><a href="#CocoaPods-私有库制作方式一" class="headerlink" title="CocoaPods 私有库制作方式一"></a>CocoaPods 私有库制作方式一</h1><h2 id="1-新建私有git库"><a href="#1-新建私有git库" class="headerlink" title="1. 新建私有git库"></a>1. 新建私有git库</h2><p>可以gitlab，也可以github，当然github是公共的，私有的得交费。</p>
<h2 id="2-创建工程"><a href="#2-创建工程" class="headerlink" title="2. 创建工程"></a>2. 创建工程</h2><p>可以使用pod命令来自动创建，命令：</p>
<blockquote>
<p>pod lib create TestKit</p>
</blockquote>
<p>中间会有很多配置，根据自己的需求配置即可。</p>
<p>如果想自动创建工程，那么需要将你的代码放到一个文件夹下，自己制作.podspec文件即可。</p>
<blockquote>
<p>pod spec cretae TestKit</p>
</blockquote>
<p>创建完之后，将工程提交到远端git库</p>
<a id="more"></a>
<h2 id="3-添加私有库到本地pod库："><a href="#3-添加私有库到本地pod库：" class="headerlink" title="3. 添加私有库到本地pod库："></a>3. 添加私有库到本地pod库：</h2><p>命令：</p>
<blockquote>
<p>pod repo add TestKit git@git.xxxx.git</p>
</blockquote>
<p>git@git.xxxx.git: 远端库的地址</p>
<p>成功之后，我们可以查看一下：</p>
<blockquote>
<p>cd ~/.cocoapods/repos<br>open .</p>
</blockquote>
<p>这里除了master之外，新增了一个TestKit文件夹</p>
<h2 id="4-开发代码，提交git，并打tag"><a href="#4-开发代码，提交git，并打tag" class="headerlink" title="4. 开发代码，提交git，并打tag"></a>4. 开发代码，提交git，并打tag</h2><p>开发完代码之后，修改一下.podspec 文件，然后提交git代码，并打tag<br>注意：这里.podspec 中的version必须跟git所打tag版本一致</p>
<blockquote>
<p>git add –all<br>git commit -m “update podspec”<br>git push origin master<br>git tag 0.0.1<br>git push –tags</p>
</blockquote>
<p>如果不确定podspec有么有问题，可用先执行【5】pod检测，再打tag</p>
<h2 id="5-检测一下pod库是否可用"><a href="#5-检测一下pod库是否可用" class="headerlink" title="5. 检测一下pod库是否可用"></a>5. 检测一下pod库是否可用</h2><p>命令：</p>
<blockquote>
<p>pod lib lint</p>
</blockquote>
<p>如果有警告可以使用命令忽略：</p>
<blockquote>
<p>pod lib lint –allow-warnings</p>
</blockquote>
<p>如果有问题，那么一般是podspec配置问题。</p>
<p>成功提示：</p>
<blockquote>
<p>TestKit.podspec passed validation.</p>
</blockquote>
<h2 id="6-本地测试库是否可用"><a href="#6-本地测试库是否可用" class="headerlink" title="6.本地测试库是否可用"></a>6.本地测试库是否可用</h2><p>新建工程</p>
<blockquote>
<p>pod init </p>
</blockquote>
<p>修改podfile文件, 并添加上本地库路径</p>
<blockquote>
<p>pod ‘TestKit’, :path =&gt; ‘/Users/xxx/Documents/TestKit’</p>
</blockquote>
<p>拉取pod代码</p>
<blockquote>
<p>pod install</p>
</blockquote>
<p>成功后，可用看到我们的库并没有在pods里面，而是在Development Pods里面，可用先检测代码有没有问题。</p>
<h2 id="7-提交本地库，向Spec-Repo提交podspec"><a href="#7-提交本地库，向Spec-Repo提交podspec" class="headerlink" title="7.提交本地库，向Spec Repo提交podspec"></a>7.提交本地库，向Spec Repo提交podspec</h2><p>命令：</p>
<blockquote>
<p>pod repo push TestKit TestKit.podspec</p>
</blockquote>
<p>如果没有什么问题，那么恭喜成功了。</p>
<h2 id="8-测试一下"><a href="#8-测试一下" class="headerlink" title="8.测试一下"></a>8.测试一下</h2><p>pod搜索一下：</p>
<blockquote>
<p>pod search TestKit </p>
</blockquote>
<p>在新工程中的podfile文件中，新增</p>
<blockquote>
<p>pod ‘TestKit’</p>
</blockquote>
<p>如果报错，拉取不下来，可以更新一下pod</p>
<blockquote>
<p>pod update </p>
</blockquote>
<p>如果还是报错：<br>[!] An unexpected version directory <code>Assets</code> was encountered for the <code>/Users/xxx/.cocoapods/repos/TestKit</code> Pod in the <code>TestKit</code> repository.<br>修改podfile文件：</p>
<blockquote>
<p>pod ‘TestKit’, :git =&gt; ‘<a href="https://xxx/TestKit.git" target="_blank" rel="external">https://xxx/TestKit.git</a>‘</p>
</blockquote>
<p>此处git是你远端git库的地址，如果git@git.xxxx.git不可以，换成https的地址即可。</p>
<h1 id="CocoaPods-私有库制作方式二"><a href="#CocoaPods-私有库制作方式二" class="headerlink" title="CocoaPods 私有库制作方式二"></a>CocoaPods 私有库制作方式二</h1><p>此方式是使用公共库的制作方式，将代码以framework的形式呈现，那么源码也是别人无法看到的。这种方式需要维护两个git库，一个是源码库，一个是framework库。维护相对来说麻烦一些，但是制作的跟公共库一样，使用方便。</p>
<h2 id="1-新建git私有库"><a href="#1-新建git私有库" class="headerlink" title="1. 新建git私有库"></a>1. 新建git私有库</h2><p>新建一个git库工程</p>
<h2 id="2-创建工程-1"><a href="#2-创建工程-1" class="headerlink" title="2. 创建工程"></a>2. 创建工程</h2><p>创建的方式跟法【一】的一样</p>
<h2 id="3-检测podspec文件是否正确"><a href="#3-检测podspec文件是否正确" class="headerlink" title="3. 检测podspec文件是否正确"></a>3. 检测podspec文件是否正确</h2><p>命令：</p>
<blockquote>
<p>pod spec lint TestKit.podspec</p>
</blockquote>
<p>此处很可能有问题，根据问题提示修改即可</p>
<h2 id="4-提交远端，并打tag"><a href="#4-提交远端，并打tag" class="headerlink" title="4. 提交远端，并打tag"></a>4. 提交远端，并打tag</h2><p>命令参考法【一】</p>
<h2 id="5-打framework包"><a href="#5-打framework包" class="headerlink" title="5. 打framework包"></a>5. 打framework包</h2><p>使用cocoapods-packager工具，可以使用命令查看自己电脑有没有安装：</p>
<blockquote>
<p>gem list</p>
</blockquote>
<p>如果没有的话，安装一下：</p>
<blockquote>
<p>sudo gem install cocoapods-packager</p>
</blockquote>
<p>如果报错，没有权限,新系统修改一下</p>
<blockquote>
<p>sudo gem install -n /usr/local/bin cocoapods-packager</p>
</blockquote>
<p>使用打包命令：</p>
<blockquote>
<p>pod package TestKit.podspec –force</p>
</blockquote>
<p>此处–force是强制覆盖的意思</p>
<p>如果你想把framework放到其他目录下,切换到你想存的目录下, 把TestKit.podspec路径补充完全即可</p>
<blockquote>
<p>cd xxx<br>pod package xxx/xxx/TestKit.podspec –force</p>
</blockquote>
<p>注意：tag很重要，必须保证跟TestKit.podspec中的一致，因为打包会根据.podspec文件中的version去git库找tag标记对应的代码。</p>
<h2 id="6-新建framework库"><a href="#6-新建framework库" class="headerlink" title="6. 新建framework库"></a>6. 新建framework库</h2><p>一般是公有的，其他人可以访问的，比如：github</p>
<h2 id="7-新建fremwork工程"><a href="#7-新建fremwork工程" class="headerlink" title="7. 新建fremwork工程"></a>7. 新建fremwork工程</h2><p>跟上面2新建工程一样，区别在于将源码替换成framework</p>
<p>如果不想新建，可以直接复制之前新建的工程替换即可。</p>
<p>新建完，可以再检测一下podspec文件是否正取。</p>
<p>完成后，提交git，并打tag</p>
<h2 id="8-上传pod官方库"><a href="#8-上传pod官方库" class="headerlink" title="8. 上传pod官方库"></a>8. 上传pod官方库</h2><p>使用cocoapods-trunk工具</p>
<p>如果没有的话，安装一下：</p>
<blockquote>
<p>sudo gem install cocoapods-trunk</p>
</blockquote>
<p>如果报错，没有权限,新系统修改一下</p>
<blockquote>
<p>sudo gem install -n /usr/local/bin cocoapods-trunk</p>
</blockquote>
<p>发布podspec：</p>
<blockquote>
<p>pod trunk push TestKit.podspec</p>
</blockquote>
<p>如果没有问题，可以搜一下：</p>
<blockquote>
<p>pod search TestKit</p>
</blockquote>
<p>如果没有搜到，可以重新setup一下pod，这个过程是比较漫长的，会重新拉取pod官方库master文件：</p>
<blockquote>
<p>pod setup</p>
</blockquote>
<h2 id="9-测试"><a href="#9-测试" class="headerlink" title="9. 测试"></a>9. 测试</h2><p>直接在podfile文件中添加</p>
<blockquote>
<p>pod ‘TestKit’</p>
</blockquote>
<p>OK, 大功告成，以后的维护工作，就是重复这个步骤（不用新建git库、pod工程），修改完代码别忘了打tag，修改podspec文件version。</p>
<p>参考：<br><a href="http://guides.cocoapods.org/making/private-cocoapods.html" target="_blank" rel="external">http://guides.cocoapods.org/making/private-cocoapods.html</a></p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WebViewJavascriptBridge源码解析]]></title>
      <url>http://semyonxu.com/2017/01/08/WebViewJavascriptBridge%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>对于APP开发，一方面需要快速迭代，一方面需要效果好性能优。这样Hybrid模式应运而生。<br>本文主要解析一下WebViewJavascriptBridge这个OC与JS交互框架的封装思路。</p>
<p>当前版本：v5.0.7</p>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="OC端"><a href="#OC端" class="headerlink" title="OC端"></a>OC端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)setupWVJSBridge &#123;</div><div class="line">    [WebViewJavascriptBridge enableLogging];</div><div class="line">    _bridge = [WebViewJavascriptBridge bridgeForWebView:_webView];</div><div class="line">    [_bridge setWebViewDelegate:self]; </div><div class="line">        [_bridge registerHandler:@&quot;Hybird&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;</div><div class="line">        NSLog(@&quot;data %@ responseCallBack %@&quot;, data, responseCallback);</div><div class="line">        NSDictionary* dicResult = @&#123;@&quot;ret&quot;:@&quot;OK&quot;&#125;;</div><div class="line">        responseCallback(dicResult);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [_bridge callHandler:@&quot;InvokeJavascriptHandler&quot; data:@&#123; @&quot;say&quot;:@&quot;Hello&quot; &#125; responseCallback:^(id responseData) &#123;</div><div class="line">        NSLog(@&quot;OC get call back from js when OC invoke %@&quot;, responseData);</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="JS端"><a href="#JS端" class="headerlink" title="JS端"></a>JS端</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WebViewJavascriptBridge.registerHandler(&apos;InvokeJavascriptHandler&apos;, function(data, responseCallback) &#123;</div><div class="line">                                                responseCallback(&#123;say : &apos;Hi&apos;&#125;)</div><div class="line">                                                    &#125;)</div><div class="line">                                                    </div><div class="line">function test_Hybird()&#123;</div><div class="line">WebViewJavascriptBridge.callHandler(&apos;Hybird&apos;, &#123;&#125;, function(cb)&#123;</div><div class="line">                                    alert(&apos;js 收到回调 &apos; + cb.ret)</div><div class="line">                                      &#125;)                                        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然需要提前注入JS代码。</p>
<h1 id="WebView提前注入JS"><a href="#WebView提前注入JS" class="headerlink" title="WebView提前注入JS"></a>WebView提前注入JS</h1><p>首先我们知道，OC可以在webView中方便的执行JS代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[webView stringByEvaluatingJavaScriptFromString:@&quot;alert(&apos;Hi&apos;)&quot;];</div></pre></td></tr></table></figure>
<p>而JS直接调用OC没有提供直接的方法（当然了，iOS7 之后Apple提供了JavaScriptCore框架可以使用，本文不详细介绍），那么我们需要通过触发url重定向功能，在WebView的回调方法中捕获url，然后通过特定的url来执行我们需要的方法。</p>
<h2 id="提前注入JS的方法"><a href="#提前注入JS的方法" class="headerlink" title="提前注入JS的方法"></a>提前注入JS的方法</h2><h3 id="作者提供的方法是在JS中触发"><a href="#作者提供的方法是在JS中触发" class="headerlink" title="作者提供的方法是在JS中触发"></a>作者提供的方法是在JS中触发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function setupWebViewJavascriptBridge(callback) &#123;</div><div class="line">        if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</div><div class="line">        if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</div><div class="line">        window.WVJBCallbacks = [callback];</div><div class="line">        var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class="line">        WVJBIframe.style.display = &apos;none&apos;;</div><div class="line">        WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class="line">        document.documentElement.appendChild(WVJBIframe);</div><div class="line">        setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">setupWebViewJavascriptBridge()</div></pre></td></tr></table></figure>
<p>前端同学需要在JS代码中，提前写入这段代码，才会有Hybrid交互的能力。</p>
<p>当执行上面这段代码的时候，会获取iframe这个属性，通过改变iframe的src来触发UIWebview的回调:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType</div></pre></td></tr></table></figure>
<p>这里注入的回调url是：<br>wvjbscheme://<strong>BRIDGE_LOADED</strong><br>顺便说下执行JS的url是：<br>wvjbscheme://<strong>WVJB_QUEUE_MESSAGE</strong></p>
<h3 id="当然我们OC也可以在手动执行JS注入代码"><a href="#当然我们OC也可以在手动执行JS注入代码" class="headerlink" title="当然我们OC也可以在手动执行JS注入代码"></a>当然我们OC也可以在手动执行JS注入代码</h3><p>简单点的方法，直接在修改库文件WebViewJavascriptBridge，把WebViewJavascriptBridgeBase *_base;拿到.h文件中，我们就可以方便的调用,需要在网页加载完回调中执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;</div><div class="line">    [_base performSelector:@selector(injectJavascriptFile)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你不想改变三方库呢，可以用runtime的方法，获取这个私有的变量_base</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)injectJSBridgeBase &#123;</div><div class="line">    unsigned int count = 0;</div><div class="line">    Ivar *members = class_copyIvarList([_bridge class], &amp;count);</div><div class="line">    for (int i=0; i&lt;count; i++) &#123;</div><div class="line">        Ivar var = members[i];</div><div class="line">        const char * memberName = ivar_getName(var);</div><div class="line">        const char * memberType = ivar_getTypeEncoding(var);</div><div class="line">        NSString *strMemberType = [NSString stringWithFormat:@&quot;%s&quot;, memberType];</div><div class="line">        if ([strMemberType rangeOfString:@&quot;WebViewJavascriptBridgeBase&quot;].location != NSNotFound) &#123;</div><div class="line">            _base = object_getIvar(_bridge, var);</div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    free(members);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ok,完美。</p>
<h2 id="UIWebview回调捕获URL处理"><a href="#UIWebview回调捕获URL处理" class="headerlink" title="UIWebview回调捕获URL处理"></a>UIWebview回调捕获URL处理</h2><p>通过UIWebview的代理方法处理URL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</div><div class="line">    if (webView != _webView) &#123; return YES; &#125;</div><div class="line">    NSURL *url = [request URL];</div><div class="line">    __strong WVJB_WEBVIEW_DELEGATE_TYPE* strongDelegate = _webViewDelegate;</div><div class="line">    if ([_base isCorrectProcotocolScheme:url]) &#123; // 判断是不是sheme：wvjbscheme</div><div class="line">        if ([_base isBridgeLoadedURL:url]) &#123; // 判断是不是：wvjbscheme://__BRIDGE_LOADED__</div><div class="line">            [_base injectJavascriptFile]; // 注入js</div><div class="line">        &#125; else if ([_base isQueueMessageURL:url]) &#123; // js注入后，触发新的url重定向 wvjbscheme://__WVJB_QUEUE_MESSAGE__</div><div class="line">            NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]]; // 获取js中的缓存队列数组字符串，清空队列</div><div class="line">            [_base flushMessageQueue:messageQueueString]; // 执行js中的缓存队列数组，全部执行完</div><div class="line">        &#125; else &#123;</div><div class="line">            [_base logUnkownMessage:url]; // sheme：wvjbscheme 下其他的url 直接提示出错</div><div class="line">        &#125;</div><div class="line">        return NO; // 只是执行js注入，不会执行加载操作</div><div class="line">    &#125; else if (strongDelegate &amp;&amp; [strongDelegate respondsToSelector:@selector(webView:shouldStartLoadWithRequest:navigationType:)]) &#123; // 如果设置delegate，则调用代理方法</div><div class="line">        return [strongDelegate webView:webView shouldStartLoadWithRequest:request navigationType:navigationType];</div><div class="line">    &#125; else &#123; // 什么也不是正常执行</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对sheme：wvjbscheme的处理主要是三部分：</p>
<ul>
<li>注入JS</li>
<li>处理消息</li>
<li>其他错误Log提示</li>
</ul>
<p>对其他的sheme，如果设置delegate:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setWebViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate;</div></pre></td></tr></table></figure>
<p>那么执行设置设置代理的方法。如果没有设置，那么WebView将不执行delegate的回调方法。即使你在UIViewController里面设置webView.delegate = self,也是无济于事的。</p>
<p>下面分析一下重要的两个分支。</p>
<h3 id="注入JS方法分支分析"><a href="#注入JS方法分支分析" class="headerlink" title="注入JS方法分支分析"></a>注入JS方法分支分析</h3><p>这里通过isBridgeLoadedURL方法是否是注入的url，是的话执行注入JS代码injectJavascriptFile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)injectJavascriptFile &#123;</div><div class="line">    NSString *js = WebViewJavascriptBridge_js();</div><div class="line">    [self _evaluateJavascript:js];</div><div class="line">    if (self.startupMessageQueue) &#123; // 一般是oc开始的注册handler方法</div><div class="line">        NSArray* queue = self.startupMessageQueue;</div><div class="line">        self.startupMessageQueue = nil;</div><div class="line">        for (id queuedMessage in queue) &#123;</div><div class="line">            [self _dispatchMessage:queuedMessage];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这里会获取本地写好的JS代码，然后执行，顺便提一句_evaluateJavascript方法就是封装的stringByEvaluatingJavaScriptFromString。</li>
<li>如果有缓存队列self.startupMessageQueue，执行里面全部的消息，一般是OC提前调用- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler方法，提前注册JS调用OC的响应方法。</li>
</ul>
<p>下面看下执行方法：_dispatchMessage:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (void)_dispatchMessage:(WVJBMessage*)message &#123;</div><div class="line">    NSString *messageJSON = [self _serializeMessage:message pretty:NO];</div><div class="line">    [self _log:@&quot;SEND&quot; json:messageJSON];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\\&quot; withString:@&quot;\\\\&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;\\\&quot;&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\&apos;&quot; withString:@&quot;\\\&apos;&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\n&quot; withString:@&quot;\\n&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\r&quot; withString:@&quot;\\r&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\f&quot; withString:@&quot;\\f&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\u2028&quot; withString:@&quot;\\u2028&quot;];</div><div class="line">    messageJSON = [messageJSON stringByReplacingOccurrencesOfString:@&quot;\u2029&quot; withString:@&quot;\\u2029&quot;];</div><div class="line">    </div><div class="line">    NSString* javascriptCommand = [NSString stringWithFormat:@&quot;WebViewJavascriptBridge._handleMessageFromObjC(&apos;%@&apos;);&quot;, messageJSON];</div><div class="line">    </div><div class="line">    // 需要保证在主线程中执行js代码</div><div class="line">    if ([[NSThread currentThread] isMainThread]) &#123;</div><div class="line">        [self _evaluateJavascript:javascriptCommand];</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_sync(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [self _evaluateJavascript:javascriptCommand];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先将字典（WVJBMessage）类型数据转换成String</li>
<li>做一些特殊字符的转换</li>
<li>调用JS的WebViewJavascriptBridge._handleMessageFromObjC(‘%@’)方法，将消息传进去。</li>
</ul>
<p>那么我们看一下JS的_handleMessageFromObjC()方法做了些什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">function _handleMessageFromObjC(messageJSON) &#123;</div><div class="line">        _dispatchMessageFromObjC(messageJSON);</div><div class="line">	&#125;</div><div class="line">function _dispatchMessageFromObjC(messageJSON) &#123;</div><div class="line">		if (dispatchMessagesWithTimeoutSafety) &#123;</div><div class="line">			setTimeout(_doDispatchMessageFromObjC);</div><div class="line">		&#125; else &#123;</div><div class="line">			 _doDispatchMessageFromObjC();</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		function _doDispatchMessageFromObjC() &#123;</div><div class="line">			var message = JSON.parse(messageJSON);</div><div class="line">			var messageHandler;</div><div class="line">			var responseCallback;</div><div class="line"></div><div class="line">			if (message.responseId) &#123;</div><div class="line">				responseCallback = responseCallbacks[message.responseId];</div><div class="line">				if (!responseCallback) &#123;</div><div class="line">					return;</div><div class="line">				&#125;</div><div class="line">				responseCallback(message.responseData);</div><div class="line">				delete responseCallbacks[message.responseId];</div><div class="line">			&#125; else &#123;</div><div class="line">				if (message.callbackId) &#123;</div><div class="line">					var callbackResponseId = message.callbackId;</div><div class="line">					responseCallback = function(responseData) &#123;</div><div class="line">						_doSend(&#123; handlerName:message.handlerName, responseId:callbackResponseId, responseData:responseData &#125;);</div><div class="line">					&#125;;</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">				var handler = messageHandlers[message.handlerName];</div><div class="line">				if (!handler) &#123;</div><div class="line">					console.log(&quot;WebViewJavascriptBridge: WARNING: no handler for message from ObjC:&quot;, message);</div><div class="line">				&#125; else &#123;</div><div class="line">					handler(message.data, responseCallback);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<ul>
<li>首先做Json格式转换</li>
<li>判断message是否有responseId，有通过responseId执行本地的回调方法。</li>
<li><p>没有responseId，回调handler方法，将数据，回调方法传回去，本地的callHandler是通过message.handlerName来标示的。<br>如果有callbackId，就是本地支持回调，那么实现一个匿名函数接受回调。<br>在触发responseCallback的时候，会有三个参数：</p>
<p>1)handlerName：调用的名称<br>2)responseId：这里会把callbackId转变成responseId<br>3)responseData：回调的数据信息</p>
<p>注意，responseId跟callbackId的区别：</p>
<ul>
<li>callbackId: 用来标示回调的id，在触发回调的时候会把callbackId变成responseId</li>
<li>responseId: 用来执行回调的id</li>
</ul>
<p>最后看下这个doSend方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function _doSend(message, responseCallback) &#123;</div><div class="line">	if (responseCallback) &#123;</div><div class="line">		var callbackId = &apos;cb_&apos;+(uniqueId++)+&apos;_&apos;+new Date().getTime();</div><div class="line">		responseCallbacks[callbackId] = responseCallback;</div><div class="line">		message[&apos;callbackId&apos;] = callbackId;</div><div class="line">	&#125;</div><div class="line">	sendMessageQueue.push(message); // 添加message到数组中</div><div class="line">	messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + &apos;://&apos; + QUEUE_HAS_MESSAGE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>这个方法执行消息的发送，如果有回调方法的话，这里会生成一个callbackId，然后存responseCallbacks中，message中新增callbackId的信息。</li>
<li>添加到sendMessageQueue队列中</li>
<li>改变iframe的src触发Webview的回调</li>
</ul>
<p>这里会触发UIWebview的回调，此时的url为：<br>wvjbscheme://<strong>WVJB_QUEUE_MESSAGE</strong><br>正好走回调的第二个分支，下面分析第二个分支</p>
<h3 id="执行消息分支分析"><a href="#执行消息分支分析" class="headerlink" title="执行消息分支分析"></a>执行消息分支分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">else if ([_base isQueueMessageURL:url]) &#123; // js注入后，触发新的url重定向 wvjbscheme://__WVJB_QUEUE_MESSAGE__</div><div class="line">            NSString *messageQueueString = [self _evaluateJavascript:[_base webViewJavascriptFetchQueyCommand]]; // 获取js中的缓存队列数组字符串，清空队列</div><div class="line">            [_base flushMessageQueue:messageQueueString]; // 执行js中的缓存队列数组，全部执行完</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面分两部分解析消息的处理</p>
<p>1） 消息的获取<br>这里会执行JS代码，通过webViewJavascriptFetchQueyCommand方法获取JS的messageQueueString，也就上上面的sendMessageQueue里面的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(NSString *)webViewJavascriptFetchQueyCommand &#123;</div><div class="line">    return @&quot;WebViewJavascriptBridge._fetchQueue();&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JS中_fetchQueue()方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function _fetchQueue() &#123;</div><div class="line">	var messageQueueString = JSON.stringify(sendMessageQueue);</div><div class="line">	sendMessageQueue = [];</div><div class="line">	return messageQueueString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出是直接把sendMessageQueue转换成string。</p>
<p>2） 消息的执行</p>
<p>执行方法flushMessageQueue：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (void)flushMessageQueue:(NSString *)messageQueueString&#123;</div><div class="line">    if (messageQueueString == nil || messageQueueString.length == 0) &#123;</div><div class="line">        NSLog(@&quot;WebViewJavascriptBridge: WARNING: ObjC got nil while fetching the message queue JSON from webview. This can happen if the WebViewJavascriptBridge JS is not currently present in the webview, e.g if the webview just loaded a new page.&quot;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id messages = [self _deserializeMessageJSON:messageQueueString];</div><div class="line">    for (WVJBMessage* message in messages) &#123;</div><div class="line">        if (![message isKindOfClass:[WVJBMessage class]]) &#123;</div><div class="line">            NSLog(@&quot;WebViewJavascriptBridge: WARNING: Invalid %@ received: %@&quot;, [message class], message);</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        [self _log:@&quot;RCVD&quot; json:message];</div><div class="line">        </div><div class="line">        NSString* responseId = message[@&quot;responseId&quot;];</div><div class="line">        if (responseId) &#123;</div><div class="line">            WVJBResponseCallback responseCallback = _responseCallbacks[responseId];</div><div class="line">            responseCallback(message[@&quot;responseData&quot;]);</div><div class="line">            [self.responseCallbacks removeObjectForKey:responseId];</div><div class="line">        &#125; else &#123;</div><div class="line">            WVJBResponseCallback responseCallback = NULL;</div><div class="line">            NSString* callbackId = message[@&quot;callbackId&quot;];</div><div class="line">            if (callbackId) &#123; // 如果接收到js的callbackId，初始化一个block，里面变callbackId为responseId</div><div class="line">                responseCallback = ^(id responseData) &#123;</div><div class="line">                    if (responseData == nil) &#123;</div><div class="line">                        responseData = [NSNull null];</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    WVJBMessage* msg = @&#123; @&quot;responseId&quot;:callbackId, @&quot;responseData&quot;:responseData &#125;;</div><div class="line">                    [self _queueMessage:msg];</div><div class="line">                &#125;;</div><div class="line">            &#125; else &#123;</div><div class="line">                responseCallback = ^(id ignoreResponseData) &#123;</div><div class="line">                    // Do nothing</div><div class="line">                &#125;;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            WVJBHandler handler = self.messageHandlers[message[@&quot;handlerName&quot;]];</div><div class="line">            </div><div class="line">            if (!handler) &#123;</div><div class="line">                NSLog(@&quot;WVJBNoHandlerException, No handler for message from JS: %@&quot;, message);</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            handler(message[@&quot;data&quot;], responseCallback);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到这里思路跟JS里面是相似的。<br>先将消息转换成JSON对象，然后便利所有的消息任务，如果有responseId，执行本地回调，并从self.responseCallbacks中移除执行过的回调方法。如果没有，通过message[@”handlerName”]执行self.messageHandlers中的回调，如果有callbackId，初始化一个responseCallback的block，并传入handler中，接收OC的再回调。</p>
<h1 id="OC直接call-JS"><a href="#OC直接call-JS" class="headerlink" title="OC直接call JS"></a>OC直接call JS</h1><p>WebViewJavascriptBridge方法中提供方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef void (^WVJBHandler)(id data, WVJBResponseCallback responseCallback);</div><div class="line"></div><div class="line">- (void)callHandler:(NSString*)handlerName;</div><div class="line">- (void)callHandler:(NSString*)handlerName data:(id)data;</div><div class="line">- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback;</div></pre></td></tr></table></figure>
<p>这里需要提供JS里面的对应的handlerName，然后参数data，最后是响应的回调，提供JS回调的数据，一个responseCallback的Block，可以再回调JS。当然如果你不需要回调，可以置为nil。 </p>
<p>方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)callHandler:(NSString *)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback &#123;</div><div class="line">    [_base sendData:data responseCallback:responseCallback handlerName:handlerName];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// WebViewJavascriptBridgeBase中</div><div class="line">- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString*)handlerName &#123;</div><div class="line">    NSMutableDictionary* message = [NSMutableDictionary dictionary];</div><div class="line">    </div><div class="line">    if (data) &#123;</div><div class="line">        message[@&quot;data&quot;] = data;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (responseCallback) &#123;</div><div class="line">        NSString* callbackId = [NSString stringWithFormat:@&quot;objc_cb_%ld&quot;, ++_uniqueId];</div><div class="line">        self.responseCallbacks[callbackId] = [responseCallback copy];</div><div class="line">        message[@&quot;callbackId&quot;] = callbackId;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (handlerName) &#123;</div><div class="line">        message[@&quot;handlerName&quot;] = handlerName;</div><div class="line">    &#125;</div><div class="line">    [self _queueMessage:message];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用的是_base的sendData:方法，这里将参数放入字典message中，并把回调block放到self.responseCallbacks字典中。</p>
<ul>
<li>data：存储的数据</li>
<li>callbackId：标示block在self.responseCallbacks中的位置</li>
<li>handlerName：交互的名字</li>
</ul>
<p>这样就解决了block回调在JS中不兼容的问题，两端分别实现，用callbackId来标示，用responseId来执行。思路不错。</p>
<p>_queueMessage:执行这条message。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)_queueMessage:(WVJBMessage*)message &#123;</div><div class="line">    if (self.startupMessageQueue) &#123; // startupMessageQueue：未在webview中注入js之前，缓存之前的交互消息message</div><div class="line">        [self.startupMessageQueue addObject:message];</div><div class="line">    &#125; else &#123;</div><div class="line">        [self _dispatchMessage:message];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>_dispatchMessage: 通过JS调用执行这条message，具体在前面已经解析过了，这里不再赘述。</p>
<h1 id="OC注册方法，等待JS-call-OC"><a href="#OC注册方法，等待JS-call-OC" class="headerlink" title="OC注册方法，等待JS call OC"></a>OC注册方法，等待JS call OC</h1><p>WebViewJavascriptBridge方法中提供方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler;</div></pre></td></tr></table></figure>
<p>方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)registerHandler:(NSString *)handlerName handler:(WVJBHandler)handler &#123;</div><div class="line">    _base.messageHandlers[handlerName] = [handler copy];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，只是将hander放到_base（WebViewJavascriptBridgeBase的一个实例对象）的messageHandlers字典中，标示的key为handlerName。</p>
<p>这就结束了，然后等待是JS的调用触发，即：iframe.src设置触发UIWebView的Delegate回调。上面解析注入JS的时候解析过，这里不详细展开。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking-3-0-源码解析之UIKit]]></title>
      <url>http://semyonxu.com/2016/11/15/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BUIKit/</url>
      <content type="html"><![CDATA[<p>本部分主要的作用：对UI控件进行网络请求的支持。</p>
<h1 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h1><p> 功能：本部分主要方便UI使用网络功能，为UIImageView，UIButton等设置网络下载图片。功能类似于SDWebImage库。以及UIProgressView，UIWebView，UIRefreshControl，UIActivityIndicatorView部分UI的网络使用封装。</p>
<p> 下面分别解析一下各个控件的设计思路</p>
<h1 id="UIImageView-AFNetworking"><a href="#UIImageView-AFNetworking" class="headerlink" title="UIImageView+AFNetworking"></a>UIImageView+AFNetworking</h1><p>为UIImageView加载网络图片提供便利的接口。</p>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setImageWithURL:(NSURL *)url;</div><div class="line">- (void)setImageWithURL:(NSURL *)url</div><div class="line">       placeholderImage:(nullable UIImage *)placeholderImage;</div><div class="line">- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest</div><div class="line">              placeholderImage:(nullable UIImage *)placeholderImage</div><div class="line">                       success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success</div><div class="line">                       failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;</div></pre></td></tr></table></figure>
<p>这里为我们抛出了图片下载地址，默认显示图片，成功的回调，失败的回调。</p>
<p>下面解析下载的核心转换代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest</div><div class="line">              placeholderImage:(UIImage *)placeholderImage</div><div class="line">                       success:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success</div><div class="line">                       failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if ([urlRequest URL] == nil) &#123;</div><div class="line">        [self cancelImageDownloadTask];</div><div class="line">        self.image = placeholderImage;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self isActiveTaskURLEqualToURLRequest:urlRequest])&#123; // - 检测是当前任务是否有这个urlRequest</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self cancelImageDownloadTask];</div><div class="line"></div><div class="line">    AFImageDownloader *downloader = [[self class] sharedImageDownloader];</div><div class="line">    id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;</div><div class="line"></div><div class="line">    //Use the image from the image cache if it exists</div><div class="line">    UIImage *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:nil];</div><div class="line">    if (cachedImage) &#123;</div><div class="line">        if (success) &#123;</div><div class="line">            success(urlRequest, nil, cachedImage);</div><div class="line">        &#125; else &#123;</div><div class="line">            self.image = cachedImage;</div><div class="line">        &#125;</div><div class="line">        [self clearActiveDownloadInformation];</div><div class="line">    &#125; else &#123;</div><div class="line">        if (placeholderImage) &#123;</div><div class="line">            self.image = placeholderImage;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        __weak __typeof(self)weakSelf = self;</div><div class="line">        NSUUID *downloadID = [NSUUID UUID]; // 下载标识符</div><div class="line">        AFImageDownloadReceipt *receipt; // 完成标识符，下载跟完成是一样的</div><div class="line">        receipt = [downloader</div><div class="line">                   downloadImageForURLRequest:urlRequest</div><div class="line">                   withReceiptID:downloadID</div><div class="line">                   success:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, UIImage * _Nonnull responseObject) &#123;</div><div class="line">                       __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line">                       if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</div><div class="line">                           if (success) &#123; // 成功返回</div><div class="line">                               success(request, response, responseObject);</div><div class="line">                           &#125; else if(responseObject) &#123; // 成功但是不是请求成功，用缓存图片，直接给imageview赋值</div><div class="line">                               strongSelf.image = responseObject;</div><div class="line">                           &#125;</div><div class="line">                           [strongSelf clearActiveDownloadInformation];</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                   &#125;</div><div class="line">                   failure:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, NSError * _Nonnull error) &#123;</div><div class="line">                       __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line">                        if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</div><div class="line">                            if (failure) &#123;</div><div class="line">                                failure(request, response, error);</div><div class="line">                            &#125;</div><div class="line">                            [strongSelf clearActiveDownloadInformation];</div><div class="line">                        &#125;</div><div class="line">                   &#125;]; // 注意，这个是同步的，所以可以获得receipt</div><div class="line"></div><div class="line">        self.af_activeImageDownloadReceipt = receipt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="首先会对上次的任务进行检测，如果有的话，取消掉。"><a href="#首先会对上次的任务进行检测，如果有的话，取消掉。" class="headerlink" title="首先会对上次的任务进行检测，如果有的话，取消掉。"></a>首先会对上次的任务进行检测，如果有的话，取消掉。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    if (self.af_activeImageDownloadReceipt != nil) &#123;</div><div class="line">        [[self.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:self.af_activeImageDownloadReceipt]; // runtime 管理对象获取downloader单利，取消当前这个receipt下的任务</div><div class="line">        [self clearActiveDownloadInformation]; // 清空 af_activeImageDownloadReceipt</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里检测的是self.af_activeImageDownloadReceipt，注意这是分类中添加的属性，下载的唯一标识符。也就是说如果这个任务已经下载过的话，下次重新下载会取消上次的下载任务。</p>
<p>类别添加属性的方法是用的runtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (AFImageDownloadReceipt *)af_activeImageDownloadReceipt &#123;</div><div class="line">    return (AFImageDownloadReceipt *)objc_getAssociatedObject(self, @selector(af_activeImageDownloadReceipt));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检测如果本地有缓存，直接获取缓存的图片，返回"><a href="#检测如果本地有缓存，直接获取缓存的图片，返回" class="headerlink" title="检测如果本地有缓存，直接获取缓存的图片，返回"></a>检测如果本地有缓存，直接获取缓存的图片，返回</h3><p>缓存类是：AFAutoPurgingImageCache。<br>缓存类的封装思路：</p>
<h4 id="AFAutoPurgingImageCache"><a href="#AFAutoPurgingImageCache" class="headerlink" title="AFAutoPurgingImageCache"></a>AFAutoPurgingImageCache</h4><p>简单的图片缓存，比起SDWebImage来说比较简单，没有分别存内存和硬盘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSMutableDictionary &lt;NSString* , AFCachedImage*&gt; *cachedImages;</div><div class="line">@property (nonatomic, assign) UInt64 currentMemoryUsage;</div><div class="line">@property (nonatomic, strong) dispatch_queue_t synchronizationQueue;</div></pre></td></tr></table></figure>
<p>cachedImages：缓存字典<br>currentMemoryUsage：当前使用的内存字节大小<br>synchronizationQueue：同步队列，主要用来做同步操作</p>
<h5 id="初始化方法："><a href="#初始化方法：" class="headerlink" title="初始化方法："></a>初始化方法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithMemoryCapacity:(UInt64)memoryCapacity preferredMemoryCapacity:(UInt64)preferredMemoryCapacity &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        self.memoryCapacity = memoryCapacity;</div><div class="line">        self.preferredMemoryUsageAfterPurge = preferredMemoryCapacity;</div><div class="line">        self.cachedImages = [[NSMutableDictionary alloc] init];</div><div class="line"></div><div class="line">        NSString *queueName = [NSString stringWithFormat:@&quot;com.alamofire.autopurgingimagecache-%@&quot;, [[NSUUID UUID] UUIDString]];</div><div class="line">        self.synchronizationQueue = dispatch_queue_create([queueName cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">        [[NSNotificationCenter defaultCenter]</div><div class="line">         addObserver:self</div><div class="line">         selector:@selector(removeAllImages)</div><div class="line">         name:UIApplicationDidReceiveMemoryWarningNotification</div><div class="line">         object:nil];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步队列是用的自定义并行队列。这里有对内存警告的处理。收到内存警告的通知：UIApplicationDidReceiveMemoryWarningNotification，执行清空所有缓存的图片removeAllImages方法。</p>
<h5 id="添加图片："><a href="#添加图片：" class="headerlink" title="添加图片："></a>添加图片：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier &#123;</div><div class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</div><div class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</div><div class="line"></div><div class="line">        AFCachedImage *previousCachedImage = self.cachedImages[identifier];</div><div class="line">        if (previousCachedImage != nil) &#123;</div><div class="line">            self.currentMemoryUsage -= previousCachedImage.totalBytes;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        self.cachedImages[identifier] = cacheImage;</div><div class="line">        self.currentMemoryUsage += cacheImage.totalBytes;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</div><div class="line">        if (self.currentMemoryUsage &gt; self.memoryCapacity) &#123;</div><div class="line">            UInt64 bytesToPurge = self.currentMemoryUsage - self.preferredMemoryUsageAfterPurge;</div><div class="line">            NSMutableArray &lt;AFCachedImage*&gt; *sortedImages = [NSMutableArray arrayWithArray:self.cachedImages.allValues];</div><div class="line">            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;lastAccessDate&quot;</div><div class="line">                                                                           ascending:YES];</div><div class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</div><div class="line"></div><div class="line">            UInt64 bytesPurged = 0;</div><div class="line"></div><div class="line">            for (AFCachedImage *cachedImage in sortedImages) &#123;</div><div class="line">                [self.cachedImages removeObjectForKey:cachedImage.identifier];</div><div class="line">                bytesPurged += cachedImage.totalBytes;</div><div class="line">                if (bytesPurged &gt;= bytesToPurge) &#123;</div><div class="line">                    break ;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            self.currentMemoryUsage -= bytesPurged;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的是GCD的barrier异步方法，在保证队列中前面的任务全部完成的情况下，执行添加方法，并不阻塞之后的任务执行。</p>
<ol>
<li>首先初始化一个AFCachedImage对象，用这个对象存图片，以及一些图片相关的信息。缓存字节数响应的增加调整。如果已经存在的图片进行处理，那么先减去缓存字节数，最后替换图片。</li>
<li>对缓存内容大小进行判断，使用barrier可以保证在上个添加任务完成后再执行下个任务。如果缓存大小超过总的缓存容量，那么首先执行排序，然后顺序移除，直到不再超出缓存容量。</li>
</ol>
<h5 id="移除图片"><a href="#移除图片" class="headerlink" title="移除图片"></a>移除图片</h5><p>移除图片类似使用的GCD的barrier同步方法。这里会阻塞，等待移除任务做完之后，进行以后的任务。跟添加有区别，这样可以保证线程安全。<br>上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (BOOL)removeImageWithIdentifier:(NSString *)identifier &#123;</div><div class="line">    __block BOOL removed = NO;</div><div class="line">    dispatch_barrier_sync(self.synchronizationQueue, ^&#123;</div><div class="line">        AFCachedImage *cachedImage = self.cachedImages[identifier];</div><div class="line">        if (cachedImage != nil) &#123;</div><div class="line">            [self.cachedImages removeObjectForKey:identifier];</div><div class="line">            self.currentMemoryUsage -= cachedImage.totalBytes;</div><div class="line">            removed = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return removed;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)removeAllImages &#123;</div><div class="line">    __block BOOL removed = NO;</div><div class="line">    dispatch_barrier_sync(self.synchronizationQueue, ^&#123;</div><div class="line">        if (self.cachedImages.count &gt; 0) &#123;</div><div class="line">            [self.cachedImages removeAllObjects];</div><div class="line">            self.currentMemoryUsage = 0;</div><div class="line">            removed = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里支持单个删除，全部删除。操作的还是当前这个cachedImages字典。</p>
<h3 id="网络下载，并把获取到的图片赋值给当前的ImageView"><a href="#网络下载，并把获取到的图片赋值给当前的ImageView" class="headerlink" title="网络下载，并把获取到的图片赋值给当前的ImageView"></a>网络下载，并把获取到的图片赋值给当前的ImageView</h3><p>首先，会先设置一个默认的placeholderImage占位图，如果你设置过的话。<br>然后，这里使用的是[NSUUID UUID]来做下载的唯一标识符，注意downloadID如receipt是一样的。这个是用来区别是否是当前任务。<br>下载任务是用的：AFImageDownloader。这是UI下载里面的核心部分。<br>通过调用下载方法，获取到下载图片结果。<br>如果成功，并且receiptID匹配当前的下载downloadID，有成功回调的话，返回去成功的参数已经图片。如果没有成功回调的话，直接给uiimageView赋值（这个地方跟SDWebImage还是有区别的，SDWebImage直接赋值，就算有成功回调也会赋值）。然后清空当前的下载信息，其实就是清空这个标示id。<br>如果失败，如果有失败block的情况，回调回去，没有不做任何处理，相同的清空下载信息。<br>最后有个赋值：<br>self.af_activeImageDownloadReceipt = receipt;<br>这个地方之所以可以这么赋值，是因为下载方法是同步的。注意的是这个任务是同步的，但是发起的网络请求是异步的。</p>
<p>下面解析一下AFImageDownloader.</p>
<h4 id="AFImageDownloader"><a href="#AFImageDownloader" class="headerlink" title="AFImageDownloader"></a>AFImageDownloader</h4><p>核心下载类，下载任务，取消任务。</p>
<h5 id="开始下载任务"><a href="#开始下载任务" class="headerlink" title="开始下载任务"></a>开始下载任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">- (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request</div><div class="line">                                                  withReceiptID:(nonnull NSUUID *)receiptID</div><div class="line">                                                        success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse  * _Nullable response, UIImage *responseObject))success</div><div class="line">                                                        failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure &#123;</div><div class="line">    </div><div class="line">    __block NSURLSessionDataTask *task = nil;</div><div class="line">    dispatch_sync(self.synchronizationQueue, ^&#123; </div><div class="line">        NSString *URLIdentifier = request.URL.absoluteString;</div><div class="line">        if (URLIdentifier == nil) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil];</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    failure(request, nil, error);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 1) Append the success and failure blocks to a pre-existing request if it already exists</div><div class="line">        AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">        if (existingMergedTask != nil) &#123;</div><div class="line">            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];</div><div class="line">            [existingMergedTask addResponseHandler:handler];</div><div class="line">            task = existingMergedTask.task;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 2) Attempt to load the image from the image cache if the cache policy allows it</div><div class="line">        switch (request.cachePolicy) &#123;</div><div class="line">            case NSURLRequestUseProtocolCachePolicy:</div><div class="line">            case NSURLRequestReturnCacheDataElseLoad: // 只有在cache中不存在data时才从原始地址下载。</div><div class="line">            case NSURLRequestReturnCacheDataDontLoad: &#123; // 只使用cache数据，如果不存在cache，请求失败；用于没有建立网络连接离线模式</div><div class="line">                UIImage *cachedImage = [self.imageCache imageforRequest:request withAdditionalIdentifier:nil];</div><div class="line">                if (cachedImage != nil) &#123;</div><div class="line">                    if (success) &#123;</div><div class="line">                        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                            success(request, nil, cachedImage);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 3) Create the request and set up authentication, validation and response serialization</div><div class="line">        NSUUID *mergedTaskIdentifier = [NSUUID UUID];</div><div class="line">        NSURLSessionDataTask *createdTask;</div><div class="line">        __weak __typeof__(self) weakSelf = self;</div><div class="line"></div><div class="line">        createdTask = [self.sessionManager</div><div class="line">                       dataTaskWithRequest:request</div><div class="line">                       completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) &#123;</div><div class="line">                           dispatch_async(self.responseQueue, ^&#123;</div><div class="line">                               __strong __typeof__(weakSelf) strongSelf = weakSelf;</div><div class="line">                               AFImageDownloaderMergedTask *mergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">                               if ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123;</div><div class="line">                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</div><div class="line">                                   if (error) &#123; // 失败返回回调</div><div class="line">                                       for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123;</div><div class="line">                                           if (handler.failureBlock) &#123;</div><div class="line">                                               dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                   handler.failureBlock(request, (NSHTTPURLResponse*)response, error);</div><div class="line">                                               &#125;);</div><div class="line">                                           &#125;</div><div class="line">                                       &#125;</div><div class="line">                                   &#125; else &#123; // 成功返回回调，添加图片到缓存</div><div class="line">                                       [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil];</div><div class="line"></div><div class="line">                                       for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123;</div><div class="line">                                           if (handler.successBlock) &#123;</div><div class="line">                                               dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                   handler.successBlock(request, (NSHTTPURLResponse*)response, responseObject);</div><div class="line">                                               &#125;);</div><div class="line">                                           &#125;</div><div class="line">                                       &#125;</div><div class="line">                                   &#125;</div><div class="line">                               &#125;</div><div class="line">                               [strongSelf safelyDecrementActiveTaskCount];</div><div class="line">                               [strongSelf safelyStartNextTaskIfNecessary]; // 成功开启下一个任务。保证最大并发数的情况下。</div><div class="line">                           &#125;);</div><div class="line">                       &#125;];</div><div class="line"></div><div class="line">        // 4) Store the response handler for use when the request completes</div><div class="line">        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID</div><div class="line">                                                                                                   success:success</div><div class="line">                                                                                                   failure:failure];</div><div class="line">        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]</div><div class="line">                                                   initWithURLIdentifier:URLIdentifier</div><div class="line">                                                   identifier:mergedTaskIdentifier</div><div class="line">                                                   task:createdTask];</div><div class="line">        [mergedTask addResponseHandler:handler]; // 一个mergedTask添加一个handler，为什么要把handler设计成一个数组呢？</div><div class="line">        self.mergedTasks[URLIdentifier] = mergedTask;</div><div class="line"></div><div class="line">        // 5) Either start the request or enqueue it depending on the current active request count</div><div class="line">        if ([self isActiveRequestCountBelowMaximumLimit]) &#123; // 不到最大并发数，开启新任务</div><div class="line">            [self startMergedTask:mergedTask];</div><div class="line">        &#125; else &#123; // 超出最大并发数，加入缓存队列</div><div class="line">            [self enqueueMergedTask:mergedTask];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        task = mergedTask.task; // createdTask</div><div class="line">    if (task) &#123;</div><div class="line">        return [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task]; // 为task打标签</div><div class="line">    &#125; else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先处理失败的回调，如果失败，抛出失败的request，error，直接返回。<br>成功的话，分三部分处理</p>
<ol>
<li>判断当前task是否已经存在，如果存在，直接获取这个task，并返回。</li>
<li>从缓存里面取，如果已经缓存过，调用成功回调，把缓存的图片返回回去。</li>
<li>如果以上两点都没有的，进行网络请求。这里使用的是AFURLSessionManager里面的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div></pre></td></tr></table></figure>
<p>方法。这个方法的解析参考NSURLSession部分的解析。<br>回调中，这里会判断是否是当前任务URLIdentifier，如果是，继续处理。并分别返回成功失败的回调。<br>处理完之后，这里会将队列任务数量-1，然后开启下一个缓存的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[strongSelf safelyDecrementActiveTaskCount];</div><div class="line">[strongSelf safelyStartNextTaskIfNecessary];</div></pre></td></tr></table></figure>
<p>由于是同步的，所以我们可以获取这个createdTask任务。<br>初始化一个AFImageDownloaderResponseHandler对象，这个对象主要负责成功失败的回调，以及唯一标示每个任务的id。然后添加到AFImageDownloaderMergedTask的对象中，AFImageDownloaderMergedTask类主要作用：统一管理task的标识符，回调对象。主要这里有两个标识符： </p>
<ul>
<li>URLIdentifier：用于标示下载任务唯一。内部使用AFImageDownload使用。</li>
<li>identifier：用于匹配下载任务与完成的处理唯一。外部类使用。</li>
</ul>
<p>然后处理缓存队列，如果没有到最大并发数，开启新任务，如果超出最大并发数，加入缓存队列。</p>
<p>看一下入队，出队的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)enqueueMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123; // 入队： 添加到队列数组中去，所谓的队列和栈，只是数组的顺序而已。</div><div class="line">    switch (self.downloadPrioritizaton) &#123;</div><div class="line">        case AFImageDownloadPrioritizationFIFO:</div><div class="line">            [self.queuedMergedTasks addObject:mergedTask]; // 先进先出，顺序添加到数组</div><div class="line">            break;</div><div class="line">        case AFImageDownloadPrioritizationLIFO:</div><div class="line">            [self.queuedMergedTasks insertObject:mergedTask atIndex:0]; // 先进后出，每次插入到数组第一个位置</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (AFImageDownloaderMergedTask *)dequeueMergedTask &#123; // 出队</div><div class="line">    AFImageDownloaderMergedTask *mergedTask = nil;</div><div class="line">    mergedTask = [self.queuedMergedTasks firstObject];</div><div class="line">    [self.queuedMergedTasks removeObject:mergedTask]; // 从队列里面移除</div><div class="line">    return mergedTask; // 返回最先进入队列的任务，先进先出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入队的设计还是使用的数组，支持先进先出，后进先出两种入队模式。</p>
<h5 id="取消下载任务"><a href="#取消下载任务" class="headerlink" title="取消下载任务"></a>取消下载任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)cancelTaskForImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</div><div class="line">    dispatch_sync(self.synchronizationQueue, ^&#123;</div><div class="line">        NSString *URLIdentifier = imageDownloadReceipt.task.originalRequest.URL.absoluteString;</div><div class="line">        AFImageDownloaderMergedTask *mergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">        NSUInteger index = [mergedTask.responseHandlers indexOfObjectPassingTest:^BOOL(AFImageDownloaderResponseHandler * _Nonnull handler, __unused NSUInteger idx, __unused BOOL * _Nonnull stop) &#123;</div><div class="line">            return handler.uuid == imageDownloadReceipt.receiptID;</div><div class="line">        &#125;];</div><div class="line"></div><div class="line">        if (index != NSNotFound) &#123;</div><div class="line">            AFImageDownloaderResponseHandler *handler = mergedTask.responseHandlers[index];</div><div class="line">            [mergedTask removeResponseHandler:handler];</div><div class="line">            NSString *failureReason = [NSString stringWithFormat:@&quot;ImageDownloader cancelled URL request: %@&quot;,imageDownloadReceipt.task.originalRequest.URL.absoluteString];</div><div class="line">            NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey:failureReason&#125;;</div><div class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorCancelled userInfo:userInfo];</div><div class="line">            if (handler.failureBlock) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    handler.failureBlock(imageDownloadReceipt.task.originalRequest, nil, error);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mergedTask.responseHandlers.count == 0 &amp;&amp; mergedTask.task.state == NSURLSessionTaskStateSuspended) &#123;</div><div class="line">            [mergedTask.task cancel];</div><div class="line">            [self removeMergedTaskWithURLIdentifier:URLIdentifier];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>通过URLIdentifier获取当前mergedTask任务，通过receiptID遍历出当前的这个handler。</li>
<li>将handler从mergedTask中移除，抛出失败的回调。</li>
<li>最后移除当前的这个mergedTask</li>
</ol>
<h1 id="UIButton-AFNetworking"><a href="#UIButton-AFNetworking" class="headerlink" title="UIButton+AFNetworking"></a>UIButton+AFNetworking</h1><p>封装思路跟UIImageView+AFNetworking基本相同，区别在于图片的处理，UIButton分别处理了图片：<br>[self setImage:cachedImage forState:state];<br>背景图片：<br>[self setBackgroundImage:placeholderImage forState:state];<br>已经对不同状态的处理。</p>
<h1 id="UIProgressView-AFNetworking"><a href="#UIProgressView-AFNetworking" class="headerlink" title="UIProgressView+AFNetworking"></a>UIProgressView+AFNetworking</h1><p>支持下载、上传的进度条，主要使用的技术点是KVO。</p>
<p>设置调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)setProgressWithUploadProgressOfTask:(NSURLSessionUploadTask *)task</div><div class="line">                                   animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext];</div><div class="line">    [task addObserver:self forKeyPath:@&quot;countOfBytesSent&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext];</div><div class="line"></div><div class="line">    [self af_setUploadProgressAnimated:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task</div><div class="line">                                     animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];</div><div class="line">    [task addObserver:self forKeyPath:@&quot;countOfBytesReceived&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];</div><div class="line"></div><div class="line">    [self af_setDownloadProgressAnimated:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对上传任务的key：state，countOfBytesSent进行了监听，<br>对下载任务key：state，countOfBytesReceived进行了监听。</p>
<p>支持动画设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (BOOL)af_uploadProgressAnimated &#123;</div><div class="line">    return [(NSNumber *)objc_getAssociatedObject(self, @selector(af_uploadProgressAnimated)) boolValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_setUploadProgressAnimated:(BOOL)animated &#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(af_uploadProgressAnimated), @(animated), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)af_downloadProgressAnimated &#123;</div><div class="line">    return [(NSNumber *)objc_getAssociatedObject(self, @selector(af_downloadProgressAnimated)) boolValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_setDownloadProgressAnimated:(BOOL)animated &#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(af_downloadProgressAnimated), @(animated), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用runtime的关联对象功能，也是蛮拼的，这么一个小的属性的支持。</p>
<p>核心：kvo的监听回调中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSKeyValueObserving</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(__unused NSDictionary *)change</div><div class="line">                       context:(void *)context</div><div class="line">&#123;</div><div class="line">    if (context == AFTaskCountOfBytesSentContext || context == AFTaskCountOfBytesReceivedContext) &#123;</div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</div><div class="line">            if ([object countOfBytesExpectedToSend] &gt; 0) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [self setProgress:[object countOfBytesSent] / ([object countOfBytesExpectedToSend] * 1.0f) animated:self.af_uploadProgressAnimated];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</div><div class="line">            if ([object countOfBytesExpectedToReceive] &gt; 0) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [self setProgress:[object countOfBytesReceived] / ([object countOfBytesExpectedToReceive] * 1.0f) animated:self.af_downloadProgressAnimated];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(state))]) &#123;</div><div class="line">            if ([(NSURLSessionTask *)object state] == NSURLSessionTaskStateCompleted) &#123;</div><div class="line">                @try &#123;</div><div class="line">                    [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(state))];</div><div class="line"></div><div class="line">                    if (context == AFTaskCountOfBytesSentContext) &#123;</div><div class="line">                        [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (context == AFTaskCountOfBytesReceivedContext) &#123;</div><div class="line">                        [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                @catch (NSException * __unused exception) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先对countOfBytesExpectedToSend和countOfBytesExpectedToReceive分别处理：[object countOfBytesSent] / ([object countOfBytesExpectedToSend] <em> 1.0f，[object countOfBytesReceived] / ([object countOfBytesExpectedToReceive] </em> 1.0f)。两个百分比的计算方式不同。</li>
<li><p>再处理state，如果当前状态是完成：NSURLSessionTaskStateCompleted，移除当前的kvo对象。使用kvo的时候注意移除，否则会导致内存泄露。</p>
<h1 id="UIRefreshControl-AFNetworking"><a href="#UIRefreshControl-AFNetworking" class="headerlink" title="UIRefreshControl+AFNetworking"></a>UIRefreshControl+AFNetworking</h1><p>系统的刷新类的支持，使用的是从AFURLSessionManager里抛出的当前task状态通知：AFNetworkingTaskDidResumeNotification，AFNetworkingTaskDidSuspendNotification，AFNetworkingTaskDidCompleteNotification。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> - (void)setRefreshingWithStateOfTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</div><div class="line"></div><div class="line">    [notificationCenter removeObserver:self name:AFNetworkingTaskDidResumeNotification object:nil];</div><div class="line">    [notificationCenter removeObserver:self name:AFNetworkingTaskDidSuspendNotification object:nil];</div><div class="line">    [notificationCenter removeObserver:self name:AFNetworkingTaskDidCompleteNotification object:nil];</div><div class="line"></div><div class="line">    if (task) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wreceiver-is-weak&quot;</div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-repeated-use-of-weak&quot;</div><div class="line">        if (task.state == NSURLSessionTaskStateRunning) &#123;</div><div class="line">            [self.refreshControl beginRefreshing];</div><div class="line"></div><div class="line">            [notificationCenter addObserver:self selector:@selector(af_beginRefreshing) name:AFNetworkingTaskDidResumeNotification object:task];</div><div class="line">            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingTaskDidCompleteNotification object:task];</div><div class="line">            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingTaskDidSuspendNotification object:task];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self.refreshControl endRefreshing];</div><div class="line">        &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p> 主要在resume状态的时候进行刷新动画，在complete、suspend状态下停止刷新动画。</p>
<h1 id="UIActivityIndicatorView-AFNetworking"><a href="#UIActivityIndicatorView-AFNetworking" class="headerlink" title="UIActivityIndicatorView+AFNetworking"></a>UIActivityIndicatorView+AFNetworking</h1><p> 跟UIRefreshControl封装思路一样。</p>
<h1 id="UIWebView-AFNetworking"><a href="#UIWebView-AFNetworking" class="headerlink" title="UIWebView+AFNetworking"></a>UIWebView+AFNetworking</h1><p>支持UIWebView的下载，网络部分使用的是NSURLSession部分的AFHTTPSessionManager的get方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (void)loadRequest:(NSURLRequest *)request</div><div class="line">           MIMEType:(NSString *)MIMEType</div><div class="line">   textEncodingName:(NSString *)textEncodingName</div><div class="line">           progress:(NSProgress * _Nullable __autoreleasing * _Nullable)progress</div><div class="line">            success:(NSData * (^)(NSHTTPURLResponse *response, NSData *data))success</div><div class="line">            failure:(void (^)(NSError *error))failure</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if (self.af_URLSessionTask.state == NSURLSessionTaskStateRunning || self.af_URLSessionTask.state == NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [self.af_URLSessionTask cancel];</div><div class="line">    &#125;</div><div class="line">    self.af_URLSessionTask = nil;</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    NSURLSessionDataTask *dataTask;</div><div class="line">    dataTask = [self.sessionManager</div><div class="line">            GET:request.URL.absoluteString</div><div class="line">            parameters:nil</div><div class="line">            progress:nil</div><div class="line">            success:^(NSURLSessionDataTask * _Nonnull task, id  _Nonnull responseObject) &#123;</div><div class="line">                __strong __typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">                if (success) &#123;</div><div class="line">                    success((NSHTTPURLResponse *)task.response, responseObject);</div><div class="line">                &#125;</div><div class="line">                [strongSelf loadData:responseObject MIMEType:MIMEType textEncodingName:textEncodingName baseURL:[task.currentRequest URL]];</div><div class="line"></div><div class="line">                if ([strongSelf.delegate respondsToSelector:@selector(webViewDidStartLoad:)]) &#123;</div><div class="line">                    [strongSelf.delegate webViewDidFinishLoad:strongSelf];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123;</div><div class="line">                if (failure) &#123;</div><div class="line">                    failure(error);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">    self.af_URLSessionTask = dataTask;</div><div class="line">    if (progress != nil) &#123;</div><div class="line">        *progress = [self.sessionManager downloadProgressForTask:dataTask];</div><div class="line">    &#125;</div><div class="line">    [self.af_URLSessionTask resume];</div><div class="line"></div><div class="line">    if ([self.delegate respondsToSelector:@selector(webViewDidStartLoad:)]) &#123;</div><div class="line">        [self.delegate webViewDidStartLoad:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求完成后， 如果成功会：<br>1）回调成功的数据<br>2）当前webview加载成功的数据<br>3）使用代理触发webViewDidStartLoad回调。</p>
<p>失败直接回调回去失败的error。</p>
<p>请求开始后，立刻触发webViewDidStartLoad的回调。对WebView的回调支持比较好。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MJRefresh源码解析]]></title>
      <url>http://semyonxu.com/2016/10/09/MJRefresh%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本文主要解析一下MJRefresh这个刷新框架的封装思路以及一些技术在实际中的运用。</p>
<p>当前版本：v3.1.12</p>
<p>github地址：<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">https://github.com/CoderMJLee/MJRefresh</a></p>
<p>首先看下结构图<br><img src="https://camo.githubusercontent.com/4a86d398d981df5dc845042b92c6d785d0d486b4/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67" alt=""></p>
<p>图有点大，大家可以点这里单独看：<a href="https://camo.githubusercontent.com/4a86d398d981df5dc845042b92c6d785d0d486b4/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67" target="_blank" rel="external">结构图</a></p>
<p>接下来我们顺着这个结构来逐步解析封装的思路。</p>
<a id="more"></a>
<h1 id="MJRefreshComponent基类"><a href="#MJRefreshComponent基类" class="headerlink" title="MJRefreshComponent基类"></a>MJRefreshComponent基类</h1><p>基类里面为我们捕获了当前的父view（UITableView、UICollectionVeiw等），然后使用KVO为我们做了一些滑动操作属性的监听，具体的处理需要交给子类去实现。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">    if (self = [super initWithFrame:frame]) &#123;</div><div class="line">        // 准备工作</div><div class="line">        [self prepare];</div><div class="line">        </div><div class="line">        // 默认是普通状态</div><div class="line">        self.state = MJRefreshStateIdle;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepare</div><div class="line">&#123;</div><div class="line">    // 基本属性</div><div class="line">    self.autoresizingMask = UIViewAutoresizingFlexibleWidth;</div><div class="line">    self.backgroundColor = [UIColor clearColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)layoutSubviews</div><div class="line">&#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    </div><div class="line">    [self placeSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubviews&#123;&#125;</div></pre></td></tr></table></figure>
<p>这里设计了两个方法，分别交给子类去使用。</p>
<ul>
<li>一个是preppare方法，触发是通过initWithFrame，这个方法是作用就是初始化一些基本的属性、状态等，倾向于数据方面的初始化。</li>
<li>一个是placeSubviews方法，触发是通过layoutSubviews。关于layoutSubviews的触发条件不清楚的同学可以Google一下。这个方法倾向于处理UI方面。</li>
</ul>
<h2 id="属性方法的转换处理"><a href="#属性方法的转换处理" class="headerlink" title="属性方法的转换处理"></a>属性方法的转换处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</div><div class="line">&#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    </div><div class="line">    // 如果不是UIScrollView，不做任何事情</div><div class="line">    if (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[UIScrollView class]]) return;</div><div class="line">    </div><div class="line">    // 旧的父控件移除监听</div><div class="line">    [self removeObservers];</div><div class="line">    </div><div class="line">    if (newSuperview) &#123; // 新的父控件</div><div class="line">        // 设置宽度</div><div class="line">        self.mj_w = newSuperview.mj_w;</div><div class="line">        // 设置位置</div><div class="line">        self.mj_x = 0;</div><div class="line">        </div><div class="line">        // 记录UIScrollView</div><div class="line">        _scrollView = (UIScrollView *)newSuperview;</div><div class="line">        // 设置永远支持垂直弹簧效果</div><div class="line">        _scrollView.alwaysBounceVertical = YES;</div><div class="line">        // 记录UIScrollView最开始的contentInset</div><div class="line">        _scrollViewOriginalInset = _scrollView.contentInset;</div><div class="line">        </div><div class="line">        // 添加监听</div><div class="line">        [self addObservers];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)drawRect:(CGRect)rect</div><div class="line">&#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    </div><div class="line">    if (self.state == MJRefreshStateWillRefresh) &#123;</div><div class="line">        // 预防view还没显示出来就调用了beginRefreshing</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - KVO监听</div><div class="line">- (void)addObservers</div><div class="line">&#123;</div><div class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</div><div class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil];</div><div class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil];</div><div class="line">    self.pan = self.scrollView.panGestureRecognizer;</div><div class="line">    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeObservers</div><div class="line">&#123;</div><div class="line">    [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentOffset];</div><div class="line">    [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentSize];;</div><div class="line">    [self.pan removeObserver:self forKeyPath:MJRefreshKeyPathPanState];</div><div class="line">    self.pan = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</div><div class="line">&#123;</div><div class="line">    // 遇到这些情况就直接返回</div><div class="line">    if (!self.userInteractionEnabled) return;</div><div class="line">    </div><div class="line">    // 这个就算看不见也需要处理</div><div class="line">    if ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [self scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 看不见</div><div class="line">    if (self.hidden) return;</div><div class="line">    if ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [self scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; else if ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [self scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#123;&#125;</div><div class="line">- (void)scrollViewContentSizeDidChange:(NSDictionary *)change&#123;&#125;</div><div class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change&#123;&#125;</div></pre></td></tr></table></figure>
<p>此处关键的切入点是继承父类的willMoveToSuperview方法，这个方法在刷新控件将要加载到父类的时候调用，这样我们可以获取到父类。然后如果是新的父类的话，首先初始化一些变量属性，然后添加KVO，KVO在这里的作用是监听@”contentOffset”，@”contentSize”以及@”state”属性的变化，来对header，footer做响应状态的处理。</p>
<p>此处为子类抛出了三个响应的方法（scrollViewContentOffsetDidChange…）可以继承下来，实现不同的功能。</p>
<h2 id="刷新状态的处理"><a href="#刷新状态的处理" class="headerlink" title="刷新状态的处理"></a>刷新状态的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#pragma mark 进入刷新状态</div><div class="line">- (void)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        self.alpha = 1.0;</div><div class="line">    &#125;];</div><div class="line">    self.pullingPercent = 1.0;</div><div class="line">    // 只要正在刷新，就完全显示</div><div class="line">    if (self.window) &#123;</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; else &#123;</div><div class="line">        self.state = MJRefreshStateWillRefresh;</div><div class="line">        // 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</div><div class="line">        [self setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 结束刷新状态</div><div class="line">- (void)endRefreshing</div><div class="line">&#123;</div><div class="line">    self.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 是否正在刷新</div><div class="line">- (BOOL)isRefreshing</div><div class="line">&#123;</div><div class="line">    return self.state == MJRefreshStateRefreshing || self.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始结束刷新状态和判断是不是正在刷新状态，其中除了动画外，self.state是个很重要的属性，几乎所有的状态变化都是state的set方法里面实现，下面我们会在子类中解读。</p>
<h2 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)executeRefreshingCallback</div><div class="line">&#123;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        if (self.refreshingBlock) &#123;</div><div class="line">            self.refreshingBlock();</div><div class="line">        &#125;</div><div class="line">        if ([self.refreshingTarget respondsToSelector:self.refreshingAction]) &#123;</div><div class="line">            MJRefreshMsgSend(MJRefreshMsgTarget(self.refreshingTarget), self.refreshingAction, self);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于回调方法，这里支持block和target:selecteor:两种。此处target方式的调用是用的封装的runtime宏，我们知道方法的调用实际上就是转换成objc_msgSend方法。</p>
<p>这种封装对于我们也是有借鉴意义的，如果写公共的框架，我们也是应该支持多种类型的回调的。最好再加一个delegate的方法。</p>
<h1 id="Header控件"><a href="#Header控件" class="headerlink" title="Header控件"></a>Header控件</h1><p>下面一步一步解析继承的子类的功能以及职责。</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p>继承自MJRefreshComponent基础父类。</p>
<p>本类的主要职责：<br>实现基本的页面刷新逻辑，负责解析出各个状态，然后对每个状态进行处理。（简单点说就是只是逻辑的实现，简单下拉，然后scrollView头部留出一点空，等待刷新完成，完成后空白消失）。</p>
<p>这里对contentoffset的状态的变化进行监听，并对结果处理成四种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MJRefreshStateIdle = 1, /** 普通闲置状态 */MJRefreshStatePulling, /** 松开就可以进行刷新的状态 */MJRefreshStateRefreshing, /** 正在刷新中的状态 */MJRefreshStateWillRefresh, /** 即将刷新的状态 */</div><div class="line">mj</div></pre></td></tr></table></figure>
<h3 id="先解读一下初始化方法"><a href="#先解读一下初始化方法" class="headerlink" title="先解读一下初始化方法:"></a>先解读一下初始化方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock &#123;</div><div class="line">    MJRefreshHeader *cmp = [[self alloc] init];</div><div class="line">    cmp.refreshingBlock = refreshingBlock;</div><div class="line">    return cmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里封装了一个类方法，方便用户调用，并获取刷新的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)prepare &#123;</div><div class="line">    [super prepare];</div><div class="line">    self.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</div><div class="line">    self.mj_h = MJRefreshHeaderHeight;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubViews &#123;</div><div class="line">    [super placeSubViews];</div><div class="line">    </div><div class="line">    // 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</div><div class="line">    self.mj_y =  - self.mj_h - self.ignoredScrollViewContentInsetTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后prepare就是跟之前说的一样，设置一下初始化值数据。而placeSubViews这里更新一下UI。</p>
<h3 id="通过contentofffset转换刷新的状态"><a href="#通过contentofffset转换刷新的状态" class="headerlink" title="通过contentofffset转换刷新的状态"></a>通过contentofffset转换刷新的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentOffsetDidChange:change];</div><div class="line">    </div><div class="line">    // 在刷新的refreshing状态</div><div class="line">    if (self.state == MJRefreshStateRefreshing) &#123;</div><div class="line">        if (self.window == nil) return;</div><div class="line">        </div><div class="line">        // sectionheader停留解决</div><div class="line">        CGFloat insetT = - self.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</div><div class="line">        insetT = insetT &gt; self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT;</div><div class="line">        self.scrollView.mj_insetT = insetT;</div><div class="line">        </div><div class="line">        self.insetTDelta = _scrollViewOriginalInset.top - insetT;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 跳转到下一个控制器时，contentInset可能会变</div><div class="line">     _scrollViewOriginalInset = self.scrollView.contentInset;</div><div class="line">    </div><div class="line">    // 当前的contentOffset</div><div class="line">    CGFloat offsetY = self.scrollView.mj_offsetY;</div><div class="line">    // 头部控件刚好出现的offsetY</div><div class="line">    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;</div><div class="line">    </div><div class="line">    // 如果是向上滚动到看不见头部控件，直接返回</div><div class="line">    // &gt;= -&gt; &gt;</div><div class="line">    if (offsetY &gt; happenOffsetY) return;</div><div class="line">    </div><div class="line">    // 普通 和 即将刷新 的临界点</div><div class="line">    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;</div><div class="line">    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;</div><div class="line">    </div><div class="line">    if (self.scrollView.isDragging) &#123; // 如果正在拖拽</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">        if (self.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</div><div class="line">            // 转为即将刷新状态</div><div class="line">            self.state = MJRefreshStatePulling;</div><div class="line">        &#125; else if (self.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</div><div class="line">            // 转为普通状态</div><div class="line">            self.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (self.state == MJRefreshStatePulling) &#123;// 即将刷新 &amp;&amp; 手松开</div><div class="line">        // 开始刷新</div><div class="line">        [self beginRefreshing];</div><div class="line">    &#125; else if (pullingPercent &lt; 1) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 根据状态做事情</div><div class="line">    if (state == MJRefreshStateIdle) &#123;</div><div class="line">        if (oldState != MJRefreshStateRefreshing) return;</div><div class="line">        </div><div class="line">        // 保存刷新时间</div><div class="line">        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];</div><div class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</div><div class="line">        </div><div class="line">        // 恢复inset和offset</div><div class="line">        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">            self.scrollView.mj_insetT += self.insetTDelta;</div><div class="line">            </div><div class="line">            // 自动调整透明度</div><div class="line">            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;</div><div class="line">        &#125; completion:^(BOOL finished) &#123;</div><div class="line">            self.pullingPercent = 0.0;</div><div class="line">            </div><div class="line">            if (self.endRefreshingCompletionBlock) &#123;</div><div class="line">                self.endRefreshingCompletionBlock();</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125; else if (state == MJRefreshStateRefreshing) &#123;</div><div class="line">         dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;</div><div class="line">                // 增加滚动区域top</div><div class="line">                self.scrollView.mj_insetT = top;</div><div class="line">                // 设置滚动位置</div><div class="line">                [self.scrollView setContentOffset:CGPointMake(0, -top) animated:NO];</div><div class="line">            &#125; completion:^(BOOL finished) &#123;</div><div class="line">                [self executeRefreshingCallback];</div><div class="line">            &#125;];</div><div class="line">         &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们一起解读一下这个刷新的过程。</p>
<p>首先，我们下拉刷新的时候，当前状态肯定是MJRefreshStateIdle（啰嗦一下：这个在MJRefreshComponent中initwithframe中有设置：self.state = MJRefreshStateIdle）。那么直接走下面的if判断，满足第一个if，当前操作是isDragging。这里计算出了拖拽所占的比例，也就下拉的百分比。</p>
<p>如果是MJRefreshStateIdle普通状态并超出下拉超出header的高度，那么状态立刻转换为MJRefreshStatePulling拖动中。</p>
<p>此时如果没有继续下拉，而是松手，那么就会走else if，立刻把状态转换回MJRefreshStateIdle。</p>
<p>此时如果继续下拉，那么走下面这个else if (self.state == MJRefreshStatePulling)，立刻调用beginRefreshing开始刷新。其实也就是把状态转换为MJRefreshStateRefreshing.看一下父类中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)beginRefreshing &#123;</div><div class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        self.alpha = 1.0;</div><div class="line">    &#125;];</div><div class="line">    self.pullingPercent = 1.0;</div><div class="line">    if (self.window) &#123;</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (self.state != MJRefreshStateRefreshing) &#123;</div><div class="line">            self.state = MJRefreshStateWillRefresh;</div><div class="line">            [self setNeedsDisplay]; // 继续调用drawrect，这样延时，加了个willrefresh的state 意欲：预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里做了一个有时间长度的动画，多加了一个willRefresh的状态，我的理解是为了防止从另一个页面返回的时候self.window为空的时候，突然刷新会崩溃，需要一个状态来过渡。当然了当前的下拉比例是百分百了。</p>
<p>设置state = MJRefreshStateRefreshing，会调用state的setStaus方法，我们看到，这里直接对页面进行了header高度的偏移，使得整个header显示出来，然后在完成动画的时候回调回去，我们可以进行一些网络请求。</p>
<p>此时状态是MJRefreshStateRefreshing，继续监听会接着走第一个if：if (self.state == MJRefreshStateRefreshing)，这里重新设置了insetTop，也就是页面偏移到整个header的高度，好像跟setState有点重复。记录了一下insetTDelta值：：初始的top - insetTop, 这个值是刷新完恢复header位置用的。当然了，这里也是为了兼容，我们使用MJ之前设置过了insetTop，这里是在之前设置过的insetTop基础上再偏移的。然后就是return，下面的代码不会再执行。</p>
<p>直到我们的网络请求完成，触发endRefreshing方法，那么此时的状态会改变回去MJRefreshStateIdle。然后处理就是保存一下刷新的时间，通过这个insetTDelta恢复insetTop为原始值，完成后执行endRefreshingCompletionBlock回调。</p>
<h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>此部分继承自MJRefreshHeader，主要就是处理状态文字，不同状态下的提示文字是不同的。系统给我们提供了多语言版本的默认提示语，当然我们也可以自己设置我们的个性提示语：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setTitle:(NSString *)title forState:(MJRefreshState)state &#123;</div><div class="line">    if (title == nil) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.stateTitles[@(state)] = title;</div><div class="line">    self.stateLabel.text = self.stateTitles[@(self.state)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（不得不吐槽一下小码哥的代码格式，有的花括号跟方法一行，有的另起一行。对于有些洁癖的看官只好忍一下了。）<br>这里是用的state枚举值当做key来存的stateTitle值，使用的是字典。</p>
<p>还是使用这两个初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (void)prepare</div><div class="line">&#123;</div><div class="line">    [super prepare];</div><div class="line">    </div><div class="line">    // 初始化间距</div><div class="line">    self.labelLeftInset = MJRefreshLabelLeftInset;</div><div class="line">    </div><div class="line">    // 初始化文字</div><div class="line">    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</div><div class="line">    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</div><div class="line">    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubviews</div><div class="line">&#123;</div><div class="line">    [super placeSubviews];</div><div class="line">    </div><div class="line">    if (self.stateLabel.hidden) return;</div><div class="line">    </div><div class="line">    BOOL noConstrainsOnStatusLabel = self.stateLabel.constraints.count == 0;</div><div class="line">    </div><div class="line">    if (self.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        // 状态</div><div class="line">        if (noConstrainsOnStatusLabel) self.stateLabel.frame = self.bounds;</div><div class="line">    &#125; else &#123;</div><div class="line">        CGFloat stateLabelH = self.mj_h * 0.5;</div><div class="line">        // 状态</div><div class="line">        if (noConstrainsOnStatusLabel) &#123;</div><div class="line">            self.stateLabel.mj_x = 0;</div><div class="line">            self.stateLabel.mj_y = 0;</div><div class="line">            self.stateLabel.mj_w = self.mj_w;</div><div class="line">            self.stateLabel.mj_h = stateLabelH;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 更新时间</div><div class="line">        if (self.lastUpdatedTimeLabel.constraints.count == 0) &#123;</div><div class="line">            self.lastUpdatedTimeLabel.mj_x = 0;</div><div class="line">            self.lastUpdatedTimeLabel.mj_y = stateLabelH;</div><div class="line">            self.lastUpdatedTimeLabel.mj_w = self.mj_w;</div><div class="line">            self.lastUpdatedTimeLabel.mj_h = self.mj_h - self.lastUpdatedTimeLabel.mj_y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prepare方法默认设置了状态文字，placeSubviews方法对文字Label进行处理。这里一共两个label，一个状态文字label，一个上次刷新时间label。并对隐藏一个或者全部做了页面布局的处理。</p>
<p>最后还是通过state的set方法来更新状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 设置状态文字</div><div class="line">    self.stateLabel.text = self.stateTitles[@(state)];</div><div class="line">    </div><div class="line">    // 重新设置key（重新显示时间）</div><div class="line">    self.lastUpdatedTimeKey = self.lastUpdatedTimeKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不得不说setState方法是核心处理方法，很重要。</p>
<h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><p>此部分继承自MJRefreshStateHeader，作用就是在添加了文字基础上，添加了动画部分，包括刷新的菊花和箭头。</p>
<p>箭头的添加方式跟文本添加是一样的，添加在了文本的左边，如果文本隐藏的话，箭头就居中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 根据状态做事情</div><div class="line">    if (state == MJRefreshStateIdle) &#123;</div><div class="line">        if (oldState == MJRefreshStateRefreshing) &#123;</div><div class="line">            self.arrowView.transform = CGAffineTransformIdentity;</div><div class="line">            </div><div class="line">            [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">                self.loadingView.alpha = 0.0;</div><div class="line">            &#125; completion:^(BOOL finished) &#123;</div><div class="line">                // 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</div><div class="line">                if (self.state != MJRefreshStateIdle) return;</div><div class="line">                </div><div class="line">                self.loadingView.alpha = 1.0;</div><div class="line">                [self.loadingView stopAnimating];</div><div class="line">                self.arrowView.hidden = NO;</div><div class="line">            &#125;];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self.loadingView stopAnimating];</div><div class="line">            self.arrowView.hidden = NO;</div><div class="line">            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                self.arrowView.transform = CGAffineTransformIdentity;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125; else if (state == MJRefreshStatePulling) &#123;</div><div class="line">        [self.loadingView stopAnimating];</div><div class="line">        self.arrowView.hidden = NO;</div><div class="line">        [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">            self.arrowView.transform = CGAffineTransformMakeRotation(0.000001 - M_PI);</div><div class="line">        &#125;];</div><div class="line">    &#125; else if (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        self.loadingView.alpha = 1.0; // 防止refreshing -&gt; idle的动画完毕动作没有被执行</div><div class="line">        [self.loadingView startAnimating];</div><div class="line">        self.arrowView.hidden = YES;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在state的set方法中，添加了一个箭头的旋转动画。</p>
<h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>与MJRefreshNormalHeader类似，继承自MJRefreshStateHeader。是在文本类的基础上添加的带有普通动画的子类。</p>
<p>只不过这里加了拖动和刷新中的动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 根据状态做事情</div><div class="line">    if (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</div><div class="line">        NSArray *images = self.stateImages[@(state)];</div><div class="line">        if (images.count == 0) return;</div><div class="line">        </div><div class="line">        [self.gifView stopAnimating];</div><div class="line">        if (images.count == 1) &#123; // 单张图片</div><div class="line">            self.gifView.image = [images lastObject];</div><div class="line">        &#125; else &#123; // 多张图片</div><div class="line">            self.gifView.animationImages = images;</div><div class="line">            self.gifView.animationDuration = [self.stateDurations[@(state)] doubleValue];</div><div class="line">            [self.gifView startAnimating];</div><div class="line">        &#125;</div><div class="line">    &#125; else if (state == MJRefreshStateIdle) &#123;</div><div class="line">        [self.gifView stopAnimating];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用的是UIImageView的自带图片动画功能。我们可以直接传入图片数组来实现动画。当然如果不能满足我们的需求，我们是可以自己封装这一层，替换为自己的动画。</p>
<h1 id="Footer控件"><a href="#Footer控件" class="headerlink" title="Footer控件"></a>Footer控件</h1><p>Footer封装了两个分支子类：</p>
<ul>
<li>BackFooter(会回弹到底部的上拉刷新控件)</li>
<li>AutoFooter(会自动刷新的上拉刷新控件)</li>
</ul>
<h2 id="MJRefreshFooter"><a href="#MJRefreshFooter" class="headerlink" title="MJRefreshFooter"></a>MJRefreshFooter</h2><p>基础父类，是两种footer的共同父类。此处比Header的父类要简单一些，因为下面两个分支的逻辑处理还是不一样的，所以这里就简单的做了一些初始化工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</div><div class="line">&#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    </div><div class="line">    if (newSuperview) &#123;</div><div class="line">        // 监听scrollView数据的变化</div><div class="line">        if ([self.scrollView isKindOfClass:[UITableView class]] || [self.scrollView isKindOfClass:[UICollectionView class]]) &#123;</div><div class="line">            [self.scrollView setMj_reloadDataBlock:^(NSInteger totalDataCount) &#123;</div><div class="line">                if (self.isAutomaticallyHidden) &#123;</div><div class="line">                    self.hidden = (totalDataCount == 0);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以设置自动隐藏Footer。前提是tableview或collectionview的数据源为空。</p>
<h2 id="AutoFooter"><a href="#AutoFooter" class="headerlink" title="AutoFooter"></a>AutoFooter</h2><p>自动上拉加载类。滑动到底部触发刷新动作，无需上拉操作。</p>
<h3 id="MJRefreshAutoFooter"><a href="#MJRefreshAutoFooter" class="headerlink" title="MJRefreshAutoFooter"></a>MJRefreshAutoFooter</h3><p>类似于MJRefreshHeader类的功能，将UI效果逻辑处理出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentOffsetDidChange:change];</div><div class="line">    </div><div class="line">    if (self.state != MJRefreshStateIdle || !self.automaticallyRefresh || self.mj_y == 0) return;</div><div class="line">    </div><div class="line">    if (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) &#123; // 内容超过一个屏幕</div><div class="line">        // 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理</div><div class="line">        if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH - _scrollView.mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - self.mj_h) &#123; </div><div class="line">       		 /*</div><div class="line">        	// contentsize Height + bottom = scrollview content 全部展示高度。    注意此处的self.hegiht 包含在bottom里面</div><div class="line">            // _scrollView.mj_contentH +  _scrollView.mj_insetB - _scrollView.mj_h - self.mj_h * (1 - self.triggerAutomaticallyRefreshPercent)  </div><div class="line">             // if  self.triggerAutomaticallyRefreshPercent = 1, 跟下面的 第二中情况是一样的。 只是兼容了一下 可以显示self的多少比例，就刷新而已。 其实此处默认也是1.  但是这个方法比下面的方法，提前回调。呵呵。</div><div class="line">            // 这个方法跟下面的方法区别在于，下面的方法需要是手松开的情况下，达到临界值，而这个方法是不需要的，也就是条件更宽松。其实，如果手势滑动到底部情况下，这个方法，和下面的方法的处理是一样的。效果也是一样的。</div><div class="line">            */</div><div class="line">            // 防止手松开时连续调用</div><div class="line">            CGPoint old = [change[@&quot;old&quot;] CGPointValue];</div><div class="line">            CGPoint new = [change[@&quot;new&quot;] CGPointValue];</div><div class="line">            if (new.y &lt;= old.y) return;</div><div class="line">            </div><div class="line">            // 当底部刷新控件完全出现时，才刷新</div><div class="line">            [self beginRefreshing];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewPanStateDidChange:change];</div><div class="line">    </div><div class="line">    if (self.state != MJRefreshStateIdle) return;</div><div class="line">    </div><div class="line">    if (_scrollView.panGestureRecognizer.state == UIGestureRecognizerStateEnded) &#123;// 手松开</div><div class="line">        if (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;= _scrollView.mj_h) &#123;  // 不够一个屏幕</div><div class="line">            if (_scrollView.mj_offsetY &gt;= - _scrollView.mj_insetT) &#123; // 向上拽, 拽的浮度需要大于top的值 没有设置的话此处是mj_insetT = 0,注意此处的mj_offsetY已经默认是加了初始top的offset。 比如设置top 100 ，此处offset = -100 ，只要向上滑动一点，就可以执行下面的刷新。</div><div class="line">                [self beginRefreshing];</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123; // 超出一个屏幕, // 这个是需要拖一下。再加载， 正常情况下，下面这个开始加载是不会走的，只有设置automaticallyRefresh = NO 才会走这个。</div><div class="line">            if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) &#123; // 也就是比偏移量比contentH + Bottom 整个scrollview的显示内容 - scrollview的height还有大。 相等是到底部，大于就是有个拖动手势。</div><div class="line">                [self beginRefreshing];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里处理了contentOffset的变化以及Pan手势的改变状态回调。</p>
<h3 id="MJRefreshAutoStateFooter"><a href="#MJRefreshAutoStateFooter" class="headerlink" title="MJRefreshAutoStateFooter"></a>MJRefreshAutoStateFooter</h3><p>封装思路类似于MJRefreshStateHeader，不再赘述。</p>
<h3 id="MJRefreshAutoNormalFooter"><a href="#MJRefreshAutoNormalFooter" class="headerlink" title="MJRefreshAutoNormalFooter"></a>MJRefreshAutoNormalFooter</h3><p>封装思路类似于MJRefreshNormalHeader，不再赘述。</p>
<h3 id="MJRefreshAutoGifFooter"><a href="#MJRefreshAutoGifFooter" class="headerlink" title="MJRefreshAutoGifFooter"></a>MJRefreshAutoGifFooter</h3><p>封装思路类似于MJRefreshGifHeader，不再赘述。</p>
<h2 id="BackFooter"><a href="#BackFooter" class="headerlink" title="BackFooter"></a>BackFooter</h2><p>跟Header的封装思路是一样的，需要上拉才会触发刷新动作。</p>
<h3 id="MJRefreshBackFooter"><a href="#MJRefreshBackFooter" class="headerlink" title="MJRefreshBackFooter"></a>MJRefreshBackFooter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentOffsetDidChange:change];</div><div class="line">    </div><div class="line">    // 如果正在刷新，直接返回</div><div class="line">    if (self.state == MJRefreshStateRefreshing) return;</div><div class="line">    </div><div class="line">    _scrollViewOriginalInset = self.scrollView.contentInset;</div><div class="line">    </div><div class="line">    // 当前的contentOffset</div><div class="line">    CGFloat currentOffsetY = self.scrollView.mj_offsetY;</div><div class="line">    // 尾部控件刚好出现的offsetY</div><div class="line">    CGFloat happenOffsetY = [self happenOffsetY];</div><div class="line">    // 如果是向下滚动到看不见尾部控件，直接返回</div><div class="line">    if (currentOffsetY &lt;= happenOffsetY) return;</div><div class="line">    </div><div class="line">    CGFloat pullingPercent = (currentOffsetY - happenOffsetY) / self.mj_h;</div><div class="line">    </div><div class="line">    // 如果已全部加载，仅设置pullingPercent，然后返回</div><div class="line">    if (self.state == MJRefreshStateNoMoreData) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (self.scrollView.isDragging) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">        // 普通 和 即将刷新 的临界点</div><div class="line">        CGFloat normal2pullingOffsetY = happenOffsetY + self.mj_h;</div><div class="line">        </div><div class="line">        if (self.state == MJRefreshStateIdle &amp;&amp; currentOffsetY &gt; normal2pullingOffsetY) &#123;</div><div class="line">            // 转为即将刷新状态</div><div class="line">            self.state = MJRefreshStatePulling;</div><div class="line">        &#125; else if (self.state == MJRefreshStatePulling &amp;&amp; currentOffsetY &lt;= normal2pullingOffsetY) &#123;</div><div class="line">            // 转为普通状态</div><div class="line">            self.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (self.state == MJRefreshStatePulling) &#123;// 即将刷新 &amp;&amp; 手松开</div><div class="line">        // 开始刷新</div><div class="line">        [self beginRefreshing];</div><div class="line">    &#125; else if (pullingPercent &lt; 1) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewContentSizeDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentSizeDidChange:change];</div><div class="line">    </div><div class="line">    // 内容的高度</div><div class="line">    CGFloat contentHeight = self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;</div><div class="line">    // 表格的高度</div><div class="line">    CGFloat scrollHeight = self.scrollView.mj_h - self.scrollViewOriginalInset.top - self.scrollViewOriginalInset.bottom + self.ignoredScrollViewContentInsetBottom;</div><div class="line">    // 设置位置和尺寸</div><div class="line">    self.mj_y = MAX(contentHeight, scrollHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比之后，我们发现跟Header的思路基本一致。</p>
<h3 id="MJRefreshBackStateFooter"><a href="#MJRefreshBackStateFooter" class="headerlink" title="MJRefreshBackStateFooter"></a>MJRefreshBackStateFooter</h3><p>封装思路类似于MJRefreshStateHeader，不再赘述。</p>
<h3 id="MJRefreshBackNormalFooter"><a href="#MJRefreshBackNormalFooter" class="headerlink" title="MJRefreshBackNormalFooter"></a>MJRefreshBackNormalFooter</h3><p>封装思路类似于MJRefreshNormalHeader，不再赘述。</p>
<h3 id="MJRefreshBackGifFooter"><a href="#MJRefreshBackGifFooter" class="headerlink" title="MJRefreshBackGifFooter"></a>MJRefreshBackGifFooter</h3><p>封装思路类似于MJRefreshGifHeader，不再赘述。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Serialization]]></title>
      <url>http://semyonxu.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSerialization/</url>
      <content type="html"><![CDATA[<p>本部分主要的作用：网络通信信息序列化/反序列化</p>
<h1 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h1><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><p>负责参数转换成NSMutableURLRequest类型，进行网络请求。</p>
<ol>
<li>构建普通请求：格式化请求参数，生成HTTP Header</li>
<li>构建multipart请求</li>
</ol>
<h2 id="类关系："><a href="#类关系：" class="headerlink" title="类关系："></a>类关系：</h2><p>父类：</p>
<ul>
<li>AFHTTPRequestSerializer,二进制格式（query字符串转换成二进制）</li>
</ul>
<p>子类：</p>
<ul>
<li>AFJSONRequestSerializer,Json格式（Json序列化成NSData类型）</li>
<li>AFPropertyListRequestSerializer，Plist（一种特殊的XML，解析起来相对容易）<a id="more"></a>
</li>
</ul>
<h2 id="封装思路："><a href="#封装思路：" class="headerlink" title="封装思路："></a>封装思路：</h2><p>所有类遵循一个协议AFURLRequestSerialization，协议中一个非必须实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullableNSURLRequest*)requestBySerializingRequest:(NSURLRequest*)request</div><div class="line">                                withParameters:(nullableid)parameters</div><div class="line">                                   error:(NSError* _Nullable__autoreleasing *)error NS_SWIFT_NOTHROW;</div></pre></td></tr></table></figure>
<p>父类AFHTTPRequestSerializer中提供外部调用接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest*)requestWithMethod:(NSString*)method</div><div class="line">                                 URLString:(NSString*)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError*__autoreleasing*)error</div></pre></td></tr></table></figure>
<p>在这个方法中调用协议方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutableRequest = [[selfrequestBySerializingRequest:mutableRequestwithParameters:parameterserror:error]mutableCopy];</div></pre></td></tr></table></figure>
<p>而这个方法的实现是父类以及各个子类分别实现。所以，此处self如果是AFHTTPRequestSerializer那么走AFHTTPRequestSerializer类下的实现，如果是<br>AFJSONRequestSerializer，那么走AFJSONRequestSerializer类下的实现。然后再分别实现这个方法不同功能的实现。</p>
<p>下面看一下各个类不同职能分别的实现：</p>
<p>AFURLRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [requestmutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeadersenumerateKeysAndObjectsUsingBlock:^(id field,id value, BOOL *__unused stop) &#123;</div><div class="line">        if (![requestvalueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:valueforHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSString *query =nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                returnnil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                caseAFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURIcontainsObject:[[request HTTPMethod]uppercaseString]]) &#123; //普通GET，HEAD等，参数直接拼接在url后面用&amp;分开</div><div class="line">        if (query &amp;&amp; query.length &gt;0) &#123;</div><div class="line">            mutableRequest.URL = [NSURLURLWithString:[[mutableRequest.URLabsoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequestvalueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot;forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[querydataUsingEncoding:self.stringEncoding]];// 普通的POST请求参数，直接转换成NSData设置到HTTP的body中。</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到AFNetworking对于GET，POST请求参数的处理，一个是直接拼接在URL上面，一个是设置在HTTPBody里面。</p>
<p>其中，HTTPMethodsEncodingParametersInURI的初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil]; // 支持GET，HEAD，DELETE</div></pre></td></tr></table></figure>
<p>也就是GET,HEAD,DELETE支持的是参数直接拼接URL的方式。</p>
<p>AFJSONRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;]; // 设置公共的请求头</div><div class="line"></div><div class="line">    if (parameters) &#123;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟AFURLRequestSerialization中的实现差不多，如果是HTTPMethodsEncodingParametersInURI请求方式是GET，HEAD，DELETE，则直接调用父类的解析方法。如果是POST等其他的，那么做了一下设置请求头Content-Type = “application/json”,并且将paramters参数Json序列化成NSData,设置到HTTPBody里面。</p>
<p>AFPropertyListRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if (parameters) &#123;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-plist&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [mutableRequest setHTTPBody:[NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好吧，封装思路跟AFJSONRequestSerialization一样，区别在于json序列化变成Plist的转换。</p>
<h1 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h1><h2 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h2><p>负责对网络请求返回的数据进行解析。</p>
<h2 id="类关系：-1"><a href="#类关系：-1" class="headerlink" title="类关系："></a>类关系：</h2><p>父类：</p>
<ul>
<li>AFHTTPResponseSerializer，二进制格式</li>
</ul>
<p>子类： </p>
<ul>
<li>AFJSONResponseSerializer, JSON格式</li>
<li>AFXMLParseResponseSerializer, XML（只能返回XMLParser，还需要自己通过代理解析）</li>
<li>AFXMLDocumentResponseSerializer, （Mac OS X）</li>
<li>AFPropertyListResponseSerializer,  Plist</li>
<li>AFImageResponseSerializer,  Image</li>
<li>AFCompoundResponseSerializer, 组合</li>
</ul>
<h2 id="封装思路：-1"><a href="#封装思路：-1" class="headerlink" title="封装思路："></a>封装思路：</h2><p>跟Request的封装思路基本相同。只不过这个是在数据请求到之后进行的处理。遵循的是AFURLResponseSerialization协议。实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div></pre></td></tr></table></figure>
<p>此处的返回值是id类型的，也就是数据解析完之后的数据。</p>
<p>顺便提一下返回值解析的调用函数是在AFURLSessionManager中的网络请求成功的回调中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 此处进行数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看一下各个类不同职能分别的实现：<br>父类AFHTTPResponseSerializer 中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</div><div class="line"></div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处就一个方法，就是做了一个返回的数据是否有效。但是数据是否有错，都会返回原始数据，没有做任何的修改。<br>看一下返回数据有效性的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</div><div class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</div><div class="line"></div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要做了判断是不是支持的返回content-type类型，再就是状态码是不是200+，如果不满足就不是有效的返回数据。<br>看下初始化值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</div><div class="line">self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];</div></pre></td></tr></table></figure>
<p>子类AFJSONResponseSerializer中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id responseObject = nil;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</div><div class="line">    // See https://github.com/rails/rails/issues/1742</div><div class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</div><div class="line">    if (data.length &gt; 0 &amp;&amp; !isSpace) &#123;</div><div class="line">        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</div><div class="line">    &#125; else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</div><div class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处看到在父类中对有效性的判断结果并没有做处理，而在Json转换类中，如果返回数据是无效的，直接就返回nil。然后就是对返回数据进行了Json转换。并对结果进行了空值进行了排空。</p>
<p>其他的子类的封装思路也都相似，不再一一赘述。注意的是不同的功能的子类对返回值的类型支持是不同的。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Reachability]]></title>
      <url>http://semyonxu.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReachability/</url>
      <content type="html"><![CDATA[<p>Reachability这部分主要负责网络的状态网络状态的监听。</p>
<h1 id="首先介绍下使用方法。"><a href="#首先介绍下使用方法。" class="headerlink" title="首先介绍下使用方法。"></a>首先介绍下使用方法。</h1><p>这里介绍三种使用方法：</p>
<h2 id="直接使用单利，调用"><a href="#直接使用单利，调用" class="headerlink" title="直接使用单利，调用"></a>直接使用单利，调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFNetworkReachabilityManager *reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">[reachabilityManager startMonitoring];</div><div class="line">[reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="使用AFURLSessionManager的属性调用"><a href="#使用AFURLSessionManager的属性调用" class="headerlink" title="使用AFURLSessionManager的属性调用"></a>使用AFURLSessionManager的属性调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;] sessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">  sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">  [sessionManager.reachabilityManager startMonitoring];</div><div class="line">  [sessionManager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">      NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h2 id="使用通知中心的模式，监听"><a href="#使用通知中心的模式，监听" class="headerlink" title="使用通知中心的模式，监听"></a>使用通知中心的模式，监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reachabilityCallBack:) name:AFNetworkingReachabilityDidChangeNotification object:nil];</div><div class="line"></div><div class="line"></div><div class="line">- (void)reachabilityCallBack:(NSNotification *)sender &#123;</div><div class="line">    NSDictionary *userInfo = sender.userInfo;</div><div class="line">    AFNetworkReachabilityStatus netStatus = [userInfo[@&quot;AFNetworkingReachabilityNotificationStatusItem&quot;] integerValue];</div><div class="line">    NSLog(@&quot;netStatus %ld &quot;, netStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法还是比较简单的。</p>
<h1 id="下面分析下源码"><a href="#下面分析下源码" class="headerlink" title="下面分析下源码"></a>下面分析下源码</h1><h2 id="初始化网络监听"><a href="#初始化网络监听" class="headerlink" title="初始化网络监听"></a>初始化网络监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager;</div><div class="line"></div><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">+ (instancetype)managerForDomain:(NSString *)domain;</div><div class="line"></div><div class="line">+ (instancetype)managerForAddress:(const void *)address;</div><div class="line"></div><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>以上均是初始化方法，我们可以直接用单利模式，比较方便的进行初始化对象，也可以直接用manager，建议还是用单利，因为单利里面也是调用的manager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager &#123;</div><div class="line">    static AFNetworkReachabilityManager *_sharedManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _sharedManager = [self manager];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _sharedManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>manager是直接使用的managerForAdress方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager</div><div class="line">&#123;</div><div class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</div><div class="line">    struct sockaddr_in6 address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin6_len = sizeof(address);</div><div class="line">    address.sin6_family = AF_INET6;</div><div class="line">#else</div><div class="line">    struct sockaddr_in address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin_len = sizeof(address);</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">#endif</div><div class="line">    return [self managerForAddress:&amp;address];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然我们也可以使用初始化domain的方法，然后转换成SCNetworkReachabilityRef对象，进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</div><div class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</div><div class="line"></div><div class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</div><div class="line">    </div><div class="line">    CFRelease(reachability);</div><div class="line"></div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 初始化方法里面只是做了一个retain，和初始化网络状态，目测SCNetworkReachabilityRef是不支持自动内存管理的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _networkReachability = CFRetain(reachability);</div><div class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="开始监听网络状态"><a href="#开始监听网络状态" class="headerlink" title="开始监听网络状态"></a>开始监听网络状态</h2><p>我们之间调用startMonitoring方法，进行开始网络状态的监控：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoring &#123;</div><div class="line">    [self stopMonitoring];</div><div class="line"></div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"></div><div class="line">        strongSelf.networkReachabilityStatus = status;</div><div class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</div><div class="line">            strongSelf.networkReachabilityStatusBlock(status);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</div><div class="line">    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</div><div class="line">    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</div><div class="line">        SCNetworkReachabilityFlags flags;</div><div class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</div><div class="line">            AFPostReachabilityStatusChange(flags, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法比较简单，此处我们可以看到，做了数据保护工作，如果没有初始化会return，首先先stopMonitoring，这样做可以避免生成多个监听网络的对象，导致收到多个成功的回调。<br>然后是一个网络状态捕获到的回调。<br>下面才是使用的SystemConfiguration框架下的SCNetworkReachability的API来做的处理，使用也比较简单，先初始化，然后设置回调block，再对回调的C数据转换成网络状态的枚举类型，最后放到了RunLoop里面，设置到了主RunLoop，并设置model为CommonModes，CommonModes就是普通的和事件处理Mode的集合，不清楚的可以去看RunLoop相关文档。</p>
<h2 id="结束监听网络状态"><a href="#结束监听网络状态" class="headerlink" title="结束监听网络状态"></a>结束监听网络状态</h2><p>结束也比较简单，当然，我们可以自己调用，也可以不调用。因为在类销毁的时候，dealloc中也调用了这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)stopMonitoring &#123;</div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看一下网络状态的枚举，也就是我们可以捕获到的网络状态有哪些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</div><div class="line">    AFNetworkReachabilityStatusUnknown          = -1,</div><div class="line">    AFNetworkReachabilityStatusNotReachable     = 0,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWWAN = 1,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWiFi = 2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>默认是Unknown未知，然后是网络不可达，无线广域网链接，WiFi链接，此处没有区分2G/3G/4G,所以需要使用的小伙伴还得自行处理。</p>
<p>当然AF也为我们提供了获取的属性方法，我们可以直接调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WWAN.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WiFi.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi;</div></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isReachable &#123;</div><div class="line">    return [self isReachableViaWWAN] || [self isReachableViaWiFi];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWWAN &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWiFi &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，我们可以拿到网络是不是可达，当前是不是状态WWAN，WiFi。使用比较方便。</p>
<p>基本就是这些了，如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之NSURLSession]]></title>
      <url>http://semyonxu.com/2016/09/28/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BNSURLSession/</url>
      <content type="html"><![CDATA[<p>NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。</p>
<p>下面分两个部分来解析：<br> 父类：AFURLSessionManager，<br> 子类：AFHTTPSessionManager</p>
<p>父类AFURLSessionManager对系统的NSURLSession类的网络请求进行了封装，并把NSURLSession里面的delegate返回值通过block返回回去。<br>子类AFHTTPSessionManager继承了所有父类的功能，在这个基础上封装了支持GET，POST，PUT，HEAD，PATCH，DELETE等HTTP请求方式，使用更加方便。当然不用子类，也是可以直接进行网络请求的。<br><a id="more"></a></p>
<h1 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h1><h2 id="先看初始化方法"><a href="#先看初始化方法" class="headerlink" title="先看初始化方法"></a>先看初始化方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">  - (instancetype)init &#123;</div><div class="line">    return [self initWithSessionConfiguration:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!configuration) &#123;</div><div class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    self.sessionConfiguration = configuration;</div><div class="line"></div><div class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">    self.operationQueue.maxConcurrentOperationCount = 1; // 最大并发数量1，不允许并发？当前请求任务只能是一个。</div><div class="line"></div><div class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 代理的设置在这里。我找的好苦啊。。。</div><div class="line"></div><div class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line"></div><div class="line">#if !TARGET_OS_WATCH</div><div class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">#endif</div><div class="line"></div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</div><div class="line"></div><div class="line">    self.lock = [[NSLock alloc] init];</div><div class="line">    self.lock.name = AFURLSessionManagerLockName;</div><div class="line"></div><div class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</div><div class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</div><div class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</div><div class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对各个属性进行了基本的初始化，为session初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSessionsessionWithConfiguration:self.sessionConfigurationdelegate:selfdelegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>我们可以看到是用的系统NSURLSession的初始化方法。</p>
<p>此处会遍历所有task添加delegate方法，猜测是兼容上次为未完成的请求Task，再继续进行处理，具体还得看情况，因为我跟了多次都是没有走这个方法。</p>
<h2 id="网络请求支持的几个方法"><a href="#网络请求支持的几个方法" class="headerlink" title="网络请求支持的几个方法"></a>网络请求支持的几个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///---------------------------</div><div class="line">/// @name Running Upload Tasks</div><div class="line">///---------------------------</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromFile:(NSURL *)fileURL</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromData:(nullable NSData *)bodyData</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</div><div class="line">                                                 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///-----------------------------</div><div class="line">/// @name Running Download Tasks</div><div class="line">///-----------------------------</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                             progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData</div><div class="line">                                                progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                             destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                       completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>这里面封装了系统NSURLSession的dataTask、uploadTask、downloadTask方法。而且另外添加了数据的进度progress。</p>
<p>下面我们来解析一下实现原理：<br>首先看一下dataTask的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request]; // 核心方法，NSURLSessionDataTask的dataTask方法。</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; // 设置代理，所有进度的处理都在代理中。进度的回调。</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，这里使用的是NSURLSessionDataTask的dataTaskWithRequest:方法，这个地方加了数据保护。然后就是为这个dataTask添加代理。所以核心的工作都交个这个代理AFURLSessionManagerTaskDelegate类来处理，那么这个代理的作用就显得尤为重要。</p>
<h2 id="网络请求的代理类AFURLSessionManagerTaskDelegate"><a href="#网络请求的代理类AFURLSessionManagerTaskDelegate" class="headerlink" title="网络请求的代理类AFURLSessionManagerTaskDelegate"></a>网络请求的代理类AFURLSessionManagerTaskDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</div><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div><div class="line">@property (nonatomic, strong) NSMutableData *mutableData;</div><div class="line">@property (nonatomic, strong) NSProgress *uploadProgress;</div><div class="line">@property (nonatomic, strong) NSProgress *downloadProgress;</div><div class="line">@property (nonatomic, copy) NSURL *downloadFileURL;</div><div class="line">@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading; // 下载任务结束回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock; // 上传进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock; // 下载进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler; // 返回成功结果的Block</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里遵循了NSURLSessionDataDelegate,NSURLSessionDataDelegate,NSURLSessionDownloadDelegate,所以是将NSURLSession的基本代理功能封装了一下。然后会对这些代理方法的返回数据进行处理，使用completionHandler Block来进行返回。</p>
<p>首先来看下代理的核心部分，然后再解读progress的封装思路</p>
<h3 id="代理的核心部分"><a href="#代理的核心部分" class="headerlink" title="代理的核心部分"></a>代理的核心部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSURLSessionTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // 单利group对象，why？这样是不是就可以对多个返回结果进行处理，这样的话，就不用顺序等待了，哪个先完成就先返回回去。</div><div class="line">            // 看参数：如果用户传了group对象，那么选择的是用户的，否则直接使用单利的组对象。 队列是默认是主队列，用户填写的就是用户的。</div><div class="line">            if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 成功后数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123; // 下载的情况下，responseObject为下载的本地地址</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // why use gcd group?</div><div class="line">                if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError); // response Header, 返回结果， 解析错误。</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123; // 此处任务完成的通知只是为了UIKit中的一些类别中拿到回调。userInfo字段并没有返回给外部，而是给UIKit用的。当然我们可以用这个通知来获取到。</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDataTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到这里核心的方法只有三个，一个是task完成的回调，一个是接受到数据的回调，最后是下载完成的回调。<br>普通的task请求会先走第二个方法didReceiveData方法，把返回的数据添加到mutableData中。<br>然后再走第一个方法，请求完成的回调。</p>
<h4 id="第一个方法："><a href="#第一个方法：" class="headerlink" title="第一个方法："></a>第一个方法：</h4><p>首先会把返回的数据赋给一个局部变量data，然后将全局的mutableData置空，这样就可以保证下次请求的数据是重新加载。这里区分了下载和普通的数据返回，如果是下载的话，直接下载到指定文件路径中，如果用户指定这个路径的话，userInfo字典里面存的就是下载路径，否则，存的是下载数据。<br>然后就是判断有没有错误，错误的话把错误返回，返回值task.response, responseObject此处是空的，然后就是error。最后在主线程中发送通知，为当前task的userInfo，注意此处的userInfo只是用来做通知信息的。而我们平时用的时候不会用通知来获取请求成功的回调，这个通知是为了AFNetworking中的UIKit封装部分服务的。<br>然后就是成功的回调，异步请求在单利队列中，这里对队列的生成都加了单利的保护。这里通过responseSerializer 对结果数据进行转化成对应的格式（这可以参考Serialization部分，里面讲解如何转化的），如果是下载的话，responseObject直接赋值成downloadFileURL，也就是下载的话，回调中只会有下载的目标地址。然后就是对userInfo的AFNetworkingTaskDidCompleteSerializedResponseKey（序列化响应结果）、AFNetworkingTaskDidCompleteErrorKey（序列化过程中的错误信息）进行赋值，不得不说AFNetworking对各个部分的情况都返回回去了，做的很详细。<br>然后就是调用回调block：completionHandler：<br>返回值task.response也就是完整的返回头信息以及返回的状态码。<br>responseObject是返回的数据或者是下载的目标地址。<br>serializationError注意这个地方的错误是序列化的错误，也就是此处如果对返回数据序列化产生错误，也会照样返回成功回调，只是回调结果会是序列化的错误。<br>最后还是一样的发送通知。</p>
<h4 id="第二个方法："><a href="#第二个方法：" class="headerlink" title="第二个方法："></a>第二个方法：</h4><p>简单的接收到返回数据，简单的把数据进行拼接。</p>
<h4 id="第三个方法："><a href="#第三个方法：" class="headerlink" title="第三个方法："></a>第三个方法：</h4><p>下载的方法，此处如果有downloadTaskDidFinishDownloading的实现，那么进行调用转换目标地址，而目标地址是在下面这个方法的destination Block中进行设置的，这个地方转了一下，也就是倒了两个block让用户来设置这个目标地址。如果可以正常获取这个目标地址的话，把location（也就是本地下载路径，其实就是缓存路径，因为这里下载完成后会删掉）的数据转移到目标路径。响应的会有文件操作的错误信息的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络请求progress的封装思路"><a href="#网络请求progress的封装思路" class="headerlink" title="网络请求progress的封装思路"></a>网络请求progress的封装思路</h3><p>此处使用的技术是KVO，先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    __weak __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</div><div class="line">    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</div><div class="line">    [self.uploadProgress setCancellable:YES];</div><div class="line">    [self.uploadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.uploadProgress setPausable:YES];</div><div class="line">    [self.uploadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line">    if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.uploadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self.downloadProgress setCancellable:YES];</div><div class="line">    [self.downloadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.downloadProgress setPausable:YES];</div><div class="line">    [self.downloadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.downloadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [self.downloadProgress addObserver:self</div><div class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                               options:NSKeyValueObservingOptionNew</div><div class="line">                               context:NULL];</div><div class="line">    [self.uploadProgress addObserver:self</div><div class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                             options:NSKeyValueObservingOptionNew</div><div class="line">                             context:NULL];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)cleanUpProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))];</div><div class="line">    [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">    [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</div><div class="line">            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</div><div class="line">            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</div><div class="line">        if (self.downloadProgressBlock) &#123;</div><div class="line">            self.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</div><div class="line">        if (self.uploadProgressBlock) &#123;</div><div class="line">            self.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化方法中我们可以看到KVO监听的KeyPath是NSURLSessionTask的四个只读属性：countOfBytesReceived, countOfBytesExpectedToReceive, countOfBytesSent, countOfBytesExpectedToSend， 也就是Task的数据统计的一些信息。 downloadProgress和uploadProgress都对fractionCompleted进行监听，也就是进度完成的百分比。<br>这里cleanUp移除所有的KVO，KVO我们平时使用的时候也是需要注意移除的，防止发生原来的还在，又添加监听导致多次监听，那么悲剧了，就是执行监听结果方法的调用越来越多。莫名其妙的bug。<br>最后KVO监听到结果的回调中，对downloadProgress，uploadProgress分别进行completedunitCount完成进度的赋值、totalUnitCount所有进度的复制。如果对象不是task而是NSProgress对象，那么直接把这个object返回回去。</p>
<h2 id="NSURLSession代理方法的转换处理"><a href="#NSURLSession代理方法的转换处理" class="headerlink" title="NSURLSession代理方法的转换处理"></a>NSURLSession代理方法的转换处理</h2><p>首先这里会有很多block的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;</div><div class="line"></div><div class="line">- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">///--------------------------------------</div><div class="line">/// @name Setting Task Delegate Callbacks</div><div class="line">///--------------------------------------</div><div class="line"></div><div class="line">- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;</div><div class="line"></div><div class="line">- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;</div><div class="line"></div><div class="line">- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</div><div class="line"></div><div class="line">- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;</div><div class="line"></div><div class="line">///-------------------------------------------</div><div class="line">/// @name Setting Data Task Delegate Callbacks</div><div class="line">///-------------------------------------------</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;</div><div class="line"></div><div class="line">- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;</div><div class="line"></div><div class="line">- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block;</div><div class="line"></div><div class="line">///-----------------------------------------------</div><div class="line">/// @name Setting Download Task Delegate Callbacks</div><div class="line">///-----------------------------------------------</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable  (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</div></pre></td></tr></table></figure>
<p>也就是支持对所有的NSURLSession代理方法的回调方法直接使用block传给用户使用，这里既支持我们处理原始的回调，AFNetworking在里面继续做响应的处理。</p>
<p>具体方法的处理，由于太多了，我们就分析一下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line"></div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会获取到当前task的delegate对象，然后在代理中对这些数据进行处理。这个方法是在网络完成的时候执行的，所以这里应该将这个task移除掉。数据的处理参见3)里面的AFURLSessionManagerTaskDelegate的方法解析。 最后会执行taskDidComplete的block回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); // block 带入目标地址的url，在外面设置</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>download的完成方法的回调，我们看到跟AFURLSessionManagerTaskDelegate中的方法功能基本是一样的，也就是如果有AFURLSessionManager类中有downloadTaskDidFinishDownloading的block实现的话，就直接在NSURLSessionDownloadDelegate中处理，如果现在还没有实现block，那么就放在delegete里面处理。注意这个地方AFURLSessionManager和NSURLSessionDownloadDelegate都有这个downloadTaskDidFinishDownloading 的block。</p>
<p>就这俩吧，其他的代理方法基本上都是转换成block进行回调，有的复杂一点需要对block的值进行处理一下，然后在回调回去。</p>
<h2 id="关于多任务的处理"><a href="#关于多任务的处理" class="headerlink" title="关于多任务的处理"></a>关于多任务的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = nil;</div><div class="line">    [self.lock lock];</div><div class="line">    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line"></div><div class="line">    return delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask</div><div class="line">                        progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">               completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    uploadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:uploadTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是支持多任务请求的。这里使用字典存的是当前task的代理AFURLSessionManagerTaskDelegate的delegate：<br>@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;<br>也就是所有的请求会把代理使用task的taskIdentifier标记存起来。设置代理的时候加了保护锁，保证可变字典的安全操作。</p>
<h2 id="AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"><a href="#AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state" class="headerlink" title="_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"></a>_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</div><div class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</div><div class="line">#pragma GCC diagnostic push</div><div class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</div><div class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</div><div class="line">        Class currentClass = [localDataTask class];</div><div class="line">        </div><div class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</div><div class="line">            Class superClass = [currentClass superclass];</div><div class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</div><div class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</div><div class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</div><div class="line">                originalAFResumeIMP != classResumeIMP) &#123;</div><div class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</div><div class="line">            &#125;</div><div class="line">            currentClass = [currentClass superclass];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [localDataTask cancel];</div><div class="line">        [session finishTasksAndInvalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</div><div class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</div><div class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionTaskState)state &#123;</div><div class="line">    NSAssert(NO, @&quot;State method should never be called in the actual dummy class&quot;);</div><div class="line">    return NSURLSessionTaskStateCanceling;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_resume &#123; // 通过Swizzle发通知AFNSURLSessionTaskDidResumeNotification</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_resume];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_suspend &#123;</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_suspend];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用runtime技术的swizzle方法对新初始化的一个NSURLSessionDataTask对象进行方法替换。替换resume方法的实现为af_resume，suspend的方法实现为af_suspend。这里面对当前的NSURLSessionTaskState进行操作。</p>
<h1 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h1><p>这部分是继承自AFURLSessionManager，如果是AFURLSessionManager是网络的核心部分，那么这部分就是方便开发者调用的一个实现部分。<br>这里面其实封装的比较简单。看一下属性数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div></pre></td></tr></table></figure>
<p>里面一个基本的URL，请求序列化，响应序列化。注意这个地方，请求序列化是在AFHTTPSessionManager中做的处理，而responseSerializer是在AFURLSessionManager中做的处理。</p>
<p>初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</div><div class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>这里支持类方法和实例方法。当然了类方法是封装的实例方法。</p>
<p>提供的网络请求方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                            parameters:(nullable id)parameters</div><div class="line">                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">     constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">              constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString</div><div class="line">                     parameters:(nullable id)parameters</div><div class="line">                        success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                        failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString</div><div class="line">                      parameters:(nullable id)parameters</div><div class="line">                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div></pre></td></tr></table></figure>
<p>以上是提供的所有的方法，HTTP协议的基本请求类型GET，POST，PUT，HEAD，DELETE都封装了。</p>
<p>下面我们看一下GET的实现，因为其他的思路都是一样的，出了POST另外增加了一种body类型的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(id)parameters</div><div class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</div><div class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</div><div class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                   uploadProgress:nil</div><div class="line">                                                 downloadProgress:downloadProgress</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line"></div><div class="line">    [dataTask resume];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到调用的是dataTaskWithHTTPMethod: URLString: parameters: uploadProgress: downloadProgress: success: failure:方法。除了POST新增的方法，其他的都是直接调用的这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是简单的把请求数据进行了序列化，如果错误的话就直接返回nil，不会发送任何请求。成功的话，进行调用AFURLSessionManager中的方法，最后对返回值进行了简单处理。封装的还算简单，没有太多复杂的逻辑。</p>
<p>最后看一下POST的另一个增加的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(id)parameters</div><div class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</div><div class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</div><div class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(task, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(task, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [task resume];</div><div class="line"></div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装思路跟上面的基本上是一样的，序列化数据的时候会把body的内容封装在请求body里面：<br> [self.requestsetHTTPBodyStream:self.bodyStream];<br> 相应的这里调用的是AFURLSessionManager中的StreamRequest方法。</p>
<p>如果文中有什么错误，欢迎指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
  
  
</search>
