<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[AFNetworking-3-0-源码解析之UIKit]]></title>
      <url>http://semyonxu.com/2016/11/15/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BUIKit/</url>
      <content type="html"><![CDATA[<p>本部分主要的作用：对UI控件进行网络请求的支持。</p>
<h1 id="UIKit"><a href="#UIKit" class="headerlink" title="UIKit"></a>UIKit</h1><p> 功能：本部分主要方便UI使用网络功能，为UIImageView，UIButton等设置网络下载图片。功能类似于SDWebImage库。以及UIProgressView，UIWebView，UIRefreshControl，UIActivityIndicatorView部分UI的网络使用封装。</p>
<p> 下面分别解析一下各个控件的设计思路</p>
<h1 id="UIImageView-AFNetworking"><a href="#UIImageView-AFNetworking" class="headerlink" title="UIImageView+AFNetworking"></a>UIImageView+AFNetworking</h1><p>为UIImageView加载网络图片提供便利的接口。</p>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setImageWithURL:(NSURL *)url;</div><div class="line">- (void)setImageWithURL:(NSURL *)url</div><div class="line">       placeholderImage:(nullable UIImage *)placeholderImage;</div><div class="line">- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest</div><div class="line">              placeholderImage:(nullable UIImage *)placeholderImage</div><div class="line">                       success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success</div><div class="line">                       failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure;</div></pre></td></tr></table></figure>
<p>这里为我们抛出了图片下载地址，默认显示图片，成功的回调，失败的回调。</p>
<p>下面解析下载的核心转换代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">- (void)setImageWithURLRequest:(NSURLRequest *)urlRequest</div><div class="line">              placeholderImage:(UIImage *)placeholderImage</div><div class="line">                       success:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *image))success</div><div class="line">                       failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if ([urlRequest URL] == nil) &#123;</div><div class="line">        [self cancelImageDownloadTask];</div><div class="line">        self.image = placeholderImage;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self isActiveTaskURLEqualToURLRequest:urlRequest])&#123; // - 检测是当前任务是否有这个urlRequest</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self cancelImageDownloadTask];</div><div class="line"></div><div class="line">    AFImageDownloader *downloader = [[self class] sharedImageDownloader];</div><div class="line">    id &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;</div><div class="line"></div><div class="line">    //Use the image from the image cache if it exists</div><div class="line">    UIImage *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:nil];</div><div class="line">    if (cachedImage) &#123;</div><div class="line">        if (success) &#123;</div><div class="line">            success(urlRequest, nil, cachedImage);</div><div class="line">        &#125; else &#123;</div><div class="line">            self.image = cachedImage;</div><div class="line">        &#125;</div><div class="line">        [self clearActiveDownloadInformation];</div><div class="line">    &#125; else &#123;</div><div class="line">        if (placeholderImage) &#123;</div><div class="line">            self.image = placeholderImage;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        __weak __typeof(self)weakSelf = self;</div><div class="line">        NSUUID *downloadID = [NSUUID UUID]; // 下载标识符</div><div class="line">        AFImageDownloadReceipt *receipt; // 完成标识符，下载跟完成是一样的</div><div class="line">        receipt = [downloader</div><div class="line">                   downloadImageForURLRequest:urlRequest</div><div class="line">                   withReceiptID:downloadID</div><div class="line">                   success:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, UIImage * _Nonnull responseObject) &#123;</div><div class="line">                       __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line">                       if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</div><div class="line">                           if (success) &#123; // 成功返回</div><div class="line">                               success(request, response, responseObject);</div><div class="line">                           &#125; else if(responseObject) &#123; // 成功但是不是请求成功，用缓存图片，直接给imageview赋值</div><div class="line">                               strongSelf.image = responseObject;</div><div class="line">                           &#125;</div><div class="line">                           [strongSelf clearActiveDownloadInformation];</div><div class="line">                       &#125;</div><div class="line"></div><div class="line">                   &#125;</div><div class="line">                   failure:^(NSURLRequest * _Nonnull request, NSHTTPURLResponse * _Nullable response, NSError * _Nonnull error) &#123;</div><div class="line">                       __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line">                        if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</div><div class="line">                            if (failure) &#123;</div><div class="line">                                failure(request, response, error);</div><div class="line">                            &#125;</div><div class="line">                            [strongSelf clearActiveDownloadInformation];</div><div class="line">                        &#125;</div><div class="line">                   &#125;]; // 注意，这个是同步的，所以可以获得receipt</div><div class="line"></div><div class="line">        self.af_activeImageDownloadReceipt = receipt;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="首先会对上次的任务进行检测，如果有的话，取消掉。"><a href="#首先会对上次的任务进行检测，如果有的话，取消掉。" class="headerlink" title="首先会对上次的任务进行检测，如果有的话，取消掉。"></a>首先会对上次的任务进行检测，如果有的话，取消掉。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    if (self.af_activeImageDownloadReceipt != nil) &#123;</div><div class="line">        [[self.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:self.af_activeImageDownloadReceipt]; // runtime 管理对象获取downloader单利，取消当前这个receipt下的任务</div><div class="line">        [self clearActiveDownloadInformation]; // 清空 af_activeImageDownloadReceipt</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里检测的是self.af_activeImageDownloadReceipt，注意这是分类中添加的属性，下载的唯一标识符。也就是说如果这个任务已经下载过的话，下次重新下载会取消上次的下载任务。</p>
<p>类别添加属性的方法是用的runtime：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (AFImageDownloadReceipt *)af_activeImageDownloadReceipt &#123;</div><div class="line">    return (AFImageDownloadReceipt *)objc_getAssociatedObject(self, @selector(af_activeImageDownloadReceipt));</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="检测如果本地有缓存，直接获取缓存的图片，返回"><a href="#检测如果本地有缓存，直接获取缓存的图片，返回" class="headerlink" title="检测如果本地有缓存，直接获取缓存的图片，返回"></a>检测如果本地有缓存，直接获取缓存的图片，返回</h3><p>缓存类是：AFAutoPurgingImageCache。<br>缓存类的封装思路：</p>
<h4 id="AFAutoPurgingImageCache"><a href="#AFAutoPurgingImageCache" class="headerlink" title="AFAutoPurgingImageCache"></a>AFAutoPurgingImageCache</h4><p>简单的图片缓存，比起SDWebImage来说比较简单，没有分别存内存和硬盘。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSMutableDictionary &lt;NSString* , AFCachedImage*&gt; *cachedImages;</div><div class="line">@property (nonatomic, assign) UInt64 currentMemoryUsage;</div><div class="line">@property (nonatomic, strong) dispatch_queue_t synchronizationQueue;</div></pre></td></tr></table></figure>
<p>cachedImages：缓存字典<br>currentMemoryUsage：当前使用的内存字节大小<br>synchronizationQueue：同步队列，主要用来做同步操作</p>
<h5 id="初始化方法："><a href="#初始化方法：" class="headerlink" title="初始化方法："></a>初始化方法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithMemoryCapacity:(UInt64)memoryCapacity preferredMemoryCapacity:(UInt64)preferredMemoryCapacity &#123;</div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        self.memoryCapacity = memoryCapacity;</div><div class="line">        self.preferredMemoryUsageAfterPurge = preferredMemoryCapacity;</div><div class="line">        self.cachedImages = [[NSMutableDictionary alloc] init];</div><div class="line"></div><div class="line">        NSString *queueName = [NSString stringWithFormat:@&quot;com.alamofire.autopurgingimagecache-%@&quot;, [[NSUUID UUID] UUIDString]];</div><div class="line">        self.synchronizationQueue = dispatch_queue_create([queueName cStringUsingEncoding:NSASCIIStringEncoding], DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">        [[NSNotificationCenter defaultCenter]</div><div class="line">         addObserver:self</div><div class="line">         selector:@selector(removeAllImages)</div><div class="line">         name:UIApplicationDidReceiveMemoryWarningNotification</div><div class="line">         object:nil];</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步队列是用的自定义并行队列。这里有对内存警告的处理。收到内存警告的通知：UIApplicationDidReceiveMemoryWarningNotification，执行清空所有缓存的图片removeAllImages方法。</p>
<h5 id="添加图片："><a href="#添加图片：" class="headerlink" title="添加图片："></a>添加图片：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (void)addImage:(UIImage *)image withIdentifier:(NSString *)identifier &#123;</div><div class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</div><div class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</div><div class="line"></div><div class="line">        AFCachedImage *previousCachedImage = self.cachedImages[identifier];</div><div class="line">        if (previousCachedImage != nil) &#123;</div><div class="line">            self.currentMemoryUsage -= previousCachedImage.totalBytes;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        self.cachedImages[identifier] = cacheImage;</div><div class="line">        self.currentMemoryUsage += cacheImage.totalBytes;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    dispatch_barrier_async(self.synchronizationQueue, ^&#123;</div><div class="line">        if (self.currentMemoryUsage &gt; self.memoryCapacity) &#123;</div><div class="line">            UInt64 bytesToPurge = self.currentMemoryUsage - self.preferredMemoryUsageAfterPurge;</div><div class="line">            NSMutableArray &lt;AFCachedImage*&gt; *sortedImages = [NSMutableArray arrayWithArray:self.cachedImages.allValues];</div><div class="line">            NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@&quot;lastAccessDate&quot;</div><div class="line">                                                                           ascending:YES];</div><div class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</div><div class="line"></div><div class="line">            UInt64 bytesPurged = 0;</div><div class="line"></div><div class="line">            for (AFCachedImage *cachedImage in sortedImages) &#123;</div><div class="line">                [self.cachedImages removeObjectForKey:cachedImage.identifier];</div><div class="line">                bytesPurged += cachedImage.totalBytes;</div><div class="line">                if (bytesPurged &gt;= bytesToPurge) &#123;</div><div class="line">                    break ;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            self.currentMemoryUsage -= bytesPurged;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的是GCD的barrier异步方法，在保证队列中前面的任务全部完成的情况下，执行添加方法，并不阻塞之后的任务执行。</p>
<ol>
<li>首先初始化一个AFCachedImage对象，用这个对象存图片，以及一些图片相关的信息。缓存字节数响应的增加调整。如果已经存在的图片进行处理，那么先减去缓存字节数，最后替换图片。</li>
<li>对缓存内容大小进行判断，使用barrier可以保证在上个添加任务完成后再执行下个任务。如果缓存大小超过总的缓存容量，那么首先执行排序，然后顺序移除，直到不再超出缓存容量。</li>
</ol>
<h5 id="移除图片"><a href="#移除图片" class="headerlink" title="移除图片"></a>移除图片</h5><p>移除图片类似使用的GCD的barrier同步方法。这里会阻塞，等待移除任务做完之后，进行以后的任务。跟添加有区别，这样可以保证线程安全。<br>上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (BOOL)removeImageWithIdentifier:(NSString *)identifier &#123;</div><div class="line">    __block BOOL removed = NO;</div><div class="line">    dispatch_barrier_sync(self.synchronizationQueue, ^&#123;</div><div class="line">        AFCachedImage *cachedImage = self.cachedImages[identifier];</div><div class="line">        if (cachedImage != nil) &#123;</div><div class="line">            [self.cachedImages removeObjectForKey:identifier];</div><div class="line">            self.currentMemoryUsage -= cachedImage.totalBytes;</div><div class="line">            removed = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return removed;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)removeAllImages &#123;</div><div class="line">    __block BOOL removed = NO;</div><div class="line">    dispatch_barrier_sync(self.synchronizationQueue, ^&#123;</div><div class="line">        if (self.cachedImages.count &gt; 0) &#123;</div><div class="line">            [self.cachedImages removeAllObjects];</div><div class="line">            self.currentMemoryUsage = 0;</div><div class="line">            removed = YES;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里支持单个删除，全部删除。操作的还是当前这个cachedImages字典。</p>
<h3 id="网络下载，并把获取到的图片赋值给当前的ImageView"><a href="#网络下载，并把获取到的图片赋值给当前的ImageView" class="headerlink" title="网络下载，并把获取到的图片赋值给当前的ImageView"></a>网络下载，并把获取到的图片赋值给当前的ImageView</h3><p>首先，会先设置一个默认的placeholderImage占位图，如果你设置过的话。<br>然后，这里使用的是[NSUUID UUID]来做下载的唯一标识符，注意downloadID如receipt是一样的。这个是用来区别是否是当前任务。<br>下载任务是用的：AFImageDownloader。这是UI下载里面的核心部分。<br>通过调用下载方法，获取到下载图片结果。<br>如果成功，并且receiptID匹配当前的下载downloadID，有成功回调的话，返回去成功的参数已经图片。如果没有成功回调的话，直接给uiimageView赋值（这个地方跟SDWebImage还是有区别的，SDWebImage直接赋值，就算有成功回调也会赋值）。然后清空当前的下载信息，其实就是清空这个标示id。<br>如果失败，如果有失败block的情况，回调回去，没有不做任何处理，相同的清空下载信息。<br>最后有个赋值：<br>self.af_activeImageDownloadReceipt = receipt;<br>这个地方之所以可以这么赋值，是因为下载方法是同步的。注意的是这个任务是同步的，但是发起的网络请求是异步的。</p>
<p>下面解析一下AFImageDownloader.</p>
<h4 id="AFImageDownloader"><a href="#AFImageDownloader" class="headerlink" title="AFImageDownloader"></a>AFImageDownloader</h4><p>核心下载类，下载任务，取消任务。</p>
<h5 id="开始下载任务"><a href="#开始下载任务" class="headerlink" title="开始下载任务"></a>开始下载任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div></pre></td><td class="code"><pre><div class="line">- (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request</div><div class="line">                                                  withReceiptID:(nonnull NSUUID *)receiptID</div><div class="line">                                                        success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse  * _Nullable response, UIImage *responseObject))success</div><div class="line">                                                        failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure &#123;</div><div class="line">    </div><div class="line">    __block NSURLSessionDataTask *task = nil;</div><div class="line">    dispatch_sync(self.synchronizationQueue, ^&#123; </div><div class="line">        NSString *URLIdentifier = request.URL.absoluteString;</div><div class="line">        if (URLIdentifier == nil) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil];</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    failure(request, nil, error);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 1) Append the success and failure blocks to a pre-existing request if it already exists</div><div class="line">        AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">        if (existingMergedTask != nil) &#123;</div><div class="line">            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];</div><div class="line">            [existingMergedTask addResponseHandler:handler];</div><div class="line">            task = existingMergedTask.task;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 2) Attempt to load the image from the image cache if the cache policy allows it</div><div class="line">        switch (request.cachePolicy) &#123;</div><div class="line">            case NSURLRequestUseProtocolCachePolicy:</div><div class="line">            case NSURLRequestReturnCacheDataElseLoad: // 只有在cache中不存在data时才从原始地址下载。</div><div class="line">            case NSURLRequestReturnCacheDataDontLoad: &#123; // 只使用cache数据，如果不存在cache，请求失败；用于没有建立网络连接离线模式</div><div class="line">                UIImage *cachedImage = [self.imageCache imageforRequest:request withAdditionalIdentifier:nil];</div><div class="line">                if (cachedImage != nil) &#123;</div><div class="line">                    if (success) &#123;</div><div class="line">                        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                            success(request, nil, cachedImage);</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 3) Create the request and set up authentication, validation and response serialization</div><div class="line">        NSUUID *mergedTaskIdentifier = [NSUUID UUID];</div><div class="line">        NSURLSessionDataTask *createdTask;</div><div class="line">        __weak __typeof__(self) weakSelf = self;</div><div class="line"></div><div class="line">        createdTask = [self.sessionManager</div><div class="line">                       dataTaskWithRequest:request</div><div class="line">                       completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) &#123;</div><div class="line">                           dispatch_async(self.responseQueue, ^&#123;</div><div class="line">                               __strong __typeof__(weakSelf) strongSelf = weakSelf;</div><div class="line">                               AFImageDownloaderMergedTask *mergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">                               if ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123;</div><div class="line">                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</div><div class="line">                                   if (error) &#123; // 失败返回回调</div><div class="line">                                       for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123;</div><div class="line">                                           if (handler.failureBlock) &#123;</div><div class="line">                                               dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                   handler.failureBlock(request, (NSHTTPURLResponse*)response, error);</div><div class="line">                                               &#125;);</div><div class="line">                                           &#125;</div><div class="line">                                       &#125;</div><div class="line">                                   &#125; else &#123; // 成功返回回调，添加图片到缓存</div><div class="line">                                       [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil];</div><div class="line"></div><div class="line">                                       for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) &#123;</div><div class="line">                                           if (handler.successBlock) &#123;</div><div class="line">                                               dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                                                   handler.successBlock(request, (NSHTTPURLResponse*)response, responseObject);</div><div class="line">                                               &#125;);</div><div class="line">                                           &#125;</div><div class="line">                                       &#125;</div><div class="line">                                   &#125;</div><div class="line">                               &#125;</div><div class="line">                               [strongSelf safelyDecrementActiveTaskCount];</div><div class="line">                               [strongSelf safelyStartNextTaskIfNecessary]; // 成功开启下一个任务。保证最大并发数的情况下。</div><div class="line">                           &#125;);</div><div class="line">                       &#125;];</div><div class="line"></div><div class="line">        // 4) Store the response handler for use when the request completes</div><div class="line">        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID</div><div class="line">                                                                                                   success:success</div><div class="line">                                                                                                   failure:failure];</div><div class="line">        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]</div><div class="line">                                                   initWithURLIdentifier:URLIdentifier</div><div class="line">                                                   identifier:mergedTaskIdentifier</div><div class="line">                                                   task:createdTask];</div><div class="line">        [mergedTask addResponseHandler:handler]; // 一个mergedTask添加一个handler，为什么要把handler设计成一个数组呢？</div><div class="line">        self.mergedTasks[URLIdentifier] = mergedTask;</div><div class="line"></div><div class="line">        // 5) Either start the request or enqueue it depending on the current active request count</div><div class="line">        if ([self isActiveRequestCountBelowMaximumLimit]) &#123; // 不到最大并发数，开启新任务</div><div class="line">            [self startMergedTask:mergedTask];</div><div class="line">        &#125; else &#123; // 超出最大并发数，加入缓存队列</div><div class="line">            [self enqueueMergedTask:mergedTask];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        task = mergedTask.task; // createdTask</div><div class="line">    if (task) &#123;</div><div class="line">        return [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task]; // 为task打标签</div><div class="line">    &#125; else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先处理失败的回调，如果失败，抛出失败的request，error，直接返回。<br>成功的话，分三部分处理</p>
<ol>
<li>判断当前task是否已经存在，如果存在，直接获取这个task，并返回。</li>
<li>从缓存里面取，如果已经缓存过，调用成功回调，把缓存的图片返回回去。</li>
<li>如果以上两点都没有的，进行网络请求。这里使用的是AFURLSessionManager里面的</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div></pre></td></tr></table></figure>
<p>方法。这个方法的解析参考NSURLSession部分的解析。<br>回调中，这里会判断是否是当前任务URLIdentifier，如果是，继续处理。并分别返回成功失败的回调。<br>处理完之后，这里会将队列任务数量-1，然后开启下一个缓存的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[strongSelf safelyDecrementActiveTaskCount];</div><div class="line">[strongSelf safelyStartNextTaskIfNecessary];</div></pre></td></tr></table></figure>
<p>由于是同步的，所以我们可以获取这个createdTask任务。<br>初始化一个AFImageDownloaderResponseHandler对象，这个对象主要负责成功失败的回调，以及唯一标示每个任务的id。然后添加到AFImageDownloaderMergedTask的对象中，AFImageDownloaderMergedTask类主要作用：统一管理task的标识符，回调对象。主要这里有两个标识符： </p>
<ul>
<li>URLIdentifier：用于标示下载任务唯一。内部使用AFImageDownload使用。</li>
<li>identifier：用于匹配下载任务与完成的处理唯一。外部类使用。</li>
</ul>
<p>然后处理缓存队列，如果没有到最大并发数，开启新任务，如果超出最大并发数，加入缓存队列。</p>
<p>看一下入队，出队的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)enqueueMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123; // 入队： 添加到队列数组中去，所谓的队列和栈，只是数组的顺序而已。</div><div class="line">    switch (self.downloadPrioritizaton) &#123;</div><div class="line">        case AFImageDownloadPrioritizationFIFO:</div><div class="line">            [self.queuedMergedTasks addObject:mergedTask]; // 先进先出，顺序添加到数组</div><div class="line">            break;</div><div class="line">        case AFImageDownloadPrioritizationLIFO:</div><div class="line">            [self.queuedMergedTasks insertObject:mergedTask atIndex:0]; // 先进后出，每次插入到数组第一个位置</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (AFImageDownloaderMergedTask *)dequeueMergedTask &#123; // 出队</div><div class="line">    AFImageDownloaderMergedTask *mergedTask = nil;</div><div class="line">    mergedTask = [self.queuedMergedTasks firstObject];</div><div class="line">    [self.queuedMergedTasks removeObject:mergedTask]; // 从队列里面移除</div><div class="line">    return mergedTask; // 返回最先进入队列的任务，先进先出</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>入队的设计还是使用的数组，支持先进先出，后进先出两种入队模式。</p>
<h5 id="取消下载任务"><a href="#取消下载任务" class="headerlink" title="取消下载任务"></a>取消下载任务</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)cancelTaskForImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</div><div class="line">    dispatch_sync(self.synchronizationQueue, ^&#123;</div><div class="line">        NSString *URLIdentifier = imageDownloadReceipt.task.originalRequest.URL.absoluteString;</div><div class="line">        AFImageDownloaderMergedTask *mergedTask = self.mergedTasks[URLIdentifier];</div><div class="line">        NSUInteger index = [mergedTask.responseHandlers indexOfObjectPassingTest:^BOOL(AFImageDownloaderResponseHandler * _Nonnull handler, __unused NSUInteger idx, __unused BOOL * _Nonnull stop) &#123;</div><div class="line">            return handler.uuid == imageDownloadReceipt.receiptID;</div><div class="line">        &#125;];</div><div class="line"></div><div class="line">        if (index != NSNotFound) &#123;</div><div class="line">            AFImageDownloaderResponseHandler *handler = mergedTask.responseHandlers[index];</div><div class="line">            [mergedTask removeResponseHandler:handler];</div><div class="line">            NSString *failureReason = [NSString stringWithFormat:@&quot;ImageDownloader cancelled URL request: %@&quot;,imageDownloadReceipt.task.originalRequest.URL.absoluteString];</div><div class="line">            NSDictionary *userInfo = @&#123;NSLocalizedFailureReasonErrorKey:failureReason&#125;;</div><div class="line">            NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorCancelled userInfo:userInfo];</div><div class="line">            if (handler.failureBlock) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    handler.failureBlock(imageDownloadReceipt.task.originalRequest, nil, error);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (mergedTask.responseHandlers.count == 0 &amp;&amp; mergedTask.task.state == NSURLSessionTaskStateSuspended) &#123;</div><div class="line">            [mergedTask.task cancel];</div><div class="line">            [self removeMergedTaskWithURLIdentifier:URLIdentifier];</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>通过URLIdentifier获取当前mergedTask任务，通过receiptID遍历出当前的这个handler。</li>
<li>将handler从mergedTask中移除，抛出失败的回调。</li>
<li>最后移除当前的这个mergedTask</li>
</ol>
<h1 id="UIButton-AFNetworking"><a href="#UIButton-AFNetworking" class="headerlink" title="UIButton+AFNetworking"></a>UIButton+AFNetworking</h1><p>封装思路跟UIImageView+AFNetworking基本相同，区别在于图片的处理，UIButton分别处理了图片：<br>[self setImage:cachedImage forState:state];<br>背景图片：<br>[self setBackgroundImage:placeholderImage forState:state];<br>已经对不同状态的处理。</p>
<h1 id="UIProgressView-AFNetworking"><a href="#UIProgressView-AFNetworking" class="headerlink" title="UIProgressView+AFNetworking"></a>UIProgressView+AFNetworking</h1><p>支持下载、上传的进度条，主要使用的技术点是KVO。</p>
<p>设置调用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)setProgressWithUploadProgressOfTask:(NSURLSessionUploadTask *)task</div><div class="line">                                   animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext];</div><div class="line">    [task addObserver:self forKeyPath:@&quot;countOfBytesSent&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesSentContext];</div><div class="line"></div><div class="line">    [self af_setUploadProgressAnimated:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setProgressWithDownloadProgressOfTask:(NSURLSessionDownloadTask *)task</div><div class="line">                                     animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [task addObserver:self forKeyPath:@&quot;state&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];</div><div class="line">    [task addObserver:self forKeyPath:@&quot;countOfBytesReceived&quot; options:(NSKeyValueObservingOptions)0 context:AFTaskCountOfBytesReceivedContext];</div><div class="line"></div><div class="line">    [self af_setDownloadProgressAnimated:animated];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对上传任务的key：state，countOfBytesSent进行了监听，<br>对下载任务key：state，countOfBytesReceived进行了监听。</p>
<p>支持动画设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (BOOL)af_uploadProgressAnimated &#123;</div><div class="line">    return [(NSNumber *)objc_getAssociatedObject(self, @selector(af_uploadProgressAnimated)) boolValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_setUploadProgressAnimated:(BOOL)animated &#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(af_uploadProgressAnimated), @(animated), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)af_downloadProgressAnimated &#123;</div><div class="line">    return [(NSNumber *)objc_getAssociatedObject(self, @selector(af_downloadProgressAnimated)) boolValue];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_setDownloadProgressAnimated:(BOOL)animated &#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(af_downloadProgressAnimated), @(animated), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用runtime的关联对象功能，也是蛮拼的，这么一个小的属性的支持。</p>
<p>核心：kvo的监听回调中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSKeyValueObserving</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</div><div class="line">                      ofObject:(id)object</div><div class="line">                        change:(__unused NSDictionary *)change</div><div class="line">                       context:(void *)context</div><div class="line">&#123;</div><div class="line">    if (context == AFTaskCountOfBytesSentContext || context == AFTaskCountOfBytesReceivedContext) &#123;</div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</div><div class="line">            if ([object countOfBytesExpectedToSend] &gt; 0) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [self setProgress:[object countOfBytesSent] / ([object countOfBytesExpectedToSend] * 1.0f) animated:self.af_uploadProgressAnimated];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</div><div class="line">            if ([object countOfBytesExpectedToReceive] &gt; 0) &#123;</div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [self setProgress:[object countOfBytesReceived] / ([object countOfBytesExpectedToReceive] * 1.0f) animated:self.af_downloadProgressAnimated];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(state))]) &#123;</div><div class="line">            if ([(NSURLSessionTask *)object state] == NSURLSessionTaskStateCompleted) &#123;</div><div class="line">                @try &#123;</div><div class="line">                    [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(state))];</div><div class="line"></div><div class="line">                    if (context == AFTaskCountOfBytesSentContext) &#123;</div><div class="line">                        [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (context == AFTaskCountOfBytesReceivedContext) &#123;</div><div class="line">                        [object removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                @catch (NSException * __unused exception) &#123;&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>首先对countOfBytesExpectedToSend和countOfBytesExpectedToReceive分别处理：[object countOfBytesSent] / ([object countOfBytesExpectedToSend] <em> 1.0f，[object countOfBytesReceived] / ([object countOfBytesExpectedToReceive] </em> 1.0f)。两个百分比的计算方式不同。</li>
<li><p>再处理state，如果当前状态是完成：NSURLSessionTaskStateCompleted，移除当前的kvo对象。使用kvo的时候注意移除，否则会导致内存泄露。</p>
<h1 id="UIRefreshControl-AFNetworking"><a href="#UIRefreshControl-AFNetworking" class="headerlink" title="UIRefreshControl+AFNetworking"></a>UIRefreshControl+AFNetworking</h1><p>系统的刷新类的支持，使用的是从AFURLSessionManager里抛出的当前task状态通知：AFNetworkingTaskDidResumeNotification，AFNetworkingTaskDidSuspendNotification，AFNetworkingTaskDidCompleteNotification。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"> - (void)setRefreshingWithStateOfTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];</div><div class="line"></div><div class="line">    [notificationCenter removeObserver:self name:AFNetworkingTaskDidResumeNotification object:nil];</div><div class="line">    [notificationCenter removeObserver:self name:AFNetworkingTaskDidSuspendNotification object:nil];</div><div class="line">    [notificationCenter removeObserver:self name:AFNetworkingTaskDidCompleteNotification object:nil];</div><div class="line"></div><div class="line">    if (task) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wreceiver-is-weak&quot;</div><div class="line">#pragma clang diagnostic ignored &quot;-Warc-repeated-use-of-weak&quot;</div><div class="line">        if (task.state == NSURLSessionTaskStateRunning) &#123;</div><div class="line">            [self.refreshControl beginRefreshing];</div><div class="line"></div><div class="line">            [notificationCenter addObserver:self selector:@selector(af_beginRefreshing) name:AFNetworkingTaskDidResumeNotification object:task];</div><div class="line">            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingTaskDidCompleteNotification object:task];</div><div class="line">            [notificationCenter addObserver:self selector:@selector(af_endRefreshing) name:AFNetworkingTaskDidSuspendNotification object:task];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self.refreshControl endRefreshing];</div><div class="line">        &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p> 主要在resume状态的时候进行刷新动画，在complete、suspend状态下停止刷新动画。</p>
<h1 id="UIActivityIndicatorView-AFNetworking"><a href="#UIActivityIndicatorView-AFNetworking" class="headerlink" title="UIActivityIndicatorView+AFNetworking"></a>UIActivityIndicatorView+AFNetworking</h1><p> 跟UIRefreshControl封装思路一样。</p>
<h1 id="UIWebView-AFNetworking"><a href="#UIWebView-AFNetworking" class="headerlink" title="UIWebView+AFNetworking"></a>UIWebView+AFNetworking</h1><p>支持UIWebView的下载，网络部分使用的是NSURLSession部分的AFHTTPSessionManager的get方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">- (void)loadRequest:(NSURLRequest *)request</div><div class="line">           MIMEType:(NSString *)MIMEType</div><div class="line">   textEncodingName:(NSString *)textEncodingName</div><div class="line">           progress:(NSProgress * _Nullable __autoreleasing * _Nullable)progress</div><div class="line">            success:(NSData * (^)(NSHTTPURLResponse *response, NSData *data))success</div><div class="line">            failure:(void (^)(NSError *error))failure</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if (self.af_URLSessionTask.state == NSURLSessionTaskStateRunning || self.af_URLSessionTask.state == NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [self.af_URLSessionTask cancel];</div><div class="line">    &#125;</div><div class="line">    self.af_URLSessionTask = nil;</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    NSURLSessionDataTask *dataTask;</div><div class="line">    dataTask = [self.sessionManager</div><div class="line">            GET:request.URL.absoluteString</div><div class="line">            parameters:nil</div><div class="line">            progress:nil</div><div class="line">            success:^(NSURLSessionDataTask * _Nonnull task, id  _Nonnull responseObject) &#123;</div><div class="line">                __strong __typeof(weakSelf) strongSelf = weakSelf;</div><div class="line">                if (success) &#123;</div><div class="line">                    success((NSHTTPURLResponse *)task.response, responseObject);</div><div class="line">                &#125;</div><div class="line">                [strongSelf loadData:responseObject MIMEType:MIMEType textEncodingName:textEncodingName baseURL:[task.currentRequest URL]];</div><div class="line"></div><div class="line">                if ([strongSelf.delegate respondsToSelector:@selector(webViewDidStartLoad:)]) &#123;</div><div class="line">                    [strongSelf.delegate webViewDidFinishLoad:strongSelf];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            failure:^(NSURLSessionDataTask * _Nonnull task, NSError * _Nonnull error) &#123;</div><div class="line">                if (failure) &#123;</div><div class="line">                    failure(error);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">    self.af_URLSessionTask = dataTask;</div><div class="line">    if (progress != nil) &#123;</div><div class="line">        *progress = [self.sessionManager downloadProgressForTask:dataTask];</div><div class="line">    &#125;</div><div class="line">    [self.af_URLSessionTask resume];</div><div class="line"></div><div class="line">    if ([self.delegate respondsToSelector:@selector(webViewDidStartLoad:)]) &#123;</div><div class="line">        [self.delegate webViewDidStartLoad:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请求完成后， 如果成功会：<br>1）回调成功的数据<br>2）当前webview加载成功的数据<br>3）使用代理触发webViewDidStartLoad回调。</p>
<p>失败直接回调回去失败的error。</p>
<p>请求开始后，立刻触发webViewDidStartLoad的回调。对WebView的回调支持比较好。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MJRefresh源码解析]]></title>
      <url>http://semyonxu.com/2016/10/09/MJRefresh%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>本文主要解析一下MJRefresh这个刷新框架的封装思路以及一些技术在实际中的运用。</p>
<p>当前版本：v3.1.12</p>
<p>github地址：<a href="https://github.com/CoderMJLee/MJRefresh" target="_blank" rel="external">https://github.com/CoderMJLee/MJRefresh</a></p>
<p>首先看下结构图<br><img src="https://camo.githubusercontent.com/4a86d398d981df5dc845042b92c6d785d0d486b4/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67" alt=""></p>
<p>图有点大，大家可以点这里单独看：<a href="https://camo.githubusercontent.com/4a86d398d981df5dc845042b92c6d785d0d486b4/687474703a2f2f696d61676573302e636e626c6f67732e636f6d2f626c6f67323031352f3439373237392f3230313530362f3133323233323435363133393137372e706e67" target="_blank" rel="external">结构图</a></p>
<p>接下来我们顺着这个结构来逐步解析封装的思路。</p>
<a id="more"></a>
<h1 id="MJRefreshComponent基类"><a href="#MJRefreshComponent基类" class="headerlink" title="MJRefreshComponent基类"></a>MJRefreshComponent基类</h1><p>基类里面为我们捕获了当前的父view（UITableView、UICollectionVeiw等），然后使用KVO为我们做了一些滑动操作属性的监听，具体的处理需要交给子类去实现。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">    if (self = [super initWithFrame:frame]) &#123;</div><div class="line">        // 准备工作</div><div class="line">        [self prepare];</div><div class="line">        </div><div class="line">        // 默认是普通状态</div><div class="line">        self.state = MJRefreshStateIdle;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepare</div><div class="line">&#123;</div><div class="line">    // 基本属性</div><div class="line">    self.autoresizingMask = UIViewAutoresizingFlexibleWidth;</div><div class="line">    self.backgroundColor = [UIColor clearColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)layoutSubviews</div><div class="line">&#123;</div><div class="line">    [super layoutSubviews];</div><div class="line">    </div><div class="line">    [self placeSubviews];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubviews&#123;&#125;</div></pre></td></tr></table></figure>
<p>这里设计了两个方法，分别交给子类去使用。</p>
<ul>
<li>一个是preppare方法，触发是通过initWithFrame，这个方法是作用就是初始化一些基本的属性、状态等，倾向于数据方面的初始化。</li>
<li>一个是placeSubviews方法，触发是通过layoutSubviews。关于layoutSubviews的触发条件不清楚的同学可以Google一下。这个方法倾向于处理UI方面。</li>
</ul>
<h2 id="属性方法的转换处理"><a href="#属性方法的转换处理" class="headerlink" title="属性方法的转换处理"></a>属性方法的转换处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</div><div class="line">&#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    </div><div class="line">    // 如果不是UIScrollView，不做任何事情</div><div class="line">    if (newSuperview &amp;&amp; ![newSuperview isKindOfClass:[UIScrollView class]]) return;</div><div class="line">    </div><div class="line">    // 旧的父控件移除监听</div><div class="line">    [self removeObservers];</div><div class="line">    </div><div class="line">    if (newSuperview) &#123; // 新的父控件</div><div class="line">        // 设置宽度</div><div class="line">        self.mj_w = newSuperview.mj_w;</div><div class="line">        // 设置位置</div><div class="line">        self.mj_x = 0;</div><div class="line">        </div><div class="line">        // 记录UIScrollView</div><div class="line">        _scrollView = (UIScrollView *)newSuperview;</div><div class="line">        // 设置永远支持垂直弹簧效果</div><div class="line">        _scrollView.alwaysBounceVertical = YES;</div><div class="line">        // 记录UIScrollView最开始的contentInset</div><div class="line">        _scrollViewOriginalInset = _scrollView.contentInset;</div><div class="line">        </div><div class="line">        // 添加监听</div><div class="line">        [self addObservers];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)drawRect:(CGRect)rect</div><div class="line">&#123;</div><div class="line">    [super drawRect:rect];</div><div class="line">    </div><div class="line">    if (self.state == MJRefreshStateWillRefresh) &#123;</div><div class="line">        // 预防view还没显示出来就调用了beginRefreshing</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - KVO监听</div><div class="line">- (void)addObservers</div><div class="line">&#123;</div><div class="line">    NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;</div><div class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentOffset options:options context:nil];</div><div class="line">    [self.scrollView addObserver:self forKeyPath:MJRefreshKeyPathContentSize options:options context:nil];</div><div class="line">    self.pan = self.scrollView.panGestureRecognizer;</div><div class="line">    [self.pan addObserver:self forKeyPath:MJRefreshKeyPathPanState options:options context:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeObservers</div><div class="line">&#123;</div><div class="line">    [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentOffset];</div><div class="line">    [self.superview removeObserver:self forKeyPath:MJRefreshKeyPathContentSize];;</div><div class="line">    [self.pan removeObserver:self forKeyPath:MJRefreshKeyPathPanState];</div><div class="line">    self.pan = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context</div><div class="line">&#123;</div><div class="line">    // 遇到这些情况就直接返回</div><div class="line">    if (!self.userInteractionEnabled) return;</div><div class="line">    </div><div class="line">    // 这个就算看不见也需要处理</div><div class="line">    if ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [self scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 看不见</div><div class="line">    if (self.hidden) return;</div><div class="line">    if ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [self scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; else if ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [self scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change&#123;&#125;</div><div class="line">- (void)scrollViewContentSizeDidChange:(NSDictionary *)change&#123;&#125;</div><div class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change&#123;&#125;</div></pre></td></tr></table></figure>
<p>此处关键的切入点是继承父类的willMoveToSuperview方法，这个方法在刷新控件将要加载到父类的时候调用，这样我们可以获取到父类。然后如果是新的父类的话，首先初始化一些变量属性，然后添加KVO，KVO在这里的作用是监听@”contentOffset”，@”contentSize”以及@”state”属性的变化，来对header，footer做响应状态的处理。</p>
<p>此处为子类抛出了三个响应的方法（scrollViewContentOffsetDidChange…）可以继承下来，实现不同的功能。</p>
<h2 id="刷新状态的处理"><a href="#刷新状态的处理" class="headerlink" title="刷新状态的处理"></a>刷新状态的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#pragma mark 进入刷新状态</div><div class="line">- (void)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        self.alpha = 1.0;</div><div class="line">    &#125;];</div><div class="line">    self.pullingPercent = 1.0;</div><div class="line">    // 只要正在刷新，就完全显示</div><div class="line">    if (self.window) &#123;</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; else &#123;</div><div class="line">        self.state = MJRefreshStateWillRefresh;</div><div class="line">        // 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</div><div class="line">        [self setNeedsDisplay];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 结束刷新状态</div><div class="line">- (void)endRefreshing</div><div class="line">&#123;</div><div class="line">    self.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark 是否正在刷新</div><div class="line">- (BOOL)isRefreshing</div><div class="line">&#123;</div><div class="line">    return self.state == MJRefreshStateRefreshing || self.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开始结束刷新状态和判断是不是正在刷新状态，其中除了动画外，self.state是个很重要的属性，几乎所有的状态变化都是state的set方法里面实现，下面我们会在子类中解读。</p>
<h2 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)executeRefreshingCallback</div><div class="line">&#123;</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        if (self.refreshingBlock) &#123;</div><div class="line">            self.refreshingBlock();</div><div class="line">        &#125;</div><div class="line">        if ([self.refreshingTarget respondsToSelector:self.refreshingAction]) &#123;</div><div class="line">            MJRefreshMsgSend(MJRefreshMsgTarget(self.refreshingTarget), self.refreshingAction, self);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于回调方法，这里支持block和target:selecteor:两种。此处target方式的调用是用的封装的runtime宏，我们知道方法的调用实际上就是转换成objc_msgSend方法。</p>
<p>这种封装对于我们也是有借鉴意义的，如果写公共的框架，我们也是应该支持多种类型的回调的。最好再加一个delegate的方法。</p>
<h1 id="Header控件"><a href="#Header控件" class="headerlink" title="Header控件"></a>Header控件</h1><p>下面一步一步解析继承的子类的功能以及职责。</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p>继承自MJRefreshComponent基础父类。</p>
<p>本类的主要职责：<br>实现基本的页面刷新逻辑，负责解析出各个状态，然后对每个状态进行处理。（简单点说就是只是逻辑的实现，简单下拉，然后scrollView头部留出一点空，等待刷新完成，完成后空白消失）。</p>
<p>这里对contentoffset的状态的变化进行监听，并对结果处理成四种状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MJRefreshStateIdle = 1, /** 普通闲置状态 */MJRefreshStatePulling, /** 松开就可以进行刷新的状态 */MJRefreshStateRefreshing, /** 正在刷新中的状态 */MJRefreshStateWillRefresh, /** 即将刷新的状态 */</div><div class="line">mj</div></pre></td></tr></table></figure>
<h3 id="先解读一下初始化方法"><a href="#先解读一下初始化方法" class="headerlink" title="先解读一下初始化方法:"></a>先解读一下初始化方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock &#123;</div><div class="line">    MJRefreshHeader *cmp = [[self alloc] init];</div><div class="line">    cmp.refreshingBlock = refreshingBlock;</div><div class="line">    return cmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里封装了一个类方法，方便用户调用，并获取刷新的回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)prepare &#123;</div><div class="line">    [super prepare];</div><div class="line">    self.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</div><div class="line">    self.mj_h = MJRefreshHeaderHeight;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubViews &#123;</div><div class="line">    [super placeSubViews];</div><div class="line">    </div><div class="line">    // 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</div><div class="line">    self.mj_y =  - self.mj_h - self.ignoredScrollViewContentInsetTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后prepare就是跟之前说的一样，设置一下初始化值数据。而placeSubViews这里更新一下UI。</p>
<h3 id="通过contentofffset转换刷新的状态"><a href="#通过contentofffset转换刷新的状态" class="headerlink" title="通过contentofffset转换刷新的状态"></a>通过contentofffset转换刷新的状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentOffsetDidChange:change];</div><div class="line">    </div><div class="line">    // 在刷新的refreshing状态</div><div class="line">    if (self.state == MJRefreshStateRefreshing) &#123;</div><div class="line">        if (self.window == nil) return;</div><div class="line">        </div><div class="line">        // sectionheader停留解决</div><div class="line">        CGFloat insetT = - self.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - self.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</div><div class="line">        insetT = insetT &gt; self.mj_h + _scrollViewOriginalInset.top ? self.mj_h + _scrollViewOriginalInset.top : insetT;</div><div class="line">        self.scrollView.mj_insetT = insetT;</div><div class="line">        </div><div class="line">        self.insetTDelta = _scrollViewOriginalInset.top - insetT;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 跳转到下一个控制器时，contentInset可能会变</div><div class="line">     _scrollViewOriginalInset = self.scrollView.contentInset;</div><div class="line">    </div><div class="line">    // 当前的contentOffset</div><div class="line">    CGFloat offsetY = self.scrollView.mj_offsetY;</div><div class="line">    // 头部控件刚好出现的offsetY</div><div class="line">    CGFloat happenOffsetY = - self.scrollViewOriginalInset.top;</div><div class="line">    </div><div class="line">    // 如果是向上滚动到看不见头部控件，直接返回</div><div class="line">    // &gt;= -&gt; &gt;</div><div class="line">    if (offsetY &gt; happenOffsetY) return;</div><div class="line">    </div><div class="line">    // 普通 和 即将刷新 的临界点</div><div class="line">    CGFloat normal2pullingOffsetY = happenOffsetY - self.mj_h;</div><div class="line">    CGFloat pullingPercent = (happenOffsetY - offsetY) / self.mj_h;</div><div class="line">    </div><div class="line">    if (self.scrollView.isDragging) &#123; // 如果正在拖拽</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">        if (self.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</div><div class="line">            // 转为即将刷新状态</div><div class="line">            self.state = MJRefreshStatePulling;</div><div class="line">        &#125; else if (self.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</div><div class="line">            // 转为普通状态</div><div class="line">            self.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (self.state == MJRefreshStatePulling) &#123;// 即将刷新 &amp;&amp; 手松开</div><div class="line">        // 开始刷新</div><div class="line">        [self beginRefreshing];</div><div class="line">    &#125; else if (pullingPercent &lt; 1) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 根据状态做事情</div><div class="line">    if (state == MJRefreshStateIdle) &#123;</div><div class="line">        if (oldState != MJRefreshStateRefreshing) return;</div><div class="line">        </div><div class="line">        // 保存刷新时间</div><div class="line">        [[NSUserDefaults standardUserDefaults] setObject:[NSDate date] forKey:self.lastUpdatedTimeKey];</div><div class="line">        [[NSUserDefaults standardUserDefaults] synchronize];</div><div class="line">        </div><div class="line">        // 恢复inset和offset</div><div class="line">        [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">            self.scrollView.mj_insetT += self.insetTDelta;</div><div class="line">            </div><div class="line">            // 自动调整透明度</div><div class="line">            if (self.isAutomaticallyChangeAlpha) self.alpha = 0.0;</div><div class="line">        &#125; completion:^(BOOL finished) &#123;</div><div class="line">            self.pullingPercent = 0.0;</div><div class="line">            </div><div class="line">            if (self.endRefreshingCompletionBlock) &#123;</div><div class="line">                self.endRefreshingCompletionBlock();</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">    &#125; else if (state == MJRefreshStateRefreshing) &#123;</div><div class="line">         dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                CGFloat top = self.scrollViewOriginalInset.top + self.mj_h;</div><div class="line">                // 增加滚动区域top</div><div class="line">                self.scrollView.mj_insetT = top;</div><div class="line">                // 设置滚动位置</div><div class="line">                [self.scrollView setContentOffset:CGPointMake(0, -top) animated:NO];</div><div class="line">            &#125; completion:^(BOOL finished) &#123;</div><div class="line">                [self executeRefreshingCallback];</div><div class="line">            &#125;];</div><div class="line">         &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们一起解读一下这个刷新的过程。</p>
<p>首先，我们下拉刷新的时候，当前状态肯定是MJRefreshStateIdle（啰嗦一下：这个在MJRefreshComponent中initwithframe中有设置：self.state = MJRefreshStateIdle）。那么直接走下面的if判断，满足第一个if，当前操作是isDragging。这里计算出了拖拽所占的比例，也就下拉的百分比。</p>
<p>如果是MJRefreshStateIdle普通状态并超出下拉超出header的高度，那么状态立刻转换为MJRefreshStatePulling拖动中。</p>
<p>此时如果没有继续下拉，而是松手，那么就会走else if，立刻把状态转换回MJRefreshStateIdle。</p>
<p>此时如果继续下拉，那么走下面这个else if (self.state == MJRefreshStatePulling)，立刻调用beginRefreshing开始刷新。其实也就是把状态转换为MJRefreshStateRefreshing.看一下父类中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)beginRefreshing &#123;</div><div class="line">    [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        self.alpha = 1.0;</div><div class="line">    &#125;];</div><div class="line">    self.pullingPercent = 1.0;</div><div class="line">    if (self.window) &#123;</div><div class="line">        self.state = MJRefreshStateRefreshing;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        if (self.state != MJRefreshStateRefreshing) &#123;</div><div class="line">            self.state = MJRefreshStateWillRefresh;</div><div class="line">            [self setNeedsDisplay]; // 继续调用drawrect，这样延时，加了个willrefresh的state 意欲：预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里做了一个有时间长度的动画，多加了一个willRefresh的状态，我的理解是为了防止从另一个页面返回的时候self.window为空的时候，突然刷新会崩溃，需要一个状态来过渡。当然了当前的下拉比例是百分百了。</p>
<p>设置state = MJRefreshStateRefreshing，会调用state的setStaus方法，我们看到，这里直接对页面进行了header高度的偏移，使得整个header显示出来，然后在完成动画的时候回调回去，我们可以进行一些网络请求。</p>
<p>此时状态是MJRefreshStateRefreshing，继续监听会接着走第一个if：if (self.state == MJRefreshStateRefreshing)，这里重新设置了insetTop，也就是页面偏移到整个header的高度，好像跟setState有点重复。记录了一下insetTDelta值：：初始的top - insetTop, 这个值是刷新完恢复header位置用的。当然了，这里也是为了兼容，我们使用MJ之前设置过了insetTop，这里是在之前设置过的insetTop基础上再偏移的。然后就是return，下面的代码不会再执行。</p>
<p>直到我们的网络请求完成，触发endRefreshing方法，那么此时的状态会改变回去MJRefreshStateIdle。然后处理就是保存一下刷新的时间，通过这个insetTDelta恢复insetTop为原始值，完成后执行endRefreshingCompletionBlock回调。</p>
<h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>此部分继承自MJRefreshHeader，主要就是处理状态文字，不同状态下的提示文字是不同的。系统给我们提供了多语言版本的默认提示语，当然我们也可以自己设置我们的个性提示语：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)setTitle:(NSString *)title forState:(MJRefreshState)state &#123;</div><div class="line">    if (title == nil) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    self.stateTitles[@(state)] = title;</div><div class="line">    self.stateLabel.text = self.stateTitles[@(self.state)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>（不得不吐槽一下小码哥的代码格式，有的花括号跟方法一行，有的另起一行。对于有些洁癖的看官只好忍一下了。）<br>这里是用的state枚举值当做key来存的stateTitle值，使用的是字典。</p>
<p>还是使用这两个初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (void)prepare</div><div class="line">&#123;</div><div class="line">    [super prepare];</div><div class="line">    </div><div class="line">    // 初始化间距</div><div class="line">    self.labelLeftInset = MJRefreshLabelLeftInset;</div><div class="line">    </div><div class="line">    // 初始化文字</div><div class="line">    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</div><div class="line">    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</div><div class="line">    [self setTitle:[NSBundle mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)placeSubviews</div><div class="line">&#123;</div><div class="line">    [super placeSubviews];</div><div class="line">    </div><div class="line">    if (self.stateLabel.hidden) return;</div><div class="line">    </div><div class="line">    BOOL noConstrainsOnStatusLabel = self.stateLabel.constraints.count == 0;</div><div class="line">    </div><div class="line">    if (self.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        // 状态</div><div class="line">        if (noConstrainsOnStatusLabel) self.stateLabel.frame = self.bounds;</div><div class="line">    &#125; else &#123;</div><div class="line">        CGFloat stateLabelH = self.mj_h * 0.5;</div><div class="line">        // 状态</div><div class="line">        if (noConstrainsOnStatusLabel) &#123;</div><div class="line">            self.stateLabel.mj_x = 0;</div><div class="line">            self.stateLabel.mj_y = 0;</div><div class="line">            self.stateLabel.mj_w = self.mj_w;</div><div class="line">            self.stateLabel.mj_h = stateLabelH;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 更新时间</div><div class="line">        if (self.lastUpdatedTimeLabel.constraints.count == 0) &#123;</div><div class="line">            self.lastUpdatedTimeLabel.mj_x = 0;</div><div class="line">            self.lastUpdatedTimeLabel.mj_y = stateLabelH;</div><div class="line">            self.lastUpdatedTimeLabel.mj_w = self.mj_w;</div><div class="line">            self.lastUpdatedTimeLabel.mj_h = self.mj_h - self.lastUpdatedTimeLabel.mj_y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>prepare方法默认设置了状态文字，placeSubviews方法对文字Label进行处理。这里一共两个label，一个状态文字label，一个上次刷新时间label。并对隐藏一个或者全部做了页面布局的处理。</p>
<p>最后还是通过state的set方法来更新状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 设置状态文字</div><div class="line">    self.stateLabel.text = self.stateTitles[@(state)];</div><div class="line">    </div><div class="line">    // 重新设置key（重新显示时间）</div><div class="line">    self.lastUpdatedTimeKey = self.lastUpdatedTimeKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不得不说setState方法是核心处理方法，很重要。</p>
<h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><p>此部分继承自MJRefreshStateHeader，作用就是在添加了文字基础上，添加了动画部分，包括刷新的菊花和箭头。</p>
<p>箭头的添加方式跟文本添加是一样的，添加在了文本的左边，如果文本隐藏的话，箭头就居中了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 根据状态做事情</div><div class="line">    if (state == MJRefreshStateIdle) &#123;</div><div class="line">        if (oldState == MJRefreshStateRefreshing) &#123;</div><div class="line">            self.arrowView.transform = CGAffineTransformIdentity;</div><div class="line">            </div><div class="line">            [UIView animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">                self.loadingView.alpha = 0.0;</div><div class="line">            &#125; completion:^(BOOL finished) &#123;</div><div class="line">                // 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</div><div class="line">                if (self.state != MJRefreshStateIdle) return;</div><div class="line">                </div><div class="line">                self.loadingView.alpha = 1.0;</div><div class="line">                [self.loadingView stopAnimating];</div><div class="line">                self.arrowView.hidden = NO;</div><div class="line">            &#125;];</div><div class="line">        &#125; else &#123;</div><div class="line">            [self.loadingView stopAnimating];</div><div class="line">            self.arrowView.hidden = NO;</div><div class="line">            [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                self.arrowView.transform = CGAffineTransformIdentity;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125; else if (state == MJRefreshStatePulling) &#123;</div><div class="line">        [self.loadingView stopAnimating];</div><div class="line">        self.arrowView.hidden = NO;</div><div class="line">        [UIView animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">            self.arrowView.transform = CGAffineTransformMakeRotation(0.000001 - M_PI);</div><div class="line">        &#125;];</div><div class="line">    &#125; else if (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        self.loadingView.alpha = 1.0; // 防止refreshing -&gt; idle的动画完毕动作没有被执行</div><div class="line">        [self.loadingView startAnimating];</div><div class="line">        self.arrowView.hidden = YES;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在state的set方法中，添加了一个箭头的旋转动画。</p>
<h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>与MJRefreshNormalHeader类似，继承自MJRefreshStateHeader。是在文本类的基础上添加的带有普通动画的子类。</p>
<p>只不过这里加了拖动和刷新中的动画。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    // 根据状态做事情</div><div class="line">    if (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</div><div class="line">        NSArray *images = self.stateImages[@(state)];</div><div class="line">        if (images.count == 0) return;</div><div class="line">        </div><div class="line">        [self.gifView stopAnimating];</div><div class="line">        if (images.count == 1) &#123; // 单张图片</div><div class="line">            self.gifView.image = [images lastObject];</div><div class="line">        &#125; else &#123; // 多张图片</div><div class="line">            self.gifView.animationImages = images;</div><div class="line">            self.gifView.animationDuration = [self.stateDurations[@(state)] doubleValue];</div><div class="line">            [self.gifView startAnimating];</div><div class="line">        &#125;</div><div class="line">    &#125; else if (state == MJRefreshStateIdle) &#123;</div><div class="line">        [self.gifView stopAnimating];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用的是UIImageView的自带图片动画功能。我们可以直接传入图片数组来实现动画。当然如果不能满足我们的需求，我们是可以自己封装这一层，替换为自己的动画。</p>
<h1 id="Footer控件"><a href="#Footer控件" class="headerlink" title="Footer控件"></a>Footer控件</h1><p>Footer封装了两个分支子类：</p>
<ul>
<li>BackFooter(会回弹到底部的上拉刷新控件)</li>
<li>AutoFooter(会自动刷新的上拉刷新控件)</li>
</ul>
<h2 id="MJRefreshFooter"><a href="#MJRefreshFooter" class="headerlink" title="MJRefreshFooter"></a>MJRefreshFooter</h2><p>基础父类，是两种footer的共同父类。此处比Header的父类要简单一些，因为下面两个分支的逻辑处理还是不一样的，所以这里就简单的做了一些初始化工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)willMoveToSuperview:(UIView *)newSuperview</div><div class="line">&#123;</div><div class="line">    [super willMoveToSuperview:newSuperview];</div><div class="line">    </div><div class="line">    if (newSuperview) &#123;</div><div class="line">        // 监听scrollView数据的变化</div><div class="line">        if ([self.scrollView isKindOfClass:[UITableView class]] || [self.scrollView isKindOfClass:[UICollectionView class]]) &#123;</div><div class="line">            [self.scrollView setMj_reloadDataBlock:^(NSInteger totalDataCount) &#123;</div><div class="line">                if (self.isAutomaticallyHidden) &#123;</div><div class="line">                    self.hidden = (totalDataCount == 0);</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里可以设置自动隐藏Footer。前提是tableview或collectionview的数据源为空。</p>
<h2 id="AutoFooter"><a href="#AutoFooter" class="headerlink" title="AutoFooter"></a>AutoFooter</h2><p>自动上拉加载类。滑动到底部触发刷新动作，无需上拉操作。</p>
<h3 id="MJRefreshAutoFooter"><a href="#MJRefreshAutoFooter" class="headerlink" title="MJRefreshAutoFooter"></a>MJRefreshAutoFooter</h3><p>类似于MJRefreshHeader类的功能，将UI效果逻辑处理出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentOffsetDidChange:change];</div><div class="line">    </div><div class="line">    if (self.state != MJRefreshStateIdle || !self.automaticallyRefresh || self.mj_y == 0) return;</div><div class="line">    </div><div class="line">    if (_scrollView.mj_insetT + _scrollView.mj_contentH &gt; _scrollView.mj_h) &#123; // 内容超过一个屏幕</div><div class="line">        // 这里的_scrollView.mj_contentH替换掉self.mj_y更为合理</div><div class="line">        if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH - _scrollView.mj_h + self.mj_h * self.triggerAutomaticallyRefreshPercent + _scrollView.mj_insetB - self.mj_h) &#123; </div><div class="line">       		 /*</div><div class="line">        	// contentsize Height + bottom = scrollview content 全部展示高度。    注意此处的self.hegiht 包含在bottom里面</div><div class="line">            // _scrollView.mj_contentH +  _scrollView.mj_insetB - _scrollView.mj_h - self.mj_h * (1 - self.triggerAutomaticallyRefreshPercent)  </div><div class="line">             // if  self.triggerAutomaticallyRefreshPercent = 1, 跟下面的 第二中情况是一样的。 只是兼容了一下 可以显示self的多少比例，就刷新而已。 其实此处默认也是1.  但是这个方法比下面的方法，提前回调。呵呵。</div><div class="line">            // 这个方法跟下面的方法区别在于，下面的方法需要是手松开的情况下，达到临界值，而这个方法是不需要的，也就是条件更宽松。其实，如果手势滑动到底部情况下，这个方法，和下面的方法的处理是一样的。效果也是一样的。</div><div class="line">            */</div><div class="line">            // 防止手松开时连续调用</div><div class="line">            CGPoint old = [change[@&quot;old&quot;] CGPointValue];</div><div class="line">            CGPoint new = [change[@&quot;new&quot;] CGPointValue];</div><div class="line">            if (new.y &lt;= old.y) return;</div><div class="line">            </div><div class="line">            // 当底部刷新控件完全出现时，才刷新</div><div class="line">            [self beginRefreshing];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewPanStateDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewPanStateDidChange:change];</div><div class="line">    </div><div class="line">    if (self.state != MJRefreshStateIdle) return;</div><div class="line">    </div><div class="line">    if (_scrollView.panGestureRecognizer.state == UIGestureRecognizerStateEnded) &#123;// 手松开</div><div class="line">        if (_scrollView.mj_insetT + _scrollView.mj_contentH &lt;= _scrollView.mj_h) &#123;  // 不够一个屏幕</div><div class="line">            if (_scrollView.mj_offsetY &gt;= - _scrollView.mj_insetT) &#123; // 向上拽, 拽的浮度需要大于top的值 没有设置的话此处是mj_insetT = 0,注意此处的mj_offsetY已经默认是加了初始top的offset。 比如设置top 100 ，此处offset = -100 ，只要向上滑动一点，就可以执行下面的刷新。</div><div class="line">                [self beginRefreshing];</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123; // 超出一个屏幕, // 这个是需要拖一下。再加载， 正常情况下，下面这个开始加载是不会走的，只有设置automaticallyRefresh = NO 才会走这个。</div><div class="line">            if (_scrollView.mj_offsetY &gt;= _scrollView.mj_contentH + _scrollView.mj_insetB - _scrollView.mj_h) &#123; // 也就是比偏移量比contentH + Bottom 整个scrollview的显示内容 - scrollview的height还有大。 相等是到底部，大于就是有个拖动手势。</div><div class="line">                [self beginRefreshing];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里处理了contentOffset的变化以及Pan手势的改变状态回调。</p>
<h3 id="MJRefreshAutoStateFooter"><a href="#MJRefreshAutoStateFooter" class="headerlink" title="MJRefreshAutoStateFooter"></a>MJRefreshAutoStateFooter</h3><p>封装思路类似于MJRefreshStateHeader，不再赘述。</p>
<h3 id="MJRefreshAutoNormalFooter"><a href="#MJRefreshAutoNormalFooter" class="headerlink" title="MJRefreshAutoNormalFooter"></a>MJRefreshAutoNormalFooter</h3><p>封装思路类似于MJRefreshNormalHeader，不再赘述。</p>
<h3 id="MJRefreshAutoGifFooter"><a href="#MJRefreshAutoGifFooter" class="headerlink" title="MJRefreshAutoGifFooter"></a>MJRefreshAutoGifFooter</h3><p>封装思路类似于MJRefreshGifHeader，不再赘述。</p>
<h2 id="BackFooter"><a href="#BackFooter" class="headerlink" title="BackFooter"></a>BackFooter</h2><p>跟Header的封装思路是一样的，需要上拉才会触发刷新动作。</p>
<h3 id="MJRefreshBackFooter"><a href="#MJRefreshBackFooter" class="headerlink" title="MJRefreshBackFooter"></a>MJRefreshBackFooter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewContentOffsetDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentOffsetDidChange:change];</div><div class="line">    </div><div class="line">    // 如果正在刷新，直接返回</div><div class="line">    if (self.state == MJRefreshStateRefreshing) return;</div><div class="line">    </div><div class="line">    _scrollViewOriginalInset = self.scrollView.contentInset;</div><div class="line">    </div><div class="line">    // 当前的contentOffset</div><div class="line">    CGFloat currentOffsetY = self.scrollView.mj_offsetY;</div><div class="line">    // 尾部控件刚好出现的offsetY</div><div class="line">    CGFloat happenOffsetY = [self happenOffsetY];</div><div class="line">    // 如果是向下滚动到看不见尾部控件，直接返回</div><div class="line">    if (currentOffsetY &lt;= happenOffsetY) return;</div><div class="line">    </div><div class="line">    CGFloat pullingPercent = (currentOffsetY - happenOffsetY) / self.mj_h;</div><div class="line">    </div><div class="line">    // 如果已全部加载，仅设置pullingPercent，然后返回</div><div class="line">    if (self.state == MJRefreshStateNoMoreData) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (self.scrollView.isDragging) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">        // 普通 和 即将刷新 的临界点</div><div class="line">        CGFloat normal2pullingOffsetY = happenOffsetY + self.mj_h;</div><div class="line">        </div><div class="line">        if (self.state == MJRefreshStateIdle &amp;&amp; currentOffsetY &gt; normal2pullingOffsetY) &#123;</div><div class="line">            // 转为即将刷新状态</div><div class="line">            self.state = MJRefreshStatePulling;</div><div class="line">        &#125; else if (self.state == MJRefreshStatePulling &amp;&amp; currentOffsetY &lt;= normal2pullingOffsetY) &#123;</div><div class="line">            // 转为普通状态</div><div class="line">            self.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; else if (self.state == MJRefreshStatePulling) &#123;// 即将刷新 &amp;&amp; 手松开</div><div class="line">        // 开始刷新</div><div class="line">        [self beginRefreshing];</div><div class="line">    &#125; else if (pullingPercent &lt; 1) &#123;</div><div class="line">        self.pullingPercent = pullingPercent;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)scrollViewContentSizeDidChange:(NSDictionary *)change</div><div class="line">&#123;</div><div class="line">    [super scrollViewContentSizeDidChange:change];</div><div class="line">    </div><div class="line">    // 内容的高度</div><div class="line">    CGFloat contentHeight = self.scrollView.mj_contentH + self.ignoredScrollViewContentInsetBottom;</div><div class="line">    // 表格的高度</div><div class="line">    CGFloat scrollHeight = self.scrollView.mj_h - self.scrollViewOriginalInset.top - self.scrollViewOriginalInset.bottom + self.ignoredScrollViewContentInsetBottom;</div><div class="line">    // 设置位置和尺寸</div><div class="line">    self.mj_y = MAX(contentHeight, scrollHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对比之后，我们发现跟Header的思路基本一致。</p>
<h3 id="MJRefreshBackStateFooter"><a href="#MJRefreshBackStateFooter" class="headerlink" title="MJRefreshBackStateFooter"></a>MJRefreshBackStateFooter</h3><p>封装思路类似于MJRefreshStateHeader，不再赘述。</p>
<h3 id="MJRefreshBackNormalFooter"><a href="#MJRefreshBackNormalFooter" class="headerlink" title="MJRefreshBackNormalFooter"></a>MJRefreshBackNormalFooter</h3><p>封装思路类似于MJRefreshNormalHeader，不再赘述。</p>
<h3 id="MJRefreshBackGifFooter"><a href="#MJRefreshBackGifFooter" class="headerlink" title="MJRefreshBackGifFooter"></a>MJRefreshBackGifFooter</h3><p>封装思路类似于MJRefreshGifHeader，不再赘述。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Serialization]]></title>
      <url>http://semyonxu.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BSerialization/</url>
      <content type="html"><![CDATA[<p>本部分主要的作用：网络通信信息序列化/反序列化</p>
<h1 id="AFURLRequestSerialization"><a href="#AFURLRequestSerialization" class="headerlink" title="AFURLRequestSerialization"></a>AFURLRequestSerialization</h1><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><p>负责参数转换成NSMutableURLRequest类型，进行网络请求。</p>
<ol>
<li>构建普通请求：格式化请求参数，生成HTTP Header</li>
<li>构建multipart请求</li>
</ol>
<h2 id="类关系："><a href="#类关系：" class="headerlink" title="类关系："></a>类关系：</h2><p>父类：</p>
<ul>
<li>AFHTTPRequestSerializer,二进制格式（query字符串转换成二进制）</li>
</ul>
<p>子类：</p>
<ul>
<li>AFJSONRequestSerializer,Json格式（Json序列化成NSData类型）</li>
<li>AFPropertyListRequestSerializer，Plist（一种特殊的XML，解析起来相对容易）<a id="more"></a>
</li>
</ul>
<h2 id="封装思路："><a href="#封装思路：" class="headerlink" title="封装思路："></a>封装思路：</h2><p>所有类遵循一个协议AFURLRequestSerialization，协议中一个非必须实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (nullableNSURLRequest*)requestBySerializingRequest:(NSURLRequest*)request</div><div class="line">                                withParameters:(nullableid)parameters</div><div class="line">                                   error:(NSError* _Nullable__autoreleasing *)error NS_SWIFT_NOTHROW;</div></pre></td></tr></table></figure>
<p>父类AFHTTPRequestSerializer中提供外部调用接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSMutableURLRequest*)requestWithMethod:(NSString*)method</div><div class="line">                                 URLString:(NSString*)URLString</div><div class="line">                                parameters:(id)parameters</div><div class="line">                                     error:(NSError*__autoreleasing*)error</div></pre></td></tr></table></figure>
<p>在这个方法中调用协议方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mutableRequest = [[selfrequestBySerializingRequest:mutableRequestwithParameters:parameterserror:error]mutableCopy];</div></pre></td></tr></table></figure>
<p>而这个方法的实现是父类以及各个子类分别实现。所以，此处self如果是AFHTTPRequestSerializer那么走AFHTTPRequestSerializer类下的实现，如果是<br>AFJSONRequestSerializer，那么走AFJSONRequestSerializer类下的实现。然后再分别实现这个方法不同功能的实现。</p>
<p>下面看一下各个类不同职能分别的实现：</p>
<p>AFURLRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [requestmutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeadersenumerateKeysAndObjectsUsingBlock:^(id field,id value, BOOL *__unused stop) &#123;</div><div class="line">        if (![requestvalueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:valueforHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    NSString *query =nil;</div><div class="line">    if (parameters) &#123;</div><div class="line">        if (self.queryStringSerialization) &#123;</div><div class="line">            NSError *serializationError;</div><div class="line">            query = self.queryStringSerialization(request, parameters, &amp;serializationError);</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                if (error) &#123;</div><div class="line">                    *error = serializationError;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                returnnil;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            switch (self.queryStringSerializationStyle) &#123;</div><div class="line">                caseAFHTTPRequestQueryStringDefaultStyle:</div><div class="line">                    query = AFQueryStringFromParameters(parameters);</div><div class="line">                    break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURIcontainsObject:[[request HTTPMethod]uppercaseString]]) &#123; //普通GET，HEAD等，参数直接拼接在url后面用&amp;分开</div><div class="line">        if (query &amp;&amp; query.length &gt;0) &#123;</div><div class="line">            mutableRequest.URL = [NSURLURLWithString:[[mutableRequest.URLabsoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]];</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // #2864: an empty string is a valid x-www-form-urlencoded payload</div><div class="line">        if (!query) &#123;</div><div class="line">            query = @&quot;&quot;;</div><div class="line">        &#125;</div><div class="line">        if (![mutableRequestvalueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot;forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line">        [mutableRequest setHTTPBody:[querydataUsingEncoding:self.stringEncoding]];// 普通的POST请求参数，直接转换成NSData设置到HTTP的body中。</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到AFNetworking对于GET，POST请求参数的处理，一个是直接拼接在URL上面，一个是设置在HTTPBody里面。</p>
<p>其中，HTTPMethodsEncodingParametersInURI的初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.HTTPMethodsEncodingParametersInURI = [NSSet setWithObjects:@&quot;GET&quot;, @&quot;HEAD&quot;, @&quot;DELETE&quot;, nil]; // 支持GET，HEAD，DELETE</div></pre></td></tr></table></figure>
<p>也就是GET,HEAD,DELETE支持的是参数直接拼接URL的方式。</p>
<p>AFJSONRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;]; // 设置公共的请求头</div><div class="line"></div><div class="line">    if (parameters) &#123;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/json&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [mutableRequest setHTTPBody:[NSJSONSerialization dataWithJSONObject:parameters options:self.writingOptions error:error]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跟AFURLRequestSerialization中的实现差不多，如果是HTTPMethodsEncodingParametersInURI请求方式是GET，HEAD，DELETE，则直接调用父类的解析方法。如果是POST等其他的，那么做了一下设置请求头Content-Type = “application/json”,并且将paramters参数Json序列化成NSData,设置到HTTPBody里面。</p>
<p>AFPropertyListRequestSerialization中的实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request</div><div class="line">                               withParameters:(id)parameters</div><div class="line">                                        error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(request);</div><div class="line"></div><div class="line">    if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</div><div class="line">        return [super requestBySerializingRequest:request withParameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSMutableURLRequest *mutableRequest = [request mutableCopy];</div><div class="line"></div><div class="line">    [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) &#123;</div><div class="line">        if (![request valueForHTTPHeaderField:field]) &#123;</div><div class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if (parameters) &#123;</div><div class="line">        if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) &#123;</div><div class="line">            [mutableRequest setValue:@&quot;application/x-plist&quot; forHTTPHeaderField:@&quot;Content-Type&quot;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [mutableRequest setHTTPBody:[NSPropertyListSerialization dataWithPropertyList:parameters format:self.format options:self.writeOptions error:error]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return mutableRequest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好吧，封装思路跟AFJSONRequestSerialization一样，区别在于json序列化变成Plist的转换。</p>
<h1 id="AFURLResponseSerialization"><a href="#AFURLResponseSerialization" class="headerlink" title="AFURLResponseSerialization"></a>AFURLResponseSerialization</h1><h2 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h2><p>负责对网络请求返回的数据进行解析。</p>
<h2 id="类关系：-1"><a href="#类关系：-1" class="headerlink" title="类关系："></a>类关系：</h2><p>父类：</p>
<ul>
<li>AFHTTPResponseSerializer，二进制格式</li>
</ul>
<p>子类： </p>
<ul>
<li>AFJSONResponseSerializer, JSON格式</li>
<li>AFXMLParseResponseSerializer, XML（只能返回XMLParser，还需要自己通过代理解析）</li>
<li>AFXMLDocumentResponseSerializer, （Mac OS X）</li>
<li>AFPropertyListResponseSerializer,  Plist</li>
<li>AFImageResponseSerializer,  Image</li>
<li>AFCompoundResponseSerializer, 组合</li>
</ul>
<h2 id="封装思路：-1"><a href="#封装思路：-1" class="headerlink" title="封装思路："></a>封装思路：</h2><p>跟Request的封装思路基本相同。只不过这个是在数据请求到之后进行的处理。遵循的是AFURLResponseSerialization协议。实现方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div></pre></td></tr></table></figure>
<p>此处的返回值是id类型的，也就是数据解析完之后的数据。</p>
<p>顺便提一下返回值解析的调用函数是在AFURLSessionManager中的网络请求成功的回调中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">            if (self.completionHandler) &#123;</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 此处进行数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123;</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                if (self.completionHandler) &#123;</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看一下各个类不同职能分别的实现：<br>父类AFHTTPResponseSerializer 中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    [self validateResponse:(NSHTTPURLResponse *)response data:data error:error];</div><div class="line"></div><div class="line">    return data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处就一个方法，就是做了一个返回的数据是否有效。但是数据是否有错，都会返回原始数据，没有做任何的修改。<br>看一下返回数据有效性的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- (BOOL)validateResponse:(NSHTTPURLResponse *)response</div><div class="line">                    data:(NSData *)data</div><div class="line">                   error:(NSError * __autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    BOOL responseIsValid = YES;</div><div class="line">    NSError *validationError = nil;</div><div class="line"></div><div class="line">    if (response &amp;&amp; [response isKindOfClass:[NSHTTPURLResponse class]]) &#123;</div><div class="line">        if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</div><div class="line">            !([response MIMEType] == nil &amp;&amp; [data length] == 0)) &#123;</div><div class="line"></div><div class="line">            if ([data length] &gt; 0 &amp;&amp; [response URL]) &#123;</div><div class="line">                NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                                          NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: unacceptable content-type: %@&quot;, @&quot;AFNetworking&quot;, nil), [response MIMEType]],</div><div class="line">                                                          NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                                          AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                                        &#125; mutableCopy];</div><div class="line">                if (data) &#123;</div><div class="line">                    mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorCannotDecodeContentData userInfo:mutableUserInfo], validationError);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) &#123;</div><div class="line">            NSMutableDictionary *mutableUserInfo = [@&#123;</div><div class="line">                                               NSLocalizedDescriptionKey: [NSString stringWithFormat:NSLocalizedStringFromTable(@&quot;Request failed: %@ (%ld)&quot;, @&quot;AFNetworking&quot;, nil), [NSHTTPURLResponse localizedStringForStatusCode:response.statusCode], (long)response.statusCode],</div><div class="line">                                               NSURLErrorFailingURLErrorKey:[response URL],</div><div class="line">                                               AFNetworkingOperationFailingURLResponseErrorKey: response,</div><div class="line">                                       &#125; mutableCopy];</div><div class="line"></div><div class="line">            if (data) &#123;</div><div class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            validationError = AFErrorWithUnderlyingError([NSError errorWithDomain:AFURLResponseSerializationErrorDomain code:NSURLErrorBadServerResponse userInfo:mutableUserInfo], validationError);</div><div class="line"></div><div class="line">            responseIsValid = NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error &amp;&amp; !responseIsValid) &#123;</div><div class="line">        *error = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseIsValid;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要做了判断是不是支持的返回content-type类型，再就是状态码是不是200+，如果不满足就不是有效的返回数据。<br>看下初始化值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.acceptableContentTypes = [NSSet setWithObjects:@&quot;application/json&quot;, @&quot;text/json&quot;, @&quot;text/javascript&quot;, nil];</div><div class="line">self.acceptableStatusCodes = [NSIndexSet indexSetWithIndexesInRange:NSMakeRange(200, 100)];</div></pre></td></tr></table></figure>
<p>子类AFJSONResponseSerializer中的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (id)responseObjectForResponse:(NSURLResponse *)response</div><div class="line">                           data:(NSData *)data</div><div class="line">                          error:(NSError *__autoreleasing *)error</div><div class="line">&#123;</div><div class="line">    if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) &#123;</div><div class="line">        if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) &#123;</div><div class="line">            return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    id responseObject = nil;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    // Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</div><div class="line">    // See https://github.com/rails/rails/issues/1742</div><div class="line">    BOOL isSpace = [data isEqualToData:[NSData dataWithBytes:&quot; &quot; length:1]];</div><div class="line">    if (data.length &gt; 0 &amp;&amp; !isSpace) &#123;</div><div class="line">        responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError];</div><div class="line">    &#125; else &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</div><div class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, self.readingOptions);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return responseObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此处看到在父类中对有效性的判断结果并没有做处理，而在Json转换类中，如果返回数据是无效的，直接就返回nil。然后就是对返回数据进行了Json转换。并对结果进行了空值进行了排空。</p>
<p>其他的子类的封装思路也都相似，不再一一赘述。注意的是不同的功能的子类对返回值的类型支持是不同的。</p>
<p>如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之Reachability]]></title>
      <url>http://semyonxu.com/2016/09/30/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BReachability/</url>
      <content type="html"><![CDATA[<p>Reachability这部分主要负责网络的状态网络状态的监听。</p>
<h1 id="首先介绍下使用方法。"><a href="#首先介绍下使用方法。" class="headerlink" title="首先介绍下使用方法。"></a>首先介绍下使用方法。</h1><p>这里介绍三种使用方法：</p>
<h2 id="直接使用单利，调用"><a href="#直接使用单利，调用" class="headerlink" title="直接使用单利，调用"></a>直接使用单利，调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">AFNetworkReachabilityManager *reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">[reachabilityManager startMonitoring];</div><div class="line">[reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="使用AFURLSessionManager的属性调用"><a href="#使用AFURLSessionManager的属性调用" class="headerlink" title="使用AFURLSessionManager的属性调用"></a>使用AFURLSessionManager的属性调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithBaseURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;] sessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">  sessionManager.responseSerializer = [AFHTTPResponseSerializer serializer];</div><div class="line">  [sessionManager.reachabilityManager startMonitoring];</div><div class="line">  [sessionManager.reachabilityManager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">      NSLog(@&quot;status %ld&quot;, (long)status);</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<h2 id="使用通知中心的模式，监听"><a href="#使用通知中心的模式，监听" class="headerlink" title="使用通知中心的模式，监听"></a>使用通知中心的模式，监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(reachabilityCallBack:) name:AFNetworkingReachabilityDidChangeNotification object:nil];</div><div class="line"></div><div class="line"></div><div class="line">- (void)reachabilityCallBack:(NSNotification *)sender &#123;</div><div class="line">    NSDictionary *userInfo = sender.userInfo;</div><div class="line">    AFNetworkReachabilityStatus netStatus = [userInfo[@&quot;AFNetworkingReachabilityNotificationStatusItem&quot;] integerValue];</div><div class="line">    NSLog(@&quot;netStatus %ld &quot;, netStatus);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法还是比较简单的。</p>
<h1 id="下面分析下源码"><a href="#下面分析下源码" class="headerlink" title="下面分析下源码"></a>下面分析下源码</h1><h2 id="初始化网络监听"><a href="#初始化网络监听" class="headerlink" title="初始化网络监听"></a>初始化网络监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager;</div><div class="line"></div><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">+ (instancetype)managerForDomain:(NSString *)domain;</div><div class="line"></div><div class="line">+ (instancetype)managerForAddress:(const void *)address;</div><div class="line"></div><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>以上均是初始化方法，我们可以直接用单利模式，比较方便的进行初始化对象，也可以直接用manager，建议还是用单利，因为单利里面也是调用的manager：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)sharedManager &#123;</div><div class="line">    static AFNetworkReachabilityManager *_sharedManager = nil;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _sharedManager = [self manager];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return _sharedManager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>manager是直接使用的managerForAdress方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager</div><div class="line">&#123;</div><div class="line">#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;&amp; __IPHONE_OS_VERSION_MIN_REQUIRED &gt;= 90000) || (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;&amp; __MAC_OS_X_VERSION_MIN_REQUIRED &gt;= 101100)</div><div class="line">    struct sockaddr_in6 address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin6_len = sizeof(address);</div><div class="line">    address.sin6_family = AF_INET6;</div><div class="line">#else</div><div class="line">    struct sockaddr_in address;</div><div class="line">    bzero(&amp;address, sizeof(address));</div><div class="line">    address.sin_len = sizeof(address);</div><div class="line">    address.sin_family = AF_INET;</div><div class="line">#endif</div><div class="line">    return [self managerForAddress:&amp;address];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然我们也可以使用初始化domain的方法，然后转换成SCNetworkReachabilityRef对象，进行初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)managerForDomain:(NSString *)domain &#123;</div><div class="line">    SCNetworkReachabilityRef reachability = SCNetworkReachabilityCreateWithName(kCFAllocatorDefault, [domain UTF8String]);</div><div class="line"></div><div class="line">    AFNetworkReachabilityManager *manager = [[self alloc] initWithReachability:reachability];</div><div class="line">    </div><div class="line">    CFRelease(reachability);</div><div class="line"></div><div class="line">    return manager;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 初始化方法里面只是做了一个retain，和初始化网络状态，目测SCNetworkReachabilityRef是不支持自动内存管理的。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithReachability:(SCNetworkReachabilityRef)reachability &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _networkReachability = CFRetain(reachability);</div><div class="line">    self.networkReachabilityStatus = AFNetworkReachabilityStatusUnknown;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="开始监听网络状态"><a href="#开始监听网络状态" class="headerlink" title="开始监听网络状态"></a>开始监听网络状态</h2><p>我们之间调用startMonitoring方法，进行开始网络状态的监控：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoring &#123;</div><div class="line">    [self stopMonitoring];</div><div class="line"></div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __weak __typeof(self)weakSelf = self;</div><div class="line">    AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">        __strong __typeof(weakSelf)strongSelf = weakSelf;</div><div class="line"></div><div class="line">        strongSelf.networkReachabilityStatus = status;</div><div class="line">        if (strongSelf.networkReachabilityStatusBlock) &#123;</div><div class="line">            strongSelf.networkReachabilityStatusBlock(status);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    SCNetworkReachabilityContext context = &#123;0, (__bridge void *)callback, AFNetworkReachabilityRetainCallback, AFNetworkReachabilityReleaseCallback, NULL&#125;;</div><div class="line">    SCNetworkReachabilitySetCallback(self.networkReachability, AFNetworkReachabilityCallback, &amp;context);</div><div class="line">    SCNetworkReachabilityScheduleWithRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0),^&#123;</div><div class="line">        SCNetworkReachabilityFlags flags;</div><div class="line">        if (SCNetworkReachabilityGetFlags(self.networkReachability, &amp;flags)) &#123;</div><div class="line">            AFPostReachabilityStatusChange(flags, callback);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法比较简单，此处我们可以看到，做了数据保护工作，如果没有初始化会return，首先先stopMonitoring，这样做可以避免生成多个监听网络的对象，导致收到多个成功的回调。<br>然后是一个网络状态捕获到的回调。<br>下面才是使用的SystemConfiguration框架下的SCNetworkReachability的API来做的处理，使用也比较简单，先初始化，然后设置回调block，再对回调的C数据转换成网络状态的枚举类型，最后放到了RunLoop里面，设置到了主RunLoop，并设置model为CommonModes，CommonModes就是普通的和事件处理Mode的集合，不清楚的可以去看RunLoop相关文档。</p>
<h2 id="结束监听网络状态"><a href="#结束监听网络状态" class="headerlink" title="结束监听网络状态"></a>结束监听网络状态</h2><p>结束也比较简单，当然，我们可以自己调用，也可以不调用。因为在类销毁的时候，dealloc中也调用了这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (void)stopMonitoring &#123;</div><div class="line">    if (!self.networkReachability) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SCNetworkReachabilityUnscheduleFromRunLoop(self.networkReachability, CFRunLoopGetMain(), kCFRunLoopCommonModes);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再看一下网络状态的枚举，也就是我们可以捕获到的网络状态有哪些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, AFNetworkReachabilityStatus) &#123;</div><div class="line">    AFNetworkReachabilityStatusUnknown          = -1,</div><div class="line">    AFNetworkReachabilityStatusNotReachable     = 0,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWWAN = 1,</div><div class="line">    AFNetworkReachabilityStatusReachableViaWiFi = 2,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>默认是Unknown未知，然后是网络不可达，无线广域网链接，WiFi链接，此处没有区分2G/3G/4G,所以需要使用的小伙伴还得自行处理。</p>
<p>当然AF也为我们提供了获取的属性方法，我们可以直接调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, assign, getter = isReachable) BOOL reachable;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WWAN.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWWAN) BOOL reachableViaWWAN;</div><div class="line"></div><div class="line">/**</div><div class="line"> Whether or not the network is currently reachable via WiFi.</div><div class="line"> */</div><div class="line">@property (readonly, nonatomic, assign, getter = isReachableViaWiFi) BOOL reachableViaWiFi;</div></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isReachable &#123;</div><div class="line">    return [self isReachableViaWWAN] || [self isReachableViaWiFi];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWWAN &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWWAN;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isReachableViaWiFi &#123;</div><div class="line">    return self.networkReachabilityStatus == AFNetworkReachabilityStatusReachableViaWiFi;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，我们可以拿到网络是不是可达，当前是不是状态WWAN，WiFi。使用比较方便。</p>
<p>基本就是这些了，如果文中有什么错误，欢迎大家指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AFNetworking 3.0 源码解析之NSURLSession]]></title>
      <url>http://semyonxu.com/2016/09/28/AFNetworking-3-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BNSURLSession/</url>
      <content type="html"><![CDATA[<p>NSURLSession是AFNetworking的核心部分，主要负责网络通信部分。</p>
<p>下面分两个部分来解析：<br> 父类：AFURLSessionManager，<br> 子类：AFHTTPSessionManager</p>
<p>父类AFURLSessionManager对系统的NSURLSession类的网络请求进行了封装，并把NSURLSession里面的delegate返回值通过block返回回去。<br>子类AFHTTPSessionManager继承了所有父类的功能，在这个基础上封装了支持GET，POST，PUT，HEAD，PATCH，DELETE等HTTP请求方式，使用更加方便。当然不用子类，也是可以直接进行网络请求的。<br><a id="more"></a></p>
<h1 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h1><h2 id="先看初始化方法"><a href="#先看初始化方法" class="headerlink" title="先看初始化方法"></a>先看初始化方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">  - (instancetype)init &#123;</div><div class="line">    return [self initWithSessionConfiguration:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!configuration) &#123;</div><div class="line">        configuration = [NSURLSessionConfiguration defaultSessionConfiguration];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    self.sessionConfiguration = configuration;</div><div class="line"></div><div class="line">    self.operationQueue = [[NSOperationQueue alloc] init];</div><div class="line">    self.operationQueue.maxConcurrentOperationCount = 1; // 最大并发数量1，不允许并发？当前请求任务只能是一个。</div><div class="line"></div><div class="line">    self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; // 代理的设置在这里。我找的好苦啊。。。</div><div class="line"></div><div class="line">    self.responseSerializer = [AFJSONResponseSerializer serializer];</div><div class="line"></div><div class="line">    self.securityPolicy = [AFSecurityPolicy defaultPolicy];</div><div class="line"></div><div class="line">#if !TARGET_OS_WATCH</div><div class="line">    self.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</div><div class="line">#endif</div><div class="line"></div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init];</div><div class="line"></div><div class="line">    self.lock = [[NSLock alloc] init];</div><div class="line">    self.lock.name = AFURLSessionManagerLockName;</div><div class="line"></div><div class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">        for (NSURLSessionDataTask *task in dataTasks) &#123;</div><div class="line">            [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123;</div><div class="line">            [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123;</div><div class="line">            [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里对各个属性进行了基本的初始化，为session初始化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.session = [NSURLSessionsessionWithConfiguration:self.sessionConfigurationdelegate:selfdelegateQueue:self.operationQueue];</div></pre></td></tr></table></figure>
<p>我们可以看到是用的系统NSURLSession的初始化方法。</p>
<p>此处会遍历所有task添加delegate方法，猜测是兼容上次为未完成的请求Task，再继续进行处理，具体还得看情况，因为我跟了多次都是没有走这个方法。</p>
<h2 id="网络请求支持的几个方法"><a href="#网络请求支持的几个方法" class="headerlink" title="网络请求支持的几个方法"></a>网络请求支持的几个方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///---------------------------</div><div class="line">/// @name Running Upload Tasks</div><div class="line">///---------------------------</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromFile:(NSURL *)fileURL</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError  * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                         fromData:(nullable NSData *)bodyData</div><div class="line">                                         progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionUploadTask *)uploadTaskWithStreamedRequest:(NSURLRequest *)request</div><div class="line">                                                 progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock</div><div class="line">                                        completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">///-----------------------------</div><div class="line">/// @name Running Download Tasks</div><div class="line">///-----------------------------</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithRequest:(NSURLRequest *)request</div><div class="line">                                             progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                          destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                    completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div><div class="line"></div><div class="line">- (NSURLSessionDownloadTask *)downloadTaskWithResumeData:(NSData *)resumeData</div><div class="line">                                                progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock</div><div class="line">                                             destination:(nullable NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                                       completionHandler:(nullable void (^)(NSURLResponse *response, NSURL * _Nullable filePath, NSError * _Nullable error))completionHandler;</div></pre></td></tr></table></figure>
<p>这里面封装了系统NSURLSession的dataTask、uploadTask、downloadTask方法。而且另外添加了数据的进度progress。</p>
<p>下面我们来解析一下实现原理：<br>首先看一下dataTask的请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request</div><div class="line">                               uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">                             downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                            completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject,  NSError * _Nullable error))completionHandler &#123;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    url_session_manager_create_task_safely(^&#123;</div><div class="line">        dataTask = [self.session dataTaskWithRequest:request]; // 核心方法，NSURLSessionDataTask的dataTask方法。</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    [self addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler]; // 设置代理，所有进度的处理都在代理中。进度的回调。</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，这里使用的是NSURLSessionDataTask的dataTaskWithRequest:方法，这个地方加了数据保护。然后就是为这个dataTask添加代理。所以核心的工作都交个这个代理AFURLSessionManagerTaskDelegate类来处理，那么这个代理的作用就显得尤为重要。</p>
<h2 id="网络请求的代理类AFURLSessionManagerTaskDelegate"><a href="#网络请求的代理类AFURLSessionManagerTaskDelegate" class="headerlink" title="网络请求的代理类AFURLSessionManagerTaskDelegate"></a>网络请求的代理类AFURLSessionManagerTaskDelegate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface AFURLSessionManagerTaskDelegate : NSObject &lt;NSURLSessionTaskDelegate, NSURLSessionDataDelegate, NSURLSessionDownloadDelegate&gt;</div><div class="line">@property (nonatomic, weak) AFURLSessionManager *manager;</div><div class="line">@property (nonatomic, strong) NSMutableData *mutableData;</div><div class="line">@property (nonatomic, strong) NSProgress *uploadProgress;</div><div class="line">@property (nonatomic, strong) NSProgress *downloadProgress;</div><div class="line">@property (nonatomic, copy) NSURL *downloadFileURL;</div><div class="line">@property (nonatomic, copy) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading; // 下载任务结束回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock uploadProgressBlock; // 上传进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskProgressBlock downloadProgressBlock; // 下载进度回调</div><div class="line">@property (nonatomic, copy) AFURLSessionTaskCompletionHandler completionHandler; // 返回成功结果的Block</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里遵循了NSURLSessionDataDelegate,NSURLSessionDataDelegate,NSURLSessionDownloadDelegate,所以是将NSURLSession的基本代理功能封装了一下。然后会对这些代理方法的返回数据进行处理，使用completionHandler Block来进行返回。</p>
<p>首先来看下代理的核心部分，然后再解读progress的封装思路</p>
<h3 id="代理的核心部分"><a href="#代理的核心部分" class="headerlink" title="代理的核心部分"></a>代理的核心部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">#pragma mark - NSURLSessionTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">    __strong AFURLSessionManager *manager = self.manager;</div><div class="line"></div><div class="line">    __block id responseObject = nil;</div><div class="line"></div><div class="line">    __block NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];</div><div class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</div><div class="line"></div><div class="line">    //Performance Improvement from #2672</div><div class="line">    NSData *data = nil;</div><div class="line">    if (self.mutableData) &#123;</div><div class="line">        data = [self.mutableData copy];</div><div class="line">        //We no longer need the reference, so nil it out to gain back some memory.</div><div class="line">        self.mutableData = nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.downloadFileURL) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = self.downloadFileURL;</div><div class="line">    &#125; else if (data) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (error) &#123;</div><div class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</div><div class="line"></div><div class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // 单利group对象，why？这样是不是就可以对多个返回结果进行处理，这样的话，就不用顺序等待了，哪个先完成就先返回回去。</div><div class="line">            // 看参数：如果用户传了group对象，那么选择的是用户的，否则直接使用单利的组对象。 队列是默认是主队列，用户填写的就是用户的。</div><div class="line">            if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                self.completionHandler(task.response, responseObject, error);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        dispatch_async(url_session_manager_processing_queue(), ^&#123;</div><div class="line">            NSError *serializationError = nil;</div><div class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; // 成功后数据的解析</div><div class="line"></div><div class="line">            if (self.downloadFileURL) &#123; // 下载的情况下，responseObject为下载的本地地址</div><div class="line">                responseObject = self.downloadFileURL;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (responseObject) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if (serializationError) &#123;</div><div class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123; // why use gcd group?</div><div class="line">                if (self.completionHandler) &#123; // 最终的回调结果</div><div class="line">                    self.completionHandler(task.response, responseObject, serializationError); // response Header, 返回结果， 解析错误。</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123; // 此处任务完成的通知只是为了UIKit中的一些类别中拿到回调。userInfo字段并没有返回给外部，而是给UIKit用的。当然我们可以用这个通知来获取到。</div><div class="line">                    [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</div><div class="line">                &#125;);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">#pragma clang diagnostic pop</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDataTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(__unused NSURLSession *)session</div><div class="line">          dataTask:(__unused NSURLSessionDataTask *)dataTask</div><div class="line">    didReceiveData:(NSData *)data</div><div class="line">&#123;</div><div class="line">    [self.mutableData appendData:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - NSURLSessionDownloadTaskDelegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    NSError *fileManagerError = nil;</div><div class="line">    self.downloadFileURL = nil;</div><div class="line"></div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        self.downloadFileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location);</div><div class="line">        if (self.downloadFileURL) &#123;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:self.downloadFileURL error:&amp;fileManagerError];</div><div class="line"></div><div class="line">            if (fileManagerError) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到这里核心的方法只有三个，一个是task完成的回调，一个是接受到数据的回调，最后是下载完成的回调。<br>普通的task请求会先走第二个方法didReceiveData方法，把返回的数据添加到mutableData中。<br>然后再走第一个方法，请求完成的回调。</p>
<h4 id="第一个方法："><a href="#第一个方法：" class="headerlink" title="第一个方法："></a>第一个方法：</h4><p>首先会把返回的数据赋给一个局部变量data，然后将全局的mutableData置空，这样就可以保证下次请求的数据是重新加载。这里区分了下载和普通的数据返回，如果是下载的话，直接下载到指定文件路径中，如果用户指定这个路径的话，userInfo字典里面存的就是下载路径，否则，存的是下载数据。<br>然后就是判断有没有错误，错误的话把错误返回，返回值task.response, responseObject此处是空的，然后就是error。最后在主线程中发送通知，为当前task的userInfo，注意此处的userInfo只是用来做通知信息的。而我们平时用的时候不会用通知来获取请求成功的回调，这个通知是为了AFNetworking中的UIKit封装部分服务的。<br>然后就是成功的回调，异步请求在单利队列中，这里对队列的生成都加了单利的保护。这里通过responseSerializer 对结果数据进行转化成对应的格式（这可以参考Serialization部分，里面讲解如何转化的），如果是下载的话，responseObject直接赋值成downloadFileURL，也就是下载的话，回调中只会有下载的目标地址。然后就是对userInfo的AFNetworkingTaskDidCompleteSerializedResponseKey（序列化响应结果）、AFNetworkingTaskDidCompleteErrorKey（序列化过程中的错误信息）进行赋值，不得不说AFNetworking对各个部分的情况都返回回去了，做的很详细。<br>然后就是调用回调block：completionHandler：<br>返回值task.response也就是完整的返回头信息以及返回的状态码。<br>responseObject是返回的数据或者是下载的目标地址。<br>serializationError注意这个地方的错误是序列化的错误，也就是此处如果对返回数据序列化产生错误，也会照样返回成功回调，只是回调结果会是序列化的错误。<br>最后还是一样的发送通知。</p>
<h4 id="第二个方法："><a href="#第二个方法：" class="headerlink" title="第二个方法："></a>第二个方法：</h4><p>简单的接收到返回数据，简单的把数据进行拼接。</p>
<h4 id="第三个方法："><a href="#第三个方法：" class="headerlink" title="第三个方法："></a>第三个方法：</h4><p>下载的方法，此处如果有downloadTaskDidFinishDownloading的实现，那么进行调用转换目标地址，而目标地址是在下面这个方法的destination Block中进行设置的，这个地方转了一下，也就是倒了两个block让用户来设置这个目标地址。如果可以正常获取这个目标地址的话，把location（也就是本地下载路径，其实就是缓存路径，因为这里下载完成后会删掉）的数据转移到目标路径。响应的会有文件操作的错误信息的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="网络请求progress的封装思路"><a href="#网络请求progress的封装思路" class="headerlink" title="网络请求progress的封装思路"></a>网络请求progress的封装思路</h3><p>此处使用的技术是KVO，先看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">- (void)setupProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    __weak __typeof__(task) weakTask = task;</div><div class="line"></div><div class="line">    self.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</div><div class="line">    self.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</div><div class="line">    [self.uploadProgress setCancellable:YES];</div><div class="line">    [self.uploadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.uploadProgress setPausable:YES];</div><div class="line">    [self.uploadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line">    if ([self.uploadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.uploadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [self.downloadProgress setCancellable:YES];</div><div class="line">    [self.downloadProgress setCancellationHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask cancel];</div><div class="line">    &#125;];</div><div class="line">    [self.downloadProgress setPausable:YES];</div><div class="line">    [self.downloadProgress setPausingHandler:^&#123;</div><div class="line">        __typeof__(weakTask) strongTask = weakTask;</div><div class="line">        [strongTask suspend];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    if ([self.downloadProgress respondsToSelector:@selector(setResumingHandler:)]) &#123;</div><div class="line">        [self.downloadProgress setResumingHandler:^&#123;</div><div class="line">            __typeof__(weakTask) strongTask = weakTask;</div><div class="line">            [strongTask resume];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line">    [task addObserver:self</div><div class="line">           forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))</div><div class="line">              options:NSKeyValueObservingOptionNew</div><div class="line">              context:NULL];</div><div class="line"></div><div class="line">    [self.downloadProgress addObserver:self</div><div class="line">                            forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                               options:NSKeyValueObservingOptionNew</div><div class="line">                               context:NULL];</div><div class="line">    [self.uploadProgress addObserver:self</div><div class="line">                          forKeyPath:NSStringFromSelector(@selector(fractionCompleted))</div><div class="line">                             options:NSKeyValueObservingOptionNew</div><div class="line">                             context:NULL];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)cleanUpProgressForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesReceived))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesSent))];</div><div class="line">    [task removeObserver:self forKeyPath:NSStringFromSelector(@selector(countOfBytesExpectedToSend))];</div><div class="line">    [self.downloadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">    [self.uploadProgress removeObserver:self forKeyPath:NSStringFromSelector(@selector(fractionCompleted))];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context &#123;</div><div class="line">    if ([object isKindOfClass:[NSURLSessionTask class]] || [object isKindOfClass:[NSURLSessionDownloadTask class]]) &#123;</div><div class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesReceived))]) &#123;</div><div class="line">            self.downloadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToReceive))]) &#123;</div><div class="line">            self.downloadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesSent))]) &#123;</div><div class="line">            self.uploadProgress.completedUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(countOfBytesExpectedToSend))]) &#123;</div><div class="line">            self.uploadProgress.totalUnitCount = [change[NSKeyValueChangeNewKey] longLongValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.downloadProgress]) &#123;</div><div class="line">        if (self.downloadProgressBlock) &#123;</div><div class="line">            self.downloadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else if ([object isEqual:self.uploadProgress]) &#123;</div><div class="line">        if (self.uploadProgressBlock) &#123;</div><div class="line">            self.uploadProgressBlock(object);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化方法中我们可以看到KVO监听的KeyPath是NSURLSessionTask的四个只读属性：countOfBytesReceived, countOfBytesExpectedToReceive, countOfBytesSent, countOfBytesExpectedToSend， 也就是Task的数据统计的一些信息。 downloadProgress和uploadProgress都对fractionCompleted进行监听，也就是进度完成的百分比。<br>这里cleanUp移除所有的KVO，KVO我们平时使用的时候也是需要注意移除的，防止发生原来的还在，又添加监听导致多次监听，那么悲剧了，就是执行监听结果方法的调用越来越多。莫名其妙的bug。<br>最后KVO监听到结果的回调中，对downloadProgress，uploadProgress分别进行completedunitCount完成进度的赋值、totalUnitCount所有进度的复制。如果对象不是task而是NSProgress对象，那么直接把这个object返回回去。</p>
<h2 id="NSURLSession代理方法的转换处理"><a href="#NSURLSession代理方法的转换处理" class="headerlink" title="NSURLSession代理方法的转换处理"></a>NSURLSession代理方法的转换处理</h2><p>首先这里会有很多block的回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (void)setSessionDidBecomeInvalidBlock:(nullable void (^)(NSURLSession *session, NSError *error))block;</div><div class="line"></div><div class="line">- (void)setSessionDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">///--------------------------------------</div><div class="line">/// @name Setting Task Delegate Callbacks</div><div class="line">///--------------------------------------</div><div class="line"></div><div class="line">- (void)setTaskNeedNewBodyStreamBlock:(nullable NSInputStream * (^)(NSURLSession *session, NSURLSessionTask *task))block;</div><div class="line"></div><div class="line">- (void)setTaskWillPerformHTTPRedirectionBlock:(nullable NSURLRequest * (^)(NSURLSession *session, NSURLSessionTask *task, NSURLResponse *response, NSURLRequest *request))block;</div><div class="line"></div><div class="line">- (void)setTaskDidReceiveAuthenticationChallengeBlock:(nullable NSURLSessionAuthChallengeDisposition (^)(NSURLSession *session, NSURLSessionTask *task, NSURLAuthenticationChallenge *challenge, NSURLCredential * _Nullable __autoreleasing * _Nullable credential))block;</div><div class="line"></div><div class="line">- (void)setTaskDidSendBodyDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, int64_t bytesSent, int64_t totalBytesSent, int64_t totalBytesExpectedToSend))block;</div><div class="line"></div><div class="line">- (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block;</div><div class="line"></div><div class="line">///-------------------------------------------</div><div class="line">/// @name Setting Data Task Delegate Callbacks</div><div class="line">///-------------------------------------------</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveResponseBlock:(nullable NSURLSessionResponseDisposition (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLResponse *response))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidBecomeDownloadTaskBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSURLSessionDownloadTask *downloadTask))block;</div><div class="line"></div><div class="line">- (void)setDataTaskDidReceiveDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSData *data))block;</div><div class="line"></div><div class="line">- (void)setDataTaskWillCacheResponseBlock:(nullable NSCachedURLResponse * (^)(NSURLSession *session, NSURLSessionDataTask *dataTask, NSCachedURLResponse *proposedResponse))block;</div><div class="line"></div><div class="line">- (void)setDidFinishEventsForBackgroundURLSessionBlock:(nullable void (^)(NSURLSession *session))block;</div><div class="line"></div><div class="line">///-----------------------------------------------</div><div class="line">/// @name Setting Download Task Delegate Callbacks</div><div class="line">///-----------------------------------------------</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable  (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidWriteDataBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t bytesWritten, int64_t totalBytesWritten, int64_t totalBytesExpectedToWrite))block;</div><div class="line"></div><div class="line">- (void)setDownloadTaskDidResumeBlock:(nullable void (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, int64_t fileOffset, int64_t expectedTotalBytes))block;</div></pre></td></tr></table></figure>
<p>也就是支持对所有的NSURLSession代理方法的回调方法直接使用block传给用户使用，这里既支持我们处理原始的回调，AFNetworking在里面继续做响应的处理。</p>
<p>具体方法的处理，由于太多了，我们就分析一下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">              task:(NSURLSessionTask *)task</div><div class="line">didCompleteWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line"></div><div class="line">    // delegate may be nil when completing a task in the background</div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</div><div class="line"></div><div class="line">        [self removeDelegateForTask:task];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (self.taskDidComplete) &#123;</div><div class="line">        self.taskDidComplete(session, task, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会获取到当前task的delegate对象，然后在代理中对这些数据进行处理。这个方法是在网络完成的时候执行的，所以这里应该将这个task移除掉。数据的处理参见3)里面的AFURLSessionManagerTaskDelegate的方法解析。 最后会执行taskDidComplete的block回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session</div><div class="line">      downloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">didFinishDownloadingToURL:(NSURL *)location</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:downloadTask];</div><div class="line">    if (self.downloadTaskDidFinishDownloading) &#123;</div><div class="line">        NSURL *fileURL = self.downloadTaskDidFinishDownloading(session, downloadTask, location); // block 带入目标地址的url，在外面设置</div><div class="line">        if (fileURL) &#123;</div><div class="line">            delegate.downloadFileURL = fileURL;</div><div class="line">            NSError *error = nil;</div><div class="line">            [[NSFileManager defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</div><div class="line">            if (error) &#123;</div><div class="line">                [[NSNotificationCenter defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (delegate) &#123;</div><div class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>download的完成方法的回调，我们看到跟AFURLSessionManagerTaskDelegate中的方法功能基本是一样的，也就是如果有AFURLSessionManager类中有downloadTaskDidFinishDownloading的block实现的话，就直接在NSURLSessionDownloadDelegate中处理，如果现在还没有实现block，那么就放在delegete里面处理。注意这个地方AFURLSessionManager和NSURLSessionDownloadDelegate都有这个downloadTaskDidFinishDownloading 的block。</p>
<p>就这俩吧，其他的代理方法基本上都是转换成block进行回调，有的复杂一点需要对block的值进行处理一下，然后在回调回去。</p>
<h2 id="关于多任务的处理"><a href="#关于多任务的处理" class="headerlink" title="关于多任务的处理"></a>关于多任务的处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = nil;</div><div class="line">    [self.lock lock];</div><div class="line">    delegate = self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line"></div><div class="line">    return delegate;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</div><div class="line">            forTask:(NSURLSessionTask *)task</div><div class="line">&#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line">    NSParameterAssert(delegate);</div><div class="line"></div><div class="line">    [self.lock lock];</div><div class="line">    self.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</div><div class="line">    [delegate setupProgressForTask:task];</div><div class="line">    [self addNotificationObserverForTask:task];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDataTask:(NSURLSessionDataTask *)dataTask</div><div class="line">                uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">              downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">             completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    dataTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line">    [self setDelegate:delegate forTask:dataTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForUploadTask:(NSURLSessionUploadTask *)uploadTask</div><div class="line">                        progress:(void (^)(NSProgress *uploadProgress)) uploadProgressBlock</div><div class="line">               completionHandler:(void (^)(NSURLResponse *response, id responseObject, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    uploadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:uploadTask];</div><div class="line"></div><div class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addDelegateForDownloadTask:(NSURLSessionDownloadTask *)downloadTask</div><div class="line">                          progress:(void (^)(NSProgress *downloadProgress)) downloadProgressBlock</div><div class="line">                       destination:(NSURL * (^)(NSURL *targetPath, NSURLResponse *response))destination</div><div class="line">                 completionHandler:(void (^)(NSURLResponse *response, NSURL *filePath, NSError *error))completionHandler</div><div class="line">&#123;</div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</div><div class="line">    delegate.manager = self;</div><div class="line">    delegate.completionHandler = completionHandler;</div><div class="line"></div><div class="line">    if (destination) &#123;</div><div class="line">        delegate.downloadTaskDidFinishDownloading = ^NSURL * (NSURLSession * __unused session, NSURLSessionDownloadTask *task, NSURL *location) &#123;</div><div class="line">            return destination(location, task.response);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    downloadTask.taskDescription = self.taskDescriptionForSessionTasks;</div><div class="line"></div><div class="line">    [self setDelegate:delegate forTask:downloadTask];</div><div class="line"></div><div class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123;</div><div class="line">    NSParameterAssert(task);</div><div class="line"></div><div class="line">    AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task];</div><div class="line">    [self.lock lock];</div><div class="line">    [delegate cleanUpProgressForTask:task];</div><div class="line">    [self removeNotificationObserverForTask:task];</div><div class="line">    [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</div><div class="line">    [self.lock unlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里是支持多任务请求的。这里使用字典存的是当前task的代理AFURLSessionManagerTaskDelegate的delegate：<br>@property (readwrite, nonatomic, strong) NSMutableDictionary *mutableTaskDelegatesKeyedByTaskIdentifier;<br>也就是所有的请求会把代理使用task的taskIdentifier标记存起来。设置代理的时候加了保护锁，保证可变字典的安全操作。</p>
<h2 id="AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"><a href="#AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state" class="headerlink" title="_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state"></a>_AFURLSessionTaskSwizzling，使用runtime方法对resume和suspend进行处理task的state</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    if (NSClassFromString(@&quot;NSURLSessionTask&quot;)) &#123;</div><div class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        NSURLSession * session = [NSURLSession sessionWithConfiguration:configuration];</div><div class="line">#pragma GCC diagnostic push</div><div class="line">#pragma GCC diagnostic ignored &quot;-Wnonnull&quot;</div><div class="line">        NSURLSessionDataTask *localDataTask = [session dataTaskWithURL:nil];</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([self class], @selector(af_resume)));</div><div class="line">        Class currentClass = [localDataTask class];</div><div class="line">        </div><div class="line">        while (class_getInstanceMethod(currentClass, @selector(resume))) &#123;</div><div class="line">            Class superClass = [currentClass superclass];</div><div class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, @selector(resume)));</div><div class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, @selector(resume)));</div><div class="line">            if (classResumeIMP != superclassResumeIMP &amp;&amp;</div><div class="line">                originalAFResumeIMP != classResumeIMP) &#123;</div><div class="line">                [self swizzleResumeAndSuspendMethodForClass:currentClass];</div><div class="line">            &#125;</div><div class="line">            currentClass = [currentClass superclass];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        [localDataTask cancel];</div><div class="line">        [session finishTasksAndInvalidate];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (void)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</div><div class="line">    Method afResumeMethod = class_getInstanceMethod(self, @selector(af_resume));</div><div class="line">    Method afSuspendMethod = class_getInstanceMethod(self, @selector(af_suspend));</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_resume), afResumeMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(resume), @selector(af_resume));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (af_addMethod(theClass, @selector(af_suspend), afSuspendMethod)) &#123;</div><div class="line">        af_swizzleSelector(theClass, @selector(suspend), @selector(af_suspend));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSURLSessionTaskState)state &#123;</div><div class="line">    NSAssert(NO, @&quot;State method should never be called in the actual dummy class&quot;);</div><div class="line">    return NSURLSessionTaskStateCanceling;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_resume &#123; // 通过Swizzle发通知AFNSURLSessionTaskDidResumeNotification</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_resume];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateRunning) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)af_suspend &#123;</div><div class="line">    NSAssert([self respondsToSelector:@selector(state)], @&quot;Does not respond to state&quot;);</div><div class="line">    NSURLSessionTaskState state = [self state];</div><div class="line">    [self af_suspend];</div><div class="line">    </div><div class="line">    if (state != NSURLSessionTaskStateSuspended) &#123;</div><div class="line">        [[NSNotificationCenter defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:self];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用runtime技术的swizzle方法对新初始化的一个NSURLSessionDataTask对象进行方法替换。替换resume方法的实现为af_resume，suspend的方法实现为af_suspend。这里面对当前的NSURLSessionTaskState进行操作。</p>
<h1 id="AFHTTPSessionManager"><a href="#AFHTTPSessionManager" class="headerlink" title="AFHTTPSessionManager"></a>AFHTTPSessionManager</h1><p>这部分是继承自AFURLSessionManager，如果是AFURLSessionManager是网络的核心部分，那么这部分就是方便开发者调用的一个实现部分。<br>这里面其实封装的比较简单。看一下属性数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic, strong, nullable) NSURL *baseURL;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPRequestSerializer &lt;AFURLRequestSerialization&gt; * requestSerializer;</div><div class="line"></div><div class="line">@property (nonatomic, strong) AFHTTPResponseSerializer &lt;AFURLResponseSerialization&gt; * responseSerializer;</div></pre></td></tr></table></figure>
<p>里面一个基本的URL，请求序列化，响应序列化。注意这个地方，请求序列化是在AFHTTPSessionManager中做的处理，而responseSerializer是在AFURLSessionManager中做的处理。</p>
<p>初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)manager;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url;</div><div class="line"></div><div class="line">- (instancetype)initWithBaseURL:(nullable NSURL *)url</div><div class="line">           sessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<p>这里支持类方法和实例方法。当然了类方法是封装的实例方法。</p>
<p>提供的网络请求方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                            parameters:(nullable id)parameters</div><div class="line">                              progress:(nullable void (^)(NSProgress *downloadProgress))downloadProgress</div><div class="line">                               success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                               failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)HEAD:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(nullable id)parameters</div><div class="line">     constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                       success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                       failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure DEPRECATED_ATTRIBUTE;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                             parameters:(nullable id)parameters</div><div class="line">              constructingBodyWithBlock:(nullable void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                               progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgress</div><div class="line">                                success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                                failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PUT:(NSString *)URLString</div><div class="line">                   parameters:(nullable id)parameters</div><div class="line">                      success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                      failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)PATCH:(NSString *)URLString</div><div class="line">                     parameters:(nullable id)parameters</div><div class="line">                        success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                        failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div><div class="line"></div><div class="line">- (nullable NSURLSessionDataTask *)DELETE:(NSString *)URLString</div><div class="line">                      parameters:(nullable id)parameters</div><div class="line">                         success:(nullable void (^)(NSURLSessionDataTask *task, id _Nullable responseObject))success</div><div class="line">                         failure:(nullable void (^)(NSURLSessionDataTask * _Nullable task, NSError *error))failure;</div></pre></td></tr></table></figure>
<p>以上是提供的所有的方法，HTTP协议的基本请求类型GET，POST，PUT，HEAD，DELETE都封装了。</p>
<p>下面我们看一下GET的实现，因为其他的思路都是一样的，出了POST另外增加了一种body类型的封装。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)GET:(NSString *)URLString</div><div class="line">                   parameters:(id)parameters</div><div class="line">                     progress:(void (^)(NSProgress * _Nonnull))downloadProgress</div><div class="line">                      success:(void (^)(NSURLSessionDataTask * _Nonnull, id _Nullable))success</div><div class="line">                      failure:(void (^)(NSURLSessionDataTask * _Nullable, NSError * _Nonnull))failure</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSURLSessionDataTask *dataTask = [self dataTaskWithHTTPMethod:@&quot;GET&quot;</div><div class="line">                                                        URLString:URLString</div><div class="line">                                                       parameters:parameters</div><div class="line">                                                   uploadProgress:nil</div><div class="line">                                                 downloadProgress:downloadProgress</div><div class="line">                                                          success:success</div><div class="line">                                                          failure:failure];</div><div class="line"></div><div class="line">    [dataTask resume];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到调用的是dataTaskWithHTTPMethod: URLString: parameters: uploadProgress: downloadProgress: success: failure:方法。除了POST新增的方法，其他的都是直接调用的这个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)dataTaskWithHTTPMethod:(NSString *)method</div><div class="line">                                       URLString:(NSString *)URLString</div><div class="line">                                      parameters:(id)parameters</div><div class="line">                                  uploadProgress:(nullable void (^)(NSProgress *uploadProgress)) uploadProgress</div><div class="line">                                downloadProgress:(nullable void (^)(NSProgress *downloadProgress)) downloadProgress</div><div class="line">                                         success:(void (^)(NSURLSessionDataTask *, id))success</div><div class="line">                                         failure:(void (^)(NSURLSessionDataTask *, NSError *))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer requestWithMethod:method URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *dataTask = nil;</div><div class="line">    dataTask = [self dataTaskWithRequest:request</div><div class="line">                          uploadProgress:uploadProgress</div><div class="line">                        downloadProgress:downloadProgress</div><div class="line">                       completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(dataTask, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(dataTask, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是简单的把请求数据进行了序列化，如果错误的话就直接返回nil，不会发送任何请求。成功的话，进行调用AFURLSessionManager中的方法，最后对返回值进行了简单处理。封装的还算简单，没有太多复杂的逻辑。</p>
<p>最后看一下POST的另一个增加的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">- (NSURLSessionDataTask *)POST:(NSString *)URLString</div><div class="line">                    parameters:(id)parameters</div><div class="line">     constructingBodyWithBlock:(void (^)(id &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                      progress:(nullable void (^)(NSProgress * _Nonnull))uploadProgress</div><div class="line">                       success:(void (^)(NSURLSessionDataTask *task, id responseObject))success</div><div class="line">                       failure:(void (^)(NSURLSessionDataTask *task, NSError *error))failure</div><div class="line">&#123;</div><div class="line">    NSError *serializationError = nil;</div><div class="line">    NSMutableURLRequest *request = [self.requestSerializer multipartFormRequestWithMethod:@&quot;POST&quot; URLString:[[NSURL URLWithString:URLString relativeToURL:self.baseURL] absoluteString] parameters:parameters constructingBodyWithBlock:block error:&amp;serializationError];</div><div class="line">    if (serializationError) &#123;</div><div class="line">        if (failure) &#123;</div><div class="line">#pragma clang diagnostic push</div><div class="line">#pragma clang diagnostic ignored &quot;-Wgnu&quot;</div><div class="line">            dispatch_async(self.completionQueue ?: dispatch_get_main_queue(), ^&#123;</div><div class="line">                failure(nil, serializationError);</div><div class="line">            &#125;);</div><div class="line">#pragma clang diagnostic pop</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __block NSURLSessionDataTask *task = [self uploadTaskWithStreamedRequest:request progress:uploadProgress completionHandler:^(NSURLResponse * __unused response, id responseObject, NSError *error) &#123;</div><div class="line">        if (error) &#123;</div><div class="line">            if (failure) &#123;</div><div class="line">                failure(task, error);</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (success) &#123;</div><div class="line">                success(task, responseObject);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [task resume];</div><div class="line"></div><div class="line">    return task;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装思路跟上面的基本上是一样的，序列化数据的时候会把body的内容封装在请求body里面：<br> [self.requestsetHTTPBodyStream:self.bodyStream];<br> 相应的这里调用的是AFURLSessionManager中的StreamRequest方法。</p>
<p>如果文中有什么错误，欢迎指正。</p>
<p>更多问题讨论欢迎加QQ群：200792066</p>
<p>转载请注明出处：<a href="http://semyonxu.com">http://semyonxu.com</a></p>
]]></content>
    </entry>
    
  
  
</search>
